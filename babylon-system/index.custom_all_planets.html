<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Solar Babylon - Orbit + Free Fly + Surface (Chunks/LOD)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#050505}
    #renderCanvas{width:100%;height:100%;touch-action:none;display:block}
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family: 'Segoe UI', sans-serif;
      color:#eee; background:rgba(0,0,0,.65); border:1px solid rgba(255,255,255,.15);
      padding:12px; border-radius:10px; backdrop-filter: blur(4px);
      width: 360px;
    }
    h1{font-size:14px;margin:0 0 10px 0;color:#fa0}
    .row{display:flex;align-items:center;gap:8px;margin:7px 0;font-size:12px}
    .btn{cursor:pointer;background:#2b2b2b;color:#fff;border:1px solid #555;padding:6px 10px;border-radius:6px;font-size:11px}
    .btn:hover{background:#444}
    .btn.primary{border-color:#a80;background:#3a2b10}
    .btn.primary:hover{background:#4a3412}
    select.btn{appearance:none}
    label{color:#ddd}
    .info{font-size:10px;color:#aaa;margin-top:8px;line-height:1.35}
    .split{display:flex;gap:8px}
    .split > *{flex:1}
    #debugInfo{margin-top:8px;font-size:10px;color:#cfc}
	.chk{transform:translateY(1px)}
    .pill{display:inline-block;padding:2px 6px;border:1px solid rgba(255,255,255,.15);border-radius:999px;font-size:10px;color:#ddd}
  </style>
</head>
<body>
  <div id="ui">
    <h1>ü™ê Solar Babylon <span class="pill" id="modePill">√ìrbita</span></h1>

    <div class="row split">
      <button id="camOrbit" class="btn primary">√ìrbita</button>
      <button id="camFly" class="btn">Vuelo libre</button>
      <button id="camSurface" class="btn">Superficie</button>
    </div>

    <div class="row">
      <label>Tiempo</label>
      <input id="speedRange" type="range" min="0" max="50" value="1" step="0.1" style="flex:1">
      <span id="speedVal" class="pill">1.0x</span>
    </div>

    <div class="row">
      <label>Objetivo</label>
      <select id="planetSelect" class="btn" style="flex:1"></select>
      <button id="approachBtn" class="btn">Aproximar</button>
    </div>
	
    <div class="row">
      <label style="flex:1">Nombres</label>
      <input id="toggleLabels" class="chk" type="checkbox" checked>
      <span class="pill" id="labelsPill">ON</span>
    </div>

    <div class="info">
      <b>Vuelo libre:</b> WASD mover, rat√≥n mirar, Shift correr, Espacio subir, Ctrl bajar.<br>
      <b>Superficie:</b> WASD mover, rat√≥n mirar, Espacio saltar, Shift correr. Gravedad hacia el centro.<br>
      <b>LOD/chunks:</b> solo en el planeta activo en modo Superficie para no matar la CPU.
    </div>

    <div id="debugInfo">Chunks activos: 0 | FPS: 0</div>
  </div>

  <canvas id="renderCanvas"></canvas>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>

  <script>
    // ====================================================================
    // 0) Engine
    // ====================================================================
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: false,
      stencil: false,
      powerPreference: "high-performance",
      adaptToDeviceRatio: true,
    });
    // Rendimiento: baja resoluci√≥n interna en pantallas densas
    try {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      // 1.0 = nativo, 1.25-1.6 suele ser un buen equilibrio
      engine.setHardwareScalingLevel(dpr > 1.25 ? 1.35 : 1.0);
    } catch(e) {}

    // ====================================================================
    // 1) Noise (determinista) + FBM
    // ====================================================================
    function hash3(x, y, z) {
      x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
      const s = Math.sin(x * 127.1 + y * 311.7 + z * 74.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smooth(t){ return t*t*(3-2*t); }
    function noise3(x, y, z) {
      const xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
      const xf = x - xi, yf = y - yi, zf = z - zi;
      const u = smooth(xf), v = smooth(yf), w = smooth(zf);

      const n000 = hash3(xi,yi,zi),     n100 = hash3(xi+1,yi,zi);
      const n010 = hash3(xi,yi+1,zi),   n110 = hash3(xi+1,yi+1,zi);
      const n001 = hash3(xi,yi,zi+1),   n101 = hash3(xi+1,yi,zi+1);
      const n011 = hash3(xi,yi+1,zi+1), n111 = hash3(xi+1,yi+1,zi+1);

      const x00 = lerp(n000, n100, u), x10 = lerp(n010, n110, u);
      const x01 = lerp(n001, n101, u), x11 = lerp(n011, n111, u);
      const y0  = lerp(x00, x10, v),   y1  = lerp(x01, x11, v);
      return lerp(y0, y1, w);
    }
    function fbm3(x, y, z, oct=6, pers=0.5, lac=2.0) {
      let total = 0, f = 1, a = 1, maxV = 0;
      for (let i=0;i<oct;i++){
        total += noise3(x*f, y*f, z*f) * a;
        maxV += a;
        a *= pers;
        f *= lac;
      }
      return total / Math.max(1e-6, maxV); // 0..1
    }

    // ====================================================================
    // 1b) Helpers + Macro shaping (configurable per planet)
    // ====================================================================
    const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
    const clamp01 = (x)=>clamp(x,0,1);
    const smoothstep = (t)=>t*t*(3-2*t);

    // Macro params: define per planet in bodyDefs with: 
    //   macro: { type: 'continents', lobes:2, continentFreq:0.55, continentStrength:0.55, 
    //            threshold:0.62, width:0.25, islandsFreq:4.8, islandsStrength:0.22, coastWidth:0.32 }
    // Back-compat: if you set continentFreq/continentStrength/islandsFreq/islandsStrength on the def,
    // it will behave like Richese but works for ANY planet.
    function getMacroFromDef(def) {
      if (!def) return null;
      if (def.macro && typeof def.macro === 'object') return def.macro;
      // Legacy fields -> macro continents+archipelago
      if (def.continentFreq!=null || def.continentStrength!=null || def.islandsFreq!=null || def.islandsStrength!=null) {
        return {
          type: 'continents',
          lobes: 2,
          continentFreq: def.continentFreq ?? 0.55,
          continentStrength: def.continentStrength ?? 0.55,
          threshold: def.continentThreshold ?? 0.62,
          width: def.continentWidth ?? 0.25,
          islandsFreq: def.islandsFreq ?? 4.8,
          islandsStrength: def.islandsStrength ?? 0.22,
          coastWidth: def.coastWidth ?? 0.32,
        };
      }
      return null;
    }

    function applyMacroElevation(pOnSphere, elev, defLike, seed) {
      const macro = getMacroFromDef(defLike);
      if (!macro) return elev;

      const amp = defLike.terrainScale ?? 0.12;
      const sea = defLike.seaLevel ?? 0.0;
      const wx = pOnSphere.x, wy = pOnSphere.y, wz = pOnSphere.z;

      if (macro.type === 'continents') {
        const lobes = macro.lobes ?? 2;
        const cF = macro.continentFreq ?? 0.55;
        const cS = macro.continentStrength ?? 0.55;
        const thr = macro.threshold ?? 0.62;
        const wid = macro.width ?? 0.25;

        const theta = Math.atan2(wz, wx);
        const lobeMask = (Math.cos(theta * lobes + (seed||0) * 0.02) * 0.5 + 0.5);
        const contN = fbm3(wx * cF + 7.1 + (seed||0), wy * cF + 1.3 + (seed||0), wz * cF + 4.7 + (seed||0), 3);
        let cont = (lobeMask * 0.65 + contN * 0.65);
        cont = clamp01((cont - thr) / Math.max(1e-6, wid));
        cont = smoothstep(cont);
        elev += cont * amp * (1.35 * cS);

        // archipelago near coasts (optional)
        const iF = macro.islandsFreq ?? null;
        const iS = macro.islandsStrength ?? 0.0;
        if (iF && iS > 0) {
          const coastW = macro.coastWidth ?? 0.32;
          const coast01 = 1.0 - clamp01(Math.abs((elev - sea) / (amp * coastW)));
          const islN = fbm3(wx * iF + 31.7 + (seed||0), wy * iF + 9.9 + (seed||0), wz * iF + 21.1 + (seed||0), 3);
          const isl = clamp01((islN - 0.58) * 2.6);
          elev += isl * coast01 * amp * (iS);
        }

        return elev;
      }

      if (macro.type === 'bands') {
        // e.g. dunes / latitudinal bands
        const freq = macro.freq ?? 16.0;
        const strength = macro.strength ?? 0.08;
        const axis = macro.axis ?? 'xz';
        let v = 0;
        if (axis === 'x') v = wx;
        else if (axis === 'y') v = wy;
        else if (axis === 'z') v = wz;
        else v = (wx + wz);
        const band = (Math.sin(v * freq) * 0.5 + 0.5) * strength;
        elev += band * amp * (macro.ampMul ?? 0.55);
        return elev;
      }

      return elev;
    }

    function getCustomBiomeColor(biome, pOnSphere, elevation, seaLevel, terrainScale, seed) {
      const lerp3 = (a,b,t) => new BABYLON.Color3(
        lerp(a.r,b.r,t), lerp(a.g,b.g,t), lerp(a.b,b.b,t)
      );
      const deep  = biome.waterDeep   || new BABYLON.Color3(0.02,0.10,0.18);
      const water = biome.water       || biome.waterShallow || new BABYLON.Color3(0.04,0.20,0.30);
      const shore = biome.shore       || new BABYLON.Color3(0.80,0.74,0.56);
      const low   = biome.lowland     || new BABYLON.Color3(0.18,0.50,0.22);
      const high  = biome.highland    || biome.rock || new BABYLON.Color3(0.32,0.30,0.28);
      const peakC = biome.peak        || new BABYLON.Color3(0.60,0.60,0.60);

      const h = elevation;
      const h01 = clamp01((h - seaLevel) / Math.max(1e-6, (terrainScale * 1.2)));

      if (h < 0.0) {
        const d = clamp01((-h) * (biome.waterDepthFalloff ?? 10));
        return lerp3(water, deep, d);
      }

      const coastSharp = biome.coastSharpness ?? 55;
      const coast = clamp01(1 - Math.abs(h) * coastSharp);

      let land = (h01 < (biome.highlandStart ?? 0.55))
        ? low
        : lerp3(low, high, clamp01((h01 - (biome.highlandStart ?? 0.55)) * (biome.highlandSlope ?? 1.9)));

      land = lerp3(land, shore, coast);

      // optional lagoons / stains
      const lagoonStrength = biome.lagoonStrength ?? 0;
      if (lagoonStrength > 0) {
        const aqua = biome.aqua || new BABYLON.Color3(0.08,0.42,0.40);
        const lagoon = clamp01((fbm3(pOnSphere.x*6+(seed||0), pOnSphere.y*6+(seed||0), pOnSphere.z*6+(seed||0), 2) - 0.58) * 3.4);
        land = lerp3(land, aqua, lagoon * lagoonStrength);
      }

      // peaks
      const ps = biome.peakStart ?? 0.72;
      const pr = biome.peakRange ?? 0.20;
      let peak = clamp01((h01 - ps) / Math.max(1e-6, pr));
      peak = smoothstep(peak);
      land = lerp3(land, peakC, peak);

      return land;
    }

    // ====================================================================
    // 2) Chunks / Quadtree terrain (cube-sphere)
    // ====================================================================
    class PlanetChunk {
      constructor(parentPlanet, radius, detailLevel, localUp, bounds, material, seed) {
        this.scene = parentPlanet.scene;
        this.parentPlanet = parentPlanet;
        this.localUp = localUp;
        this.bounds = bounds; // {minX,maxX,minY,maxY} in [0..1]
        this.detailLevel = detailLevel;
        this.radius = radius;
        this.material = material;
        this.seed = seed;

        this.children = [];
        this.isLeaf = true;
        this.mesh = null;

        // split distance tuned for web
        this.splitDistance = radius * (1.9 / Math.pow(1.85, detailLevel));
        this.mergeDistance = this.splitDistance * 1.35; // hysteresis
        this.buildMesh();
      }

      buildMesh() {
        const resolution = this.parentPlanet.chunkResolution; // vertices per side
        const positions = [];
        const indices = [];
        const normals = [];
        const uvs = [];
        const colors = []; // vertex colors (biomas)

        const axisA = new BABYLON.Vector3(this.localUp.y, this.localUp.z, this.localUp.x);
        const axisB = BABYLON.Vector3.Cross(this.localUp, axisA);

        for (let y = 0; y <= resolution; y++) {
          for (let x = 0; x <= resolution; x++) {
            const px = x / resolution;
            const py = y / resolution;

            const localX = this.bounds.minX + (this.bounds.maxX - this.bounds.minX) * px;
            const localY = this.bounds.minY + (this.bounds.maxY - this.bounds.minY) * py;

            const pointOnCube = this.localUp
              .add(axisA.scale((localX - 0.5) * 2))
              .add(axisB.scale((localY - 0.5) * 2));

            const pointOnSphere = pointOnCube.clone().normalize();

            // Terrain
            let elevation = 0;
            if (this.parentPlanet.hasTerrain) {
              const f = this.parentPlanet.noiseFrequency;
              const n = fbm3(
                pointOnSphere.x * f + this.seed,
                pointOnSphere.y * f + this.seed,
                pointOnSphere.z * f + this.seed,
                this.parentPlanet.noiseOctaves
              );

              // mountains
              elevation = (n * 2 - 1) * this.parentPlanet.terrainScale;
              // Macro shaping (continents/archipi√©lagos/bandas...) configurable por planeta
              elevation = applyMacroElevation(pointOnSphere, elevation, this.parentPlanet, this.seed);
              // clamp m√≠nimo (permite negativos si seaLevel es negativo)
              elevation = Math.max(elevation, this.parentPlanet.seaLevel);
            }

            const finalPos = pointOnSphere.scale(this.radius * (1 + elevation));
            positions.push(finalPos.x, finalPos.y, finalPos.z);

            // normals initial, recomputed later
            normals.push(pointOnSphere.x, pointOnSphere.y, pointOnSphere.z);

            // (simple) face UVs; good enough for material blending, not for full textures
            uvs.push(px, py);
			
            // Biomes via vertex colors (look ‚Äúprocedural ficticio‚Äù)
            const c = this.parentPlanet.getBiomeColor(pointOnSphere, elevation);
            colors.push(c.r, c.g, c.b, 1.0);
          }
        }

        for (let y = 0; y < resolution; y++) {
          for (let x = 0; x < resolution; x++) {
            const i = x + y * (resolution + 1);
            indices.push(i, i + 1, i + resolution + 1);
            indices.push(i + 1, i + resolution + 2, i + resolution + 1);
          }
        }

        const mesh = new BABYLON.Mesh(`chunk_L${this.detailLevel}`, this.scene);
        const vd = new BABYLON.VertexData();
        vd.positions = positions;
        vd.indices = indices;
        vd.normals = normals;
        vd.uvs = uvs;
		vd.colors = colors;
        vd.applyToMesh(mesh);

        // recompute normals for terrain
        const tempNormals = [];
        BABYLON.VertexData.ComputeNormals(positions, indices, tempNormals);
        mesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind, tempNormals);
        // Low-poly look (faceted). Evitar hacerlo en LOD muy alto para no matar CPU.
        if (this.detailLevel <= 4 && this.parentPlanet.chunkResolution <= 16) {
          try { mesh.convertToFlatShadedMesh(); } catch(e) {}
        }

        mesh.material = this.material;
        mesh.parent = this.parentPlanet.root;
        mesh.isPickable = true;

        // we do raycast picking, no heavy physics impostors
        mesh.checkCollisions = false;

        if (this.parentPlanet.shadowGen) {
          this.parentPlanet.shadowGen.addShadowCaster(mesh);
          mesh.receiveShadows = true;
        }

        this.mesh = mesh;
      }

      updateLOD(cameraPos) {
        if (!this.mesh) return;

        // Measure distance to surface patch: camera to chunk bounding sphere center approximation
        const dist = BABYLON.Vector3.Distance(cameraPos, this.mesh.getBoundingInfo().boundingSphere.centerWorld);

        if (dist < this.splitDistance && this.detailLevel < this.parentPlanet.maxDetailLevel) {
          if (this.isLeaf) this.parentPlanet._requestSplit(this);
          if (!this.isLeaf) for (const c of this.children) c.updateLOD(cameraPos);
        } else if (dist > (this.mergeDistance || (this.splitDistance * 1.35))) {
          if (!this.isLeaf) this.merge();
        }
      }

      split() {
        this.isLeaf = false;
        this.mesh.setEnabled(false);

        const next = this.detailLevel + 1;
        const b = this.bounds;
        const midX = (b.minX + b.maxX) / 2;
        const midY = (b.minY + b.maxY) / 2;

        const b1 = { minX: b.minX, maxX: midX, minY: b.minY, maxY: midY };
        const b2 = { minX: midX, maxX: b.maxX, minY: b.minY, maxY: midY };
        const b3 = { minX: b.minX, maxX: midX, minY: midY, maxY: b.maxY };
        const b4 = { minX: midX, maxX: b.maxX, minY: midY, maxY: b.maxY };

        this.children = [
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b1, this.material, this.seed),
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b2, this.material, this.seed),
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b3, this.material, this.seed),
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b4, this.material, this.seed),
        ];
      }

      merge() {
        this.isLeaf = true;
        this.mesh.setEnabled(true);
        for (const c of this.children) c.dispose();
        this.children = [];
      }

      dispose() {
        if (this.mesh) {
          if (this.parentPlanet.shadowGen) this.parentPlanet.shadowGen.removeShadowCaster(this.mesh);
          this.mesh.dispose();
          this.mesh = null;
        }
        for (const c of this.children) c.dispose();
      }
    }

    class ProceduralPlanet {
      constructor(scene, name, radius, shadowGen) {
        this.scene = scene;
        this.name = name;
        this.radius = radius;
        this.shadowGen = shadowGen;

        this.root = new BABYLON.TransformNode(name + "_procRoot", scene);
        this.faces = [];

        // Tuning
        this.hasTerrain = true;
        this.terrainScale = 0.15;  // Aumentado para monta√±as m√°s altas
        this.seaLevel = -0.02;     // clamp (negativo => permite ‚Äúmar‚Äù visual)
        this.noiseFrequency = 3.5; // Frecuencia m√°s alta para m√°s detalle rocoso
        this.noiseOctaves = 7;     // M√°s octavas para fractales m√°s complejos

        this.chunkResolution = 18; // 18 => (19x19) vertices per chunk
        this.maxDetailLevel = 6;   // keep sane on web

        // Material para chunks de superficie (StandardMaterial = m√°s barato que PBR)
        this.material = new BABYLON.StandardMaterial(name + "_procMat", scene);
        this.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        this.material.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
        this.material.useVertexColor = true;
        // Congelar una vez creado (reduce overhead)
        try { this.material.freeze(); } catch(e) {}

        // Macro shaping (opcional)
        this.macro = null;

        // Preset de biomas (se sobreescribe por planeta)
        this.biomePreset = "default";
        // Bioma custom por planeta (opcional). Si existe, tiene prioridad sobre biomePreset.
        this.biome = null;

        // Atmosphere (optional)
        this.atmo = null;

        // seed per planet
        this.seed = (name.length * 17.13) % 1000;

        const dirs = [
          new BABYLON.Vector3(0, 1, 0), new BABYLON.Vector3(0, -1, 0),
          new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(-1, 0, 0),
          new BABYLON.Vector3(0, 0, 1), new BABYLON.Vector3(0, 0, -1)
        ];

        for (const dir of dirs) {
          this.faces.push(new PlanetChunk(
            this,
            this.radius,
            0,
            dir,
            { minX: 0, maxX: 1, minY: 0, maxY: 1 },
            this.material,
            this.seed
          ));
        }

        this.enabled = true;
        // Rendimiento: limitar splits por frame para evitar tirones
        this._splitQueue = [];
        this._maxSplitsPerFrame = 6;
        this.setEnabled(false); // start hidden, enabled only in surface mode
      }
	  
      // Color por bioma (inspirado en Dune / planetas ficticios)
      getBiomeColor(pOnSphere, elevation) {
        // Bioma custom por planeta (opcional)
        if (this.biome && typeof this.biome === 'object') {
          return getCustomBiomeColor(this.biome, pOnSphere, elevation, this.seaLevel, this.terrainScale, this.seed);
        }

        const clamp01 = (x) => Math.max(0, Math.min(1, x));
        const lerp3 = (a,b,t) => new BABYLON.Color3(
          lerp(a.r,b.r,t), lerp(a.g,b.g,t), lerp(a.b,b.b,t)
        );

        // normaliza altura a 0..1 aprox
        const h = elevation; // suele estar en [-0.02 .. +0.16] seg√∫n preset
        const h01 = clamp01((h - this.seaLevel) / Math.max(1e-6, (this.terrainScale * 1.2)));

        // latitud 0..1 (para nieve en polos si aplica)
        const lat = clamp01(Math.abs(pOnSphere.y));

        // presets
        if (this.biomePreset === "arrakis") {
          // Desierto: arena + roca oscura en monta√±as, casi sin agua
          const sand = new BABYLON.Color3(0.82, 0.70, 0.46);
          const dune = new BABYLON.Color3(0.90, 0.78, 0.52);
          const rock = new BABYLON.Color3(0.35, 0.29, 0.22);
          const t = clamp01(Math.pow(h01, 1.2));
          // dunas (ligero ‚Äúbandeado‚Äù)
          const band = (Math.sin((pOnSphere.x + pOnSphere.z) * 18.0) * 0.5 + 0.5) * 0.08;
          const base = lerp3(sand, dune, clamp01(t + band));
          return lerp3(base, rock, clamp01((h01 - 0.65) * 2.2));
        }

        if (this.biomePreset === "caladan") {
          // Oce√°nico: agua profunda + costas claras + verde h√∫medo + nieve en picos/polos
          const deep = new BABYLON.Color3(0.03, 0.12, 0.22);
          const water = new BABYLON.Color3(0.05, 0.22, 0.35);
          const shore = new BABYLON.Color3(0.78, 0.72, 0.55);
          const green = new BABYLON.Color3(0.16, 0.48, 0.18);
          const rock  = new BABYLON.Color3(0.30, 0.28, 0.25);
          const snow  = new BABYLON.Color3(0.92, 0.92, 0.92);

          if (h < 0.0) {
            const d = clamp01((-h) * 10);
            return lerp3(water, deep, d);
          }
          // costa cerca de 0
          const coast = clamp01(1 - Math.abs(h) * 55);
          let land = (h01 < 0.55) ? green : lerp3(green, rock, clamp01((h01 - 0.55) * 1.8));
          land = lerp3(land, shore, coast);
          // nieve por altura + polos
          const snowMask = clamp01((h01 - 0.82) * 4.0) * clamp01((lat - 0.25) * 1.4 + 0.3);
          return lerp3(land, snow, snowMask);
        }

        if (this.biomePreset === "giedi") {
          // Industrial oscuro: basaltos, ceniza, ‚Äúbrillos‚Äù verdosos
          const ash = new BABYLON.Color3(0.10, 0.10, 0.11);
          const basalt = new BABYLON.Color3(0.18, 0.17, 0.16);
          const metal = new BABYLON.Color3(0.22, 0.23, 0.24);
          const toxic = new BABYLON.Color3(0.10, 0.22, 0.12);
          const t = clamp01(Math.pow(h01, 1.1));
          let c = lerp3(ash, basalt, t);
          c = lerp3(c, metal, clamp01((h01 - 0.6) * 2.0));
          // ‚Äúmanchas‚Äù verdosas sutiles
          const stain = clamp01((fbm3(pOnSphere.x*5+this.seed, pOnSphere.y*5+this.seed, pOnSphere.z*5+this.seed, 3) - 0.55) * 3.0);
          c = lerp3(c, toxic, stain * 0.35);
          return c;
        }

        if (this.biomePreset === "ice") {
          // Helado: hielo + roca
          const ice = new BABYLON.Color3(0.78, 0.86, 0.92);
          const snow = new BABYLON.Color3(0.94, 0.95, 0.96);
          const rock = new BABYLON.Color3(0.32, 0.32, 0.35);
          const t = clamp01(h01);
          let c = lerp3(ice, snow, clamp01((t - 0.2) * 1.4));
          c = lerp3(c, rock, clamp01((t - 0.75) * 2.0));
          return c;
        }

        if (this.biomePreset === "ix") {
          // Ix: fr√≠o/tecnol√≥gico (acero + hielo + roca)
          const steel = new BABYLON.Color3(0.38, 0.42, 0.46);
          const rock  = new BABYLON.Color3(0.24, 0.25, 0.28);
          const ice   = new BABYLON.Color3(0.82, 0.88, 0.94);
          const t = clamp01(Math.pow(h01, 1.1));
          let c = lerp3(steel, rock, clamp01((t - 0.35) * 1.5));
          const frost = clamp01((lat - 0.18) * 1.6) * clamp01((0.55 - h01) * 2.0);
          c = lerp3(c, ice, frost);
          return c;
        }

        if (this.biomePreset === "kaitain") {
          // Kaitain: templado imperial (praderas, tierras claras, mares)
          const water = new BABYLON.Color3(0.05, 0.18, 0.30);
          const deep  = new BABYLON.Color3(0.02, 0.08, 0.16);
          const shore = new BABYLON.Color3(0.80, 0.74, 0.56);
          const grass = new BABYLON.Color3(0.20, 0.55, 0.22);
          const soil  = new BABYLON.Color3(0.58, 0.52, 0.38);
          const rock  = new BABYLON.Color3(0.32, 0.30, 0.28);

          if (h < 0.0) {
            const d = clamp01((-h) * 10);
            return lerp3(water, deep, d);
          }
          const coast = clamp01(1 - Math.abs(h) * 65);
          let land = (h01 < 0.48) ? grass : lerp3(grass, soil, clamp01((h01 - 0.48) * 1.7));
          land = lerp3(land, rock, clamp01((h01 - 0.78) * 2.2));
          land = lerp3(land, shore, coast);
          return land;
        }

        if (this.biomePreset === "salusa") {
          // Salusa Secundus: √°spero, c√°rcavas, roca rojiza
          const dark = new BABYLON.Color3(0.12, 0.10, 0.10);
          const rust = new BABYLON.Color3(0.42, 0.22, 0.16);
          const rock = new BABYLON.Color3(0.30, 0.22, 0.20);
          const t = clamp01(Math.pow(h01, 1.2));
          let c = lerp3(dark, rust, clamp01(t + 0.12));
          c = lerp3(c, rock, clamp01((h01 - 0.62) * 2.2));
          // ceniza/tormentas sutiles
          const ash = clamp01((fbm3(pOnSphere.x*4+this.seed, pOnSphere.y*4+this.seed, pOnSphere.z*4+this.seed, 3) - 0.55) * 3.2);
          c = lerp3(c, dark, ash * 0.25);
          return c;
        }

        if (this.biomePreset === "richese") {
          // Richese: archipi√©lagos, mares turquesa, costas claras
          const deep  = new BABYLON.Color3(0.02, 0.14, 0.20);
          const water = new BABYLON.Color3(0.04, 0.28, 0.34);
          const aqua  = new BABYLON.Color3(0.08, 0.42, 0.40);
          const shore = new BABYLON.Color3(0.86, 0.80, 0.62);
          const green = new BABYLON.Color3(0.18, 0.56, 0.22);
          const rock  = new BABYLON.Color3(0.52, 0.52, 0.52);

          if (h < 0.0) {
            const d = clamp01((-h) * 10);
            return lerp3(water, deep, d);
          }
          const coast = clamp01(1 - Math.abs(h) * 55);
          let land = (h01 < 0.55) ? green : lerp3(green, rock, clamp01((h01 - 0.55) * 1.9));
          land = lerp3(land, shore, coast);
		  
		  // cimas grises (monta√±a alta)
		  // sube el umbral si quieres menos gris; b√°jalo si quieres m√°s
		  let m = clamp01((h01 - 0.72) / 0.20);
		  m = m*m*(3 - 2*m); // smoothstep
		  land = lerp3(land, peak, m);
		  
          // lagunas turquesa (manchas)
          const lagoon = clamp01((fbm3(pOnSphere.x*6+this.seed, pOnSphere.y*6+this.seed, pOnSphere.z*6+this.seed, 2) - 0.58) * 3.4);
          land = lerp3(land, aqua, lagoon * 0.18);
          // cimas grises (alta monta√±a)
          const peak = clamp01((h01 - 0.72) * 3.6);
          land = lerp3(land, rock, peak);
          return land;
        }

        // default (rocoso simple)
        const low = new BABYLON.Color3(0.35, 0.35, 0.37);
        const high = new BABYLON.Color3(0.55, 0.55, 0.55);
        return lerp3(low, high, h01);
      }

      setEnabled(on) {
        this.enabled = on;
        this.root.setEnabled(on);
        for (const f of this.faces) this._setChunkTreeEnabled(f, on);
        if (this.atmo) this.atmo.setEnabled(on);
      }

      _setChunkTreeEnabled(chunk, on) {
        if (chunk.mesh) chunk.mesh.setEnabled(on && chunk.isLeaf);
        if (!chunk.isLeaf) for (const c of chunk.children) this._setChunkTreeEnabled(c, on);
      }

      _requestSplit(chunk) {
        // Evita duplicados
        if (chunk._queued) return;
        chunk._queued = true;
        this._splitQueue.push(chunk);
      }

      update(camera) {
        if (!this.enabled) return;

        // update lod only if camera is near
        const dist = BABYLON.Vector3.Distance(camera.position, this.root.position);
        if (dist < this.radius * 5.5) {
          for (const f of this.faces) f.updateLOD(camera.position);
        }

        // Procesa splits con presupuesto por frame (evita picos)
        let budget = this._maxSplitsPerFrame;
        while (budget-- > 0 && this._splitQueue.length) {
          const ch = this._splitQueue.shift();
          if (!ch) break;
          ch._queued = false;
          if (ch.isLeaf) ch.split();
        }
      }

      countActiveChunks() {
        let total = 0;
        for (const f of this.faces) total += this._countLeaves(f);
        return total;
      }
      _countLeaves(chunk) {
        if (chunk.isLeaf) return (chunk.mesh && chunk.mesh.isEnabled()) ? 1 : 0;
        let c = 0;
        for (const ch of chunk.children) c += this._countLeaves(ch);
        return c;
      }

      dispose() {
        for (const f of this.faces) f.dispose();
        this.faces = [];
        if (this.atmo) this.atmo.dispose();
        this.root.dispose();
      }
    }

    
    // ====================================================================
    // 3) Low-poly far planets (vertex-displaced + vertex colors)
    // ====================================================================
    function createLowPolyFarPlanet(scene, def, orbitNode) {
      const seg = def.farSegments || 48;
      const land = BABYLON.MeshBuilder.CreateSphere(def.name + "_land", { diameter: def.radius * 2, segments: seg }, scene);
      land.parent = orbitNode;
      land.position.set(def.orbitR, 0, 0);

      // Material (vertex colors)
      const landMat = new BABYLON.StandardMaterial(def.name + "_landMat", scene);
      landMat.diffuseColor = new BABYLON.Color3(1,1,1);
      landMat.specularColor = new BABYLON.Color3(0.06,0.06,0.06);
      landMat.useVertexColor = true;
      land.material = landMat;

      // Optional micro bump to avoid "plastic" look
      if (def.microBump) {
        const bt = loadTextureOrNull(scene, def.microBump);
        if (bt) {
          bt.uScale = 6;
          bt.vScale = 6;
          landMat.bumpTexture = bt;
          landMat.bumpTexture.level = 0.8;
        }
      }

      const positions = land.getVerticesData(BABYLON.VertexBuffer.PositionKind);
      const normals   = land.getVerticesData(BABYLON.VertexBuffer.NormalKind);
      if (!positions || !normals) return { land, ocean: null };

      const colors = new Array((positions.length/3) * 4);

      // Dummy for palette reuse
      const dummy = {
        seed: (def.name.length * 17.13) % 1000,
        biomePreset: def.biomePreset || "default",
        biome: def.biome || null,
        seaLevel: (def.seaLevel ?? 0.0),
        terrainScale: (def.terrainScale ?? 0.12),
      };

      const f = def.noiseFrequency ?? 2.6;
      const oct = def.noiseOctaves ?? 6;
      const amp = def.terrainScale ?? 0.12;
      const sea = def.seaLevel ?? 0.0;

      // Helpers
      const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
      const quant = (x,step)=> (step>0? (Math.round(x/step)*step) : x);

      for (let i=0; i<positions.length; i+=3) {
        // unit direction
        const nx = normals[i], ny = normals[i+1], nz = normals[i+2];

        // domain warp (reduces repetition)
        const w = (fbm3(nx*f*1.2 + dummy.seed, ny*f*1.2 + dummy.seed, nz*f*1.2 + dummy.seed, 3) * 2 - 1) * 0.25;
        const wx = nx + w, wy = ny + w*0.35, wz = nz - w*0.2;

        const n0 = (fbm3(wx*f + dummy.seed, wy*f + dummy.seed, wz*f + dummy.seed, oct) * 2 - 1);
        // ridged mountains
        const r0 = 1.0 - Math.abs(n0);
        const ridge = Math.pow(clamp(r0,0,1), 2.2);

        // extra detail
        const n1 = (fbm3(wx*f*2.4 + 19.7 + dummy.seed, wy*f*2.4 + 3.3 + dummy.seed, wz*f*2.4 + 11.1 + dummy.seed, 4) * 2 - 1);

        // base elevation
        let elev = (n0 * 0.55 + ridge * 0.55 + n1 * 0.12) * amp;

        // Planet-specific flavor
        if (dummy.biomePreset === "arrakis") {
          // dunes banding
          const band = (Math.sin((wx + wz) * 16.0) * 0.5 + 0.5) * 0.10;
          elev += band * amp * 0.55;
        }
        if (dummy.biomePreset === "giedi" || dummy.biomePreset === "salusa") {
          // harsher craters/erosion feel
          const pits = (fbm3(wx*f*4.0 + 99.0 + dummy.seed, wy*f*4.0 + 17.0 + dummy.seed, wz*f*4.0 + 33.0 + dummy.seed, 3) - 0.55);
          elev += pits * amp * 0.20;
        }
        // Macro shaping (continents/archipi√©lagos/bandas...) configurable por planeta
        elev = applyMacroElevation(new BABYLON.Vector3(wx, wy, wz).normalize(), elev, def, dummy.seed);

        // clamp by seaLevel (visual basins)
        elev = Math.max(elev, sea);

        // low-poly quantization for chunky facets
        elev = quant(elev, amp * 0.11);

        const scale = def.radius * (1 + elev);
        positions[i]   = nx * scale;
        positions[i+1] = ny * scale;
        positions[i+2] = nz * scale;

        const c = ProceduralPlanet.prototype.getBiomeColor.call(dummy, new BABYLON.Vector3(nx,ny,nz), elev);
        const ci = (i/3)*4;
        colors[ci] = c.r; colors[ci+1] = c.g; colors[ci+2] = c.b; colors[ci+3] = 1.0;
      }

      land.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
      land.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
      // recompute normals after displacement
      BABYLON.VertexData.ComputeNormals(positions, land.getIndices(), normals);
      land.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
      try { land.convertToFlatShadedMesh(); } catch(e){}

      // Optional ocean sphere
      let ocean = null;
      if (def.ocean) {

const seaFrac = Math.max(0.6, 1 + sea + 0.002);
ocean = BABYLON.MeshBuilder.CreateSphere(def.name + "_ocean", {
  diameter: def.radius * 2 * seaFrac,
  segments: Math.max(18, Math.floor(seg * 0.55))
}, scene);
ocean.parent = orbitNode;
ocean.position.set(def.orbitR, 0, 0);
ocean.isPickable = false;

// Rendimiento: en FAR usamos StandardMaterial (PBR + transparencia es caro).
const useStandard = (def.farOceanStandard === true) || (seg <= 28);

if (useStandard) {
  const sm = new BABYLON.StandardMaterial(def.name + "_oceanStd", scene);
  sm.diffuseColor = def.oceanColor || new BABYLON.Color3(0.05, 0.18, 0.28);
  sm.specularColor = new BABYLON.Color3(0.12, 0.12, 0.12);
  sm.alpha = 0.92;
  sm.backFaceCulling = true;
  ocean.material = sm;
  try { sm.freeze(); } catch(e) {}
} else {
  const om = new BABYLON.PBRMaterial(def.name + "_oceanMat", scene);
  om.albedoColor = def.oceanColor || new BABYLON.Color3(0.05, 0.18, 0.28);
  om.metallic = 0.15;
  om.roughness = 0.35;
  om.alpha = 0.90;
  om.useAlphaFromAlbedoTexture = false;
  om.transparencyMode = BABYLON.PBRMaterial.PBR_ALPHABLEND;
  om.backFaceCulling = true;
  ocean.material = om;
  try { om.freeze(); } catch(e) {}
}

ocean.receiveShadows = false;
      }

      return { land, ocean };
    }
    
// ===================================================
// Near-detail planet (solo para el objetivo cercano)
// - M√°s segmentos (suave)
// - M√°s detalle de relieve (sin flat shading)
// - Misma paleta por vertex colors (no cambia est√©tica global)
// ===================================================
function createHighDetailNearPlanet(scene, def, orbitNode) {
  // segmentos altos, pero solo 1 cuerpo a la vez (target)
  const seg = def.nearSegments || Math.max(128, Math.floor((def.farSegments || 48) * 3));
  // IcoSphere da triangulaci√≥n m√°s uniforme para close-ups
  const land = BABYLON.MeshBuilder.CreateIcoSphere(def.name + "_nearLand", {
    radius: def.radius,
    subdivisions: Math.min(8, Math.max(6, Math.round(seg / 32)))
  }, scene);
  land.parent = orbitNode;
  land.position.set(def.orbitR, 0, 0);

  const landMat = new BABYLON.StandardMaterial(def.name + "_nearLandMat", scene);
  landMat.diffuseColor = new BABYLON.Color3(1,1,1);
  landMat.specularColor = new BABYLON.Color3(0.08,0.08,0.08);
  landMat.useVertexColor = true;
  land.material = landMat;

  // Micro bump (mismo asset, m√°s tiling cerca)
  if (def.microBump) {
    const bt = loadTextureOrNull(scene, def.microBump);
    if (bt) {
      bt.uScale = 18;
      bt.vScale = 18;
      landMat.bumpTexture = bt;
      landMat.bumpTexture.level = 1.0;
    }
  }

  const positions = land.getVerticesData(BABYLON.VertexBuffer.PositionKind);
  const normals   = land.getVerticesData(BABYLON.VertexBuffer.NormalKind);
  if (!positions || !normals) return { land, ocean: null };

  const colors = new Array((positions.length/3) * 4);

  const dummy = {
    seed: (def.name.length * 17.13) % 1000,
    biomePreset: def.biomePreset || "default",
        biome: def.biome || null,
    seaLevel: (def.seaLevel ?? 0.0),
    terrainScale: (def.terrainScale ?? 0.12),
  };

  const f = def.noiseFrequency ?? 2.6;
  const oct = (def.noiseOctaves ?? 6) + 1; // un pel√≠n m√°s de detalle cerca
      const ampBase = def.terrainScale ?? 0.12;
      const nearAmp = (def.nearTerrainAmp != null) ? def.nearTerrainAmp : 1.25;
      const amp = ampBase * nearAmp;
  const sea = def.seaLevel ?? 0.0;

  const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));

  for (let i=0; i<positions.length; i+=3) {
    const nx = normals[i], ny = normals[i+1], nz = normals[i+2];

    // domain warp suave
    const w = (fbm3(nx*f*1.35 + dummy.seed, ny*f*1.35 + dummy.seed, nz*f*1.35 + dummy.seed, 3) * 2 - 1) * 0.22;
    const wx = nx + w, wy = ny + w*0.35, wz = nz - w*0.2;

    const n0 = (fbm3(wx*f + dummy.seed, wy*f + dummy.seed, wz*f + dummy.seed, oct) * 2 - 1);
    const r0 = 1.0 - Math.abs(n0);
    const ridge = Math.pow(clamp(r0,0,1), 2.05);

    const n1 = (fbm3(wx*f*2.6 + 19.7 + dummy.seed, wy*f*2.6 + 3.3 + dummy.seed, wz*f*2.6 + 11.1 + dummy.seed, 4) * 2 - 1);
    const n2 = (fbm3(wx*f*5.2 + 7.7 + dummy.seed, wy*f*5.2 + 13.3 + dummy.seed, wz*f*5.2 + 21.1 + dummy.seed, 3) * 2 - 1);

    let elev = (n0 * 0.50 + ridge * 0.85 + n1 * 0.14 + n2 * 0.06) * amp;

    if (dummy.biomePreset === "arrakis") {
      const band = (Math.sin((wx + wz) * 18.0) * 0.5 + 0.5) * 0.10;
      elev += band * amp * 0.55;
    }
    if (dummy.biomePreset === "giedi" || dummy.biomePreset === "salusa") {
      const pits = (fbm3(wx*f*4.4 + 99.0 + dummy.seed, wy*f*4.4 + 17.0 + dummy.seed, wz*f*4.4 + 33.0 + dummy.seed, 3) - 0.56);
      elev += pits * amp * 0.22;
    }

    // Macro shaping configurable por planeta (continentes/archipi√©lagos, etc.)
    elev = applyMacroElevation(new BABYLON.Vector3(wx, wy, wz).normalize(), elev, def, dummy.seed);

    elev = Math.max(elev, sea);

    const scale = def.radius * (1 + elev);
    positions[i]   = nx * scale;
    positions[i+1] = ny * scale;
    positions[i+2] = nz * scale;

    const c = ProceduralPlanet.prototype.getBiomeColor.call(dummy, new BABYLON.Vector3(nx,ny,nz), elev);
    const ci = (i/3)*4;
    colors[ci] = c.r; colors[ci+1] = c.g; colors[ci+2] = c.b; colors[ci+3] = 1.0;
  }

  land.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
  land.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
  BABYLON.VertexData.ComputeNormals(positions, land.getIndices(), normals);
  land.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);

  // Ocean cerca: usamos PBR para un look m√°s rico en proximidad
  let ocean = null;
  if (def.ocean) {
    const seaFrac = Math.max(0.6, 1 + sea + 0.002);
    ocean = BABYLON.MeshBuilder.CreateSphere(def.name + "_nearOcean", {
      diameter: def.radius * 2 * seaFrac,
      segments: Math.max(48, Math.floor(seg * 0.75))
    }, scene);
    ocean.parent = orbitNode;
    ocean.position.set(def.orbitR, 0, 0);
    ocean.isPickable = false;

    const om = new BABYLON.PBRMaterial(def.name + "_nearOceanMat", scene);
    om.albedoColor = def.oceanColor || new BABYLON.Color3(0.05, 0.18, 0.28);
    om.metallic = 0.0;
    om.roughness = 0.18;
    om.alpha = 0.88;
    om.environmentIntensity = 0.35;
    ocean.material = om;

    if (def.oceanBump) {
      const obt = loadTextureOrNull(scene, def.oceanBump);
      if (obt) {
        obt.uScale = 10;
        obt.vScale = 10;
        om.bumpTexture = obt;
        om.bumpTexture.level = 0.8;
      }
    }
  }

  return { land, ocean };
}


// ====================================================================
    // 3) Helpers (textures/materials/atmospheres)
    // ====================================================================
    function loadTextureOrNull(scene, url, { hasAlpha=false } = {}) {
      try {
        const t = new BABYLON.Texture(url, scene, true, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
          null,
          () => console.warn("[texture] no se pudo cargar:", url)
        );
        t.hasAlpha = !!hasAlpha;
        return t;
      } catch (e) {
        console.warn("[texture] error creando textura:", url, e);
        return null;
      }
    }

    function makePlanetPBR(scene, name, maps) {
      const mat = new BABYLON.PBRMaterial(name, scene);
      mat.metallic = 0.0;
      mat.roughness = maps?.roughness ?? 0.95;
      mat.specularIntensity = maps?.specularIntensity ?? 0.15;

      if (maps?.albedo) {
        const a = loadTextureOrNull(scene, maps.albedo);
        if (a) mat.albedoTexture = a;
      } else {
        mat.albedoColor = maps?.fallbackColor ?? new BABYLON.Color3(0.6,0.6,0.6);
      }

      if (maps?.normal) {
        const n = loadTextureOrNull(scene, maps.normal);
        if (n) {
          mat.bumpTexture = n;
          mat.bumpTexture.level = maps.bumpLevel ?? 1.0;
        }
      }
      if (maps?.bump) {
        const b = loadTextureOrNull(scene, maps.bump);
        if (b) {
          mat.bumpTexture = b;
          mat.bumpTexture.level = maps.bumpLevel ?? 0.8;
        }
      }

      return mat;
    }

    function makeAtmosphere(scene, parentNode, radius, color3, alpha=0.35) {
      const atmo = BABYLON.MeshBuilder.CreateSphere(parentNode.name + "_Atmo", { diameter: radius * 2.18, segments: 48 }, scene);
      atmo.parent = parentNode;
      atmo.isPickable = false;

      const mat = new BABYLON.StandardMaterial(parentNode.name + "_AtmoMat", scene);
      mat.diffuseColor = BABYLON.Color3.Black();
      mat.specularColor = BABYLON.Color3.Black();
      mat.emissiveColor = color3;
      mat.alpha = alpha;
      mat.backFaceCulling = false;

      // Fresnel-ish edge glow
      mat.emissiveFresnelParameters = new BABYLON.FresnelParameters();
      mat.emissiveFresnelParameters.bias = 0.2;
      mat.emissiveFresnelParameters.power = 2.0;
      mat.emissiveFresnelParameters.leftColor = BABYLON.Color3.Black();
      mat.emissiveFresnelParameters.rightColor = color3;

      atmo.material = mat;
      return atmo;
    }

    // ====================================================================
    // 4) Scene
    // ====================================================================
    const ui = {
      camOrbitBtn: document.getElementById("camOrbit"),
      camFlyBtn: document.getElementById("camFly"),
      camSurfaceBtn: document.getElementById("camSurface"),
      speedRange: document.getElementById("speedRange"),
      speedVal: document.getElementById("speedVal"),
      planetSelect: document.getElementById("planetSelect"),
      approachBtn: document.getElementById("approachBtn"),
      debugInfo: document.getElementById("debugInfo"),
      toggleLabels: document.getElementById("toggleLabels"),
      labelsPill: document.getElementById("labelsPill"),
      modePill: document.getElementById("modePill"),
    };

    let timeScale = 1.0;

    const createScene = () => {
      const scn = new BABYLON.Scene(engine);
      // Rendimiento: evita trabajo extra de picking continuo
      scn.skipPointerMovePicking = true;
      scn.blockMaterialDirtyMechanism = true;
      // Fondo realmente negro (evita el "cielo gris" cuando sube la exposici√≥n/bloom)
      scn.clearColor = new BABYLON.Color4(0, 0, 0, 1);
	  
      // Iluminaci√≥n Global (IBL) muy suave (sin crear skybox/ground)
      scn.environmentIntensity = 0.15;

      // Background stars (point cloud, estilo "inicio"; sin URLs externas)
      const starsPCS = new BABYLON.PointsCloudSystem("stars", 1, scn);
      const starCount = 12000; // rendimiento
      const starRadius = 2800;
      let starsMesh = null;

      starsPCS.addPoints(starCount, (p) => {
        // distribuci√≥n esf√©rica (m√°s estrellas lejos)
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);

        const r = starRadius * (0.35 + 0.65 * Math.pow(Math.random(), 0.35));
        p.position.x = r * Math.sin(phi) * Math.cos(theta);
        p.position.y = r * Math.cos(phi);
        p.position.z = r * Math.sin(phi) * Math.sin(theta);

        // brillo con ligera variaci√≥n
        const a = 0.55 + Math.random() * 0.45;
        p.color = new BABYLON.Color4(1, 1, 1, a);
      });

      starsPCS.buildMeshAsync().then((m) => {
        starsMesh = m;
        starsMesh.isPickable = false;
        starsMesh.alwaysSelectAsActiveMesh = true;

        const starsMat = new BABYLON.StandardMaterial("starsMat", scn);
        starsMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        starsMat.disableLighting = true;
        starsMat.pointsCloud = true;

		starsMat.pointSize = 1.15;
        starsMesh.material = starsMat;
      });
	  
      // Mantener las estrellas "infinito" siguiendo la c√°mara
      scn.onBeforeRenderObservable.add(() => {
        if (starsMesh && scn.activeCamera) {
          starsMesh.position.copyFrom(scn.activeCamera.position);
        }
      });

      // Cameras
      const cameraOrbit = new BABYLON.ArcRotateCamera("camOrbit", -Math.PI/2, Math.PI/3, 260, BABYLON.Vector3.Zero(), scn);
      cameraOrbit.lowerRadiusLimit = 8;
      cameraOrbit.upperRadiusLimit = 2500;
      cameraOrbit.wheelDeltaPercentage = 0.01;
      cameraOrbit.attachControl(canvas, true);

      const cameraFly = new BABYLON.UniversalCamera("camFly", new BABYLON.Vector3(0, 60, -220), scn);
      cameraFly.minZ = 0.1;
      cameraFly.speed = 2.2;
      cameraFly.angularSensibility = 4000;
      cameraFly.keysUp = [87];    // W
      cameraFly.keysDown = [83];  // S
      cameraFly.keysLeft = [65];  // A
      cameraFly.keysRight = [68]; // D
      // add vertical controls
      cameraFly.keysUpward = [32];       // Space up
      cameraFly.keysDownward = [17, 67]; // Ctrl or C down

      // Surface camera: use a playerRoot for proper orientation
      const playerRoot = new BABYLON.TransformNode("playerRoot", scn);
      playerRoot.rotationQuaternion = BABYLON.Quaternion.Identity();

      const cameraSurface = new BABYLON.UniversalCamera("camSurface", new BABYLON.Vector3(0, 2, 0), scn);
      cameraSurface.parent = playerRoot;
      cameraSurface.minZ = 0.05;
      cameraSurface.speed = 0; // we implement movement ourselves
      cameraSurface.angularSensibility = 3500;

      scn.activeCamera = cameraOrbit;

      // Lights
      const sunLight = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scn);
      sunLight.intensity = 2.2;
      sunLight.range = 8000;

      
      // Light linking: Canopus s√≥lo ilumina su propio sistema (mejora rendimiento y evita 'todo gira/ilumina Canopus')
      const mainLitMeshes = [];
      sunLight.includedOnlyMeshes = mainLitMeshes;
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scn);
      hemi.intensity = 0.10;
      hemi.diffuse = new BABYLON.Color3(0.1, 0.1, 0.2); // Tinte azulado para ambiente espacial
      hemi.groundColor = new BABYLON.Color3(0,0,0);

      // Un pel√≠n de ambiente para que no queden negros en superficie sin "subir" el cielo
      scn.ambientColor = new BABYLON.Color3(0.05, 0.05, 0.06);

      // Shadows (optional)
      const shadowGen = new BABYLON.ShadowGenerator(2048, sunLight);
      // Rendimiento: Poisson es mucho m√°s barato que contact hardening
      shadowGen.usePoissonSampling = true;
      shadowGen.bias = 0.00025;
      shadowGen.normalBias = 0.01;

      // Glow desactivado por rendimiento (ya tenemos halo del sol)
      // const glow = new BABYLON.GlowLayer("glow", scn);
      // glow.intensity = 0.12;

      // Textures (put these in: /textures/planets/)
      const T = (f) => "textures/planets/" + f;

      const mapsByName = {
        // Texturas opcionales (si las pones en /textures/planets/)
        // Si no existen, el c√≥digo hace fallback a colores.
        "Canopus": { /* albedo: T("2k_sun.jpg") */ },
      };

      // Bodies definition (not to scale; tuned for visuals)
      const bodyDefs = [
        // --- Sistema Dune (no a escala; valores ajustados a visual) ---
        {
          name:"Canopus", kind:"sun", radius: 50,
          orbitR: 0, orbitSpeed: 0, rotSpeed: 0.002,
          rocky:false,
        },

        // Planetas de la novela
        {
          name:"Arrakis", kind:"planet", radius: 6.2,
          orbitR: -340, orbitSpeed: 0.00060, rotSpeed: 0.080,
          rocky:true,
          biomePreset:"arrakis",
          terrainScale: 0.22,
          seaLevel: 0.01,          // sin oc√©ano
          noiseFrequency: 2.9,
          noiseOctaves: 6,
          farSegments: 48,
          ocean:false,
          oceanColor: new BABYLON.Color3(0.04,0.12,0.18),
          microBump: T("detail_rock3.png"),
        },
		// Lunas de Arrakis (novela: 2 lunas; una con "Hand of God" y otra llamada Muad'dib)
		{ name:"First Moon", kind:"moon", radius: 1.55, orbitR: 14.5, orbitSpeed: 0.060, rotSpeed: 0.010, atmo:false, rocky:true, parent:"Arrakis" },
		{ name:"Muad'dib",   kind:"moon", radius: 1.05, orbitR: 10.2, orbitSpeed: 0.085, rotSpeed: 0.012, atmo:false, rocky:true, parent:"Arrakis" },
        {
          name:"Caladan", kind:"planet", radius: 7.0,
          orbitR: 400, orbitSpeed: 0.00052, rotSpeed: -0.107,
          rocky:true,
          biomePreset:"caladan",
          terrainScale: 0.13,
          seaLevel: 0.0355,        // mucho mar
          noiseFrequency: 2.1,
          noiseOctaves: 6,
          farSegments: 52,
          ocean:true,
          oceanColor: new BABYLON.Color3(0.04,0.20,0.30),
          microBump: T("detail_craters.png"),
        },
        {
          name:"Giedi Prime", kind:"planet", radius: 6.6,
          orbitR: 465, orbitSpeed: 0.00046, rotSpeed: 0.092,
          rocky:true,
          biomePreset:"giedi",
          terrainScale: 0.20,
          seaLevel: 0.008,        // charcos/mares m√≠nimos
          noiseFrequency: 3.2,
          noiseOctaves: 5,
          farSegments: 50,
          ocean:true,
          oceanColor: new BABYLON.Color3(0.02,0.08,0.05),
          microBump: T("detail_rock2.png"),
        },
        {
          name:"Ix", kind:"planet", radius: 5.9,
          orbitR: 530, orbitSpeed: 0.00040, rotSpeed: 0.204,
          rocky:true,
          biomePreset:"ix",
          terrainScale: 0.16,
          seaLevel: -0.012,
          noiseFrequency: 2.7,
          noiseOctaves: 6,
          farSegments: 48,
          ocean:true,
          oceanColor: new BABYLON.Color3(0.03,0.12,0.18),
          microBump: T("detail_snow.png"),
        },
        {
          name:"Kaitain", kind:"planet", radius: 6.3,
          orbitR: 595, orbitSpeed: 0.00035, rotSpeed: 0.106,
          rocky:true,
          biomePreset:"kaitain",
          terrainScale: 0.12,
          seaLevel: -0.022,
          noiseFrequency: 2.2,
          noiseOctaves: 6,
          farSegments: 50,
          ocean:true,
          oceanColor: new BABYLON.Color3(0.04,0.18,0.26),
          microBump: T("detail_craters.png"),
        },
        {
          name:"Salusa Secundus", kind:"planet", radius: 6.0,
          orbitR: 670, orbitSpeed: 0.00030, rotSpeed: 0.109,
          rocky:true,
          biomePreset:"salusa",
          terrainScale: 0.24,
          seaLevel: 0.01,          // sin oc√©ano
          noiseFrequency: 3.0,
          noiseOctaves: 6,
          farSegments: 48,
          ocean:false,
          microBump: T("detail_rock3.png"),
        },
        {
          name:"Richese", kind:"planet", radius: 6.4,
          orbitR: 760, orbitSpeed: 0.00026, rotSpeed: 0.108,
          rocky:true,
          biomePreset:"richese",
          terrainScale: 0.11,
          seaLevel: -0.01250,        // planeta muy oce√°nico
          noiseFrequency: 2.0,
          noiseOctaves: 6,
          farSegments: 52,
          ocean:true,
          oceanColor: new BABYLON.Color3(0.05,0.26,0.30),
          microBump: T("detail_craters.png"),
		  // --- Continentes + archipi√©lagos (solo Richese) ---
		  continentFreq: 0.55,        // muy baja: forma masas grandes
		  continentStrength: 0.55,    // cu√°nto ‚Äúlevanta‚Äù el continente
		  islandsFreq: 4.8,           // alta: islas
		  islandsStrength: 0.22       // cu√°nto ‚Äúmuerde‚Äù cerca de costa
        },
      ];

      // ====================================================================
      // Extra: Multi-star (10 sistemas) FAR-only por defecto (rendimiento)
      // Inspirados en el Imperium (Dune) ‚Äî nombres estilo Dune, no canon estricto
      // ====================================================================
      const extraSystems = [
        {
          id: "Ecaz",
          speedScale: 6,
          pos: new BABYLON.Vector3(1400, 120, -900),
          star: { name: "Star Ecaz", kind:"sun", radius: 28, emissive: new BABYLON.Color3(1.0,0.86,0.55) },
          planets: [
            { name:"Ecaz ‚Äì Ecaz", kind:"planet", radius: 5.2, orbitR: 120, orbitSpeed: 0.00080, rotSpeed: 0.050, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 24, farOceanStandard:true },
            { name:"Ecaz ‚Äì Tupile", kind:"planet", radius: 4.3, orbitR: 170, orbitSpeed: 0.00060, rotSpeed: 0.040, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 24, farOceanStandard:true },
            { name:"Ecaz ‚Äì Sikun", kind:"planet", radius: 3.8, orbitR: 230, orbitSpeed: 0.00048, rotSpeed: 0.060, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Ecaz ‚Äì Chusuk", kind:"planet", radius: 3.1, orbitR: 290, orbitSpeed: 0.00038, rotSpeed: 0.070, rocky:true, biomePreset:"ix", seaLevel:-0.02, ocean:true, farSegments: 18, farOceanStandard:true },
          ],
        },
        {
          id: "Wallach",
          speedScale: 6,
          pos: new BABYLON.Vector3(-1550, 40, -1050),
          star: { name: "Star Wallach", kind:"sun", radius: 30, emissive: new BABYLON.Color3(0.95,0.92,0.78) },
          planets: [
            { name:"Wallach ‚Äì Wallach IX", kind:"planet", radius: 5.0, orbitR: 110, orbitSpeed: 0.00085, rotSpeed: 0.045, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 24, farOceanStandard:true },
            { name:"Wallach ‚Äì Panope", kind:"planet", radius: 4.2, orbitR: 165, orbitSpeed: 0.00062, rotSpeed: 0.055, rocky:true, biomePreset:"caladan", seaLevel:-0.02, ocean:true, farSegments: 22, farOceanStandard:true },
            { name:"Wallach ‚Äì Lankiveil", kind:"planet", radius: 4.6, orbitR: 235, orbitSpeed: 0.00048, rotSpeed: 0.040, rocky:true, biomePreset:"ix", seaLevel:0.015, ocean:false, farSegments: 22 },
          ],
        },
        {
          id: "Tleilax",
          speedScale: 6,
          pos: new BABYLON.Vector3(1120, -80, 1280),
          star: { name: "Star Tleilax", kind:"sun", radius: 26, emissive: new BABYLON.Color3(1.0,0.70,0.55) },
          planets: [
            { name:"Tleilax ‚Äì Tleilax", kind:"planet", radius: 4.9, orbitR: 120, orbitSpeed: 0.00075, rotSpeed: 0.060, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 24 },
            { name:"Tleilax ‚Äì Bandalong", kind:"planet", radius: 3.7, orbitR: 175, orbitSpeed: 0.00056, rotSpeed: 0.070, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Tleilax ‚Äì Sietch", kind:"planet", radius: 3.0, orbitR: 245, orbitSpeed: 0.00042, rotSpeed: 0.085, rocky:true, biomePreset:"arrakis", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Ginaz",
          speedScale: 6,
          pos: new BABYLON.Vector3(-1250, 90, 1320),
          star: { name: "Star Ginaz", kind:"sun", radius: 27, emissive: new BABYLON.Color3(0.90,0.92,1.0) },
          planets: [
            { name:"Ginaz ‚Äì Ginaz", kind:"planet", radius: 4.6, orbitR: 115, orbitSpeed: 0.00082, rotSpeed: 0.055, rocky:true, biomePreset:"kaitain", seaLevel:-0.015, ocean:true, farSegments: 22, farOceanStandard:true },
            { name:"Ginaz ‚Äì Naraj", kind:"planet", radius: 3.9, orbitR: 175, orbitSpeed: 0.00060, rotSpeed: 0.070, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Ginaz ‚Äì Wedlock", kind:"planet", radius: 3.4, orbitR: 250, orbitSpeed: 0.00045, rotSpeed: 0.080, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Grumman",
          speedScale: 6,
          pos: new BABYLON.Vector3(1850, -120, 250),
          star: { name: "Star Grumman", kind:"sun", radius: 29, emissive: new BABYLON.Color3(1.0,0.94,0.80) },
          planets: [
            { name:"Grumman ‚Äì Grumman", kind:"planet", radius: 4.8, orbitR: 120, orbitSpeed: 0.00080, rotSpeed: 0.050, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 22, farOceanStandard:true },
            { name:"Grumman ‚Äì Kralizec", kind:"planet", radius: 4.1, orbitR: 190, orbitSpeed: 0.00058, rotSpeed: 0.065, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Grumman ‚Äì Selusa", kind:"planet", radius: 3.3, orbitR: 265, orbitSpeed: 0.00042, rotSpeed: 0.090, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Buzzell",
          speedScale: 6,
          pos: new BABYLON.Vector3(-2100, -60, 250),
          star: { name: "Star Buzzell", kind:"sun", radius: 25, emissive: new BABYLON.Color3(0.95,0.78,0.55) },
          planets: [
            { name:"Buzzell ‚Äì Buzzell", kind:"planet", radius: 4.0, orbitR: 105, orbitSpeed: 0.00092, rotSpeed: 0.060, rocky:true, biomePreset:"arrakis", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Buzzell ‚Äì Harmonthep", kind:"planet", radius: 5.4, orbitR: 175, orbitSpeed: 0.00060, rotSpeed: 0.040, rocky:true, biomePreset:"kaitain", seaLevel:-0.02, ocean:true, farSegments: 24, farOceanStandard:true },
            { name:"Buzzell ‚Äì Lampadas", kind:"planet", radius: 3.6, orbitR: 255, orbitSpeed: 0.00045, rotSpeed: 0.080, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Junction",
          speedScale: 6,
          pos: new BABYLON.Vector3(0, 160, 2100),
          star: { name: "Star Junction", kind:"sun", radius: 24, emissive: new BABYLON.Color3(0.85,0.90,1.0) },
          planets: [
            { name:"Junction ‚Äì Junction", kind:"planet", radius: 4.2, orbitR: 120, orbitSpeed: 0.00088, rotSpeed: 0.055, rocky:true, biomePreset:"ix", seaLevel:0.015, ocean:false, farSegments: 22 },
            { name:"Junction ‚Äì Poritrin", kind:"planet", radius: 5.8, orbitR: 195, orbitSpeed: 0.00058, rotSpeed: 0.040, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 24, farOceanStandard:true },
            { name:"Junction ‚Äì Ecaz Minor", kind:"planet", radius: 3.0, orbitR: 275, orbitSpeed: 0.00042, rotSpeed: 0.085, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 18, farOceanStandard:true },
          ],
        },
        {
          id: "Lampadas",
          speedScale: 6,
          pos: new BABYLON.Vector3(2200, 60, -1350),
          star: { name: "Star Lampadas", kind:"sun", radius: 28, emissive: new BABYLON.Color3(1.0,0.82,0.60) },
          planets: [
            { name:"Lampadas ‚Äì Lampadas", kind:"planet", radius: 4.9, orbitR: 125, orbitSpeed: 0.00082, rotSpeed: 0.050, rocky:true, biomePreset:"kaitain", seaLevel:-0.015, ocean:true, farSegments: 22, farOceanStandard:true },
            { name:"Lampadas ‚Äì Rossak", kind:"planet", radius: 4.4, orbitR: 190, orbitSpeed: 0.00058, rotSpeed: 0.060, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Lampadas ‚Äì Bela", kind:"planet", radius: 3.5, orbitR: 270, orbitSpeed: 0.00042, rotSpeed: 0.080, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Poritrin",
          speedScale: 6,
          pos: new BABYLON.Vector3(-2300, 120, -1750),
          star: { name: "Star Poritrin", kind:"sun", radius: 26, emissive: new BABYLON.Color3(0.95,0.88,0.70) },
          planets: [
            { name:"Poritrin ‚Äì Poritrin", kind:"planet", radius: 5.6, orbitR: 130, orbitSpeed: 0.00076, rotSpeed: 0.040, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 24, farOceanStandard:true },
            { name:"Poritrin ‚Äì Grumman Minor", kind:"planet", radius: 3.6, orbitR: 205, orbitSpeed: 0.00054, rotSpeed: 0.070, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 18, farOceanStandard:true },
            { name:"Poritrin ‚Äì Tleilax Outpost", kind:"planet", radius: 3.1, orbitR: 280, orbitSpeed: 0.00040, rotSpeed: 0.085, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Naraj",
          speedScale: 6,
          pos: new BABYLON.Vector3(2550, -80, 1750),
          star: { name: "Star Naraj", kind:"sun", radius: 24, emissive: new BABYLON.Color3(0.88,0.95,1.0) },
          planets: [
            { name:"Naraj ‚Äì Naraj", kind:"planet", radius: 4.1, orbitR: 110, orbitSpeed: 0.00090, rotSpeed: 0.060, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Naraj ‚Äì Ixian Forge", kind:"planet", radius: 3.8, orbitR: 170, orbitSpeed: 0.00062, rotSpeed: 0.070, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 18 },
            { name:"Naraj ‚Äì Caladan Drift", kind:"planet", radius: 5.0, orbitR: 240, orbitSpeed: 0.00045, rotSpeed: 0.040, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 22, farOceanStandard:true },
          ],
        },
      ];


      // Create meshes
      const bodies = new Map(); // name => body
      const orbitNodes = new Map(); // name => node rotated around sun
      const moonOrbitNodes = new Map(); // moon around parent

      // Sun mesh
      const sunMesh = BABYLON.MeshBuilder.CreateSphere("Canopus", { diameter: bodyDefs[0].radius * 2, segments: 64 }, scn);
      // Link main star light to the Canopus mesh now that it exists
      mainLitMeshes.push(sunMesh);
      sunLight.parent = sunMesh;
      sunLight.position.set(0,0,0);
      sunMesh.position.set(0,0,0);

      // --- MEJORA DEL SOL: PBR Y TEXTURA PROCEDURAL ---
      const sunMat = new BABYLON.PBRMaterial("sunMat", scn);
      sunMat.unlit = true; // No recibe sombras, emite luz
      sunMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.1); // N√∫cleo naranja/fuego
      
      // Textura de ruido animada para la superficie solar
      const sunNoise = new BABYLON.NoiseProceduralTexture("sunNoise", 512, scn);
      sunNoise.animationSpeedFactor = 0.8;
      sunNoise.brightness = 0.5;
      sunMat.emissiveTexture = sunNoise;
       sunMesh.material = sunMat;

      // Halo del sol (billboard) con depth prepass: NO atraviesa planetas
      const halo = BABYLON.MeshBuilder.CreatePlane("Canopus_Halo", { size: bodyDefs[0].radius * 3.6 }, scn);
      halo.parent = sunMesh;
      halo.isPickable = false;
      halo.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

      const haloTex = new BABYLON.DynamicTexture("haloTex", { width: 512, height: 512 }, scn, false);
      const ctx = haloTex.getContext();
      const g = ctx.createRadialGradient(256,256,0,256,256,256);
      g.addColorStop(0.00, "rgba(255,210,140,0.55)");
      g.addColorStop(0.25, "rgba(255,165, 70,0.22)");
      g.addColorStop(0.55, "rgba(255,120, 40,0.10)");
      g.addColorStop(1.00, "rgba(0,0,0,0.00)");
      ctx.fillStyle = g; ctx.fillRect(0,0,512,512);
      haloTex.update();

      const haloMat = new BABYLON.StandardMaterial("haloMat", scn);
      haloMat.diffuseTexture = haloTex;
      haloMat.emissiveTexture = haloTex;
      haloMat.opacityTexture = haloTex;
      haloMat.disableLighting = true;
      haloMat.backFaceCulling = false;
      haloMat.alpha = 0.75;
      haloMat.alphaMode = BABYLON.Engine.ALPHA_ADD;
      haloMat.needDepthPrePass = true;
      halo.material = haloMat;

      // Planets + Moons
      for (const def of bodyDefs) {
        if (def.kind === "sun") {
          bodies.set(def.name, {
            def,
			systemId: "Canopus",
            farMesh: sunMesh,
            atmo: null,
            ring: null,
            orbitAngle: 0,
            orbitNode: null,
            proc: null,
          });
          continue;
        }

        // ---------- MOONS: orbit around parent planet ----------
        if (def.kind === "moon" && def.parent) {
          const parentBody = bodies.get(def.parent);
          if (!parentBody) {
            console.warn("[moon] parent no encontrado:", def.parent, "para", def.name);
            continue;
          }

          const moonOrbitNode = new BABYLON.TransformNode(def.name + "_moonOrbit", scn);
          moonOrbitNode.parent = parentBody.farMesh; // sigue a Arrakis (y a su √≥rbita)
          moonOrbitNode.position.set(0,0,0);
          moonOrbitNodes.set(def.name, moonOrbitNode);

          const created = createLowPolyFarPlanet(scn, def, moonOrbitNode);
          const mesh = created.land;
          const ocean = created.ocean;

          shadowGen.addShadowCaster(mesh);
          mesh.receiveShadows = true;
          if (ocean) ocean.receiveShadows = false;

                            // Light linking: este cuerpo pertenece al sistema Canopus
          mainLitMeshes.push(mesh);
          if (ocean) mainLitMeshes.push(ocean);
          bodies.set(def.name, {
            def,
			systemId: "Canopus",
            farMesh: mesh,
          farOcean: ocean,
            farOcean: ocean,
            atmo: null,
            ring: null,
            orbitAngle: Math.random() * Math.PI * 2,
            orbitNode: moonOrbitNode,  // ojo: para lunas, orbitNode es alrededor del planeta
            proc: null,
          });

          continue; // muy importante: no crearla como planeta del sol
        }

        // ---------- PLANETS: orbit around sun ----------
        const orbitNode = new BABYLON.TransformNode(def.name + "_orbit", scn);
        orbitNode.position.set(0,0,0);
        orbitNodes.set(def.name, orbitNode);

        def._sysSpeed = def._sysSpeed || 1;
        const created = createLowPolyFarPlanet(scn, def, orbitNode);
        const mesh = created.land;
        const ocean = created.ocean;

        shadowGen.addShadowCaster(mesh);
        mesh.receiveShadows = true;
        if (ocean) { ocean.receiveShadows = false; }
		
		// Light linking: estos planetas pertenecen al sistema Canopus
		mainLitMeshes.push(mesh);
		if (ocean) mainLitMeshes.push(ocean);

        // rings
        let ring = null;
        if (def.rings && def.ringTex) {
          ring = BABYLON.MeshBuilder.CreateDisc(def.name+"_Rings", { radius: def.radius * 3.3, tessellation: 128 }, scn);
          ring.parent = mesh;
          ring.rotation.x = Math.PI / 2;
          ring.isPickable = false;

          const ringMat = new BABYLON.StandardMaterial(def.name+"_RingMat", scn);
          ringMat.backFaceCulling = false;
          ringMat.disableLighting = true;
          ringMat.emissiveColor = new BABYLON.Color3(0.9,0.85,0.75).scale(0.75);
          ringMat.alpha = 0.95;

          const rt = loadTextureOrNull(scn, def.ringTex, { hasAlpha: true });
          if (rt) {
            ringMat.diffuseTexture = rt;
            ringMat.opacityTexture = rt;
            ringMat.useAlphaFromDiffuseTexture = true;
            ringMat.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
          }
          ring.material = ringMat;
        }

        // Atmosferas desactivadas por ahora
        let atmo = null;

        bodies.set(def.name, {
          def,
		  systemId: "Canopus",
          farMesh: mesh,
          atmo,
          ring,
          orbitAngle: Math.random() * Math.PI * 2,
          orbitNode,
          proc: null,
        });
      }

      // Ensure sunLight follows sun (in case you move it later)
      sunLight.position.copyFrom(sunMesh.position);
      // GUI labels (optional)
      const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ui", true, scn);

      // Labels registry (incluye planetas, lunas y estrellas)
      const labelsByName = new Map(); // name -> { rect, kind, mesh }
      let showLabels = true;
	  
	  function createLabel(text, mesh) {
        const rect = new BABYLON.GUI.Rectangle("lbl_" + text);
        rect.background = "rgba(0,0,0,0.35)";
        rect.thickness = 1;
        rect.color = "rgba(255,255,255,0.25)";
        rect.cornerRadius = 8;
        rect.height = "22px";
        rect.width = "120px";
        rect.isHitTestVisible = false;

        const tb = new BABYLON.GUI.TextBlock();
        tb.text = text;
        tb.color = "#fff";
        tb.fontSize = 12;
        rect.addControl(tb);

        gui.addControl(rect);
        rect.linkWithMesh(mesh);
        rect.linkOffsetY = -20;
		
        return rect;
      }
	  
      // ‚úÖ √öNICO punto para crear/registrar labels (evita que "se queden" para siempre)
      function registerLabel(name, kind, mesh) {
        if (!mesh) return null;
        let meta = labelsByName.get(name);
        if (!meta) {
          const rect = createLabel(name, mesh);
          meta = { rect, kind, mesh };
          labelsByName.set(name, meta);
        } else {
          // por si cambiaste mesh (rar√≠simo, pero seguro)
          meta.kind = kind || meta.kind;
          meta.mesh = mesh || meta.mesh;
        }
        return meta.rect;
      }

      // Fill selector + labels
      ui.planetSelect.innerHTML = "";
      
      // ====================================================================
      // 3b) Create extra star systems (FAR-only por defecto)
      // ====================================================================
      const systemRoots = new Map(); // systemId -> root node
      const systemLights = []; // {light, root, range}
	  const systemLightById = new Map(); // sysId -> PointLight
	  
      function linkMeshToSystemLight(systemId, mesh) {
        if (!mesh) return;
        const L = systemLightById.get(systemId);
        if (!L) return;
        // si usas includedOnlyMeshes, a√±ade el mesh
        if (Array.isArray(L.includedOnlyMeshes)) {
          if (!L.includedOnlyMeshes.includes(mesh)) L.includedOnlyMeshes.push(mesh);
        }
      }

      function createStarSystem(sys) {
        const root = new BABYLON.TransformNode("sys_" + sys.id, scn);
        root.position.copyFrom(sys.pos);
        systemRoots.set(sys.id, root);

        // Star mesh (emissive)
        const star = BABYLON.MeshBuilder.CreateSphere(sys.star.name, { diameter: sys.star.radius * 2, segments: 48 }, scn);
        star.parent = root;
        star.position.set(0,0,0);
        star.isPickable = false;

        const starMat = new BABYLON.StandardMaterial(sys.star.name + "_mat", scn);
        starMat.emissiveColor = sys.star.emissive || new BABYLON.Color3(1,0.9,0.7);
        starMat.diffuseColor = BABYLON.Color3.Black();
        starMat.specularColor = BABYLON.Color3.Black();
        starMat.disableLighting = true;
        star.material = starMat;

        bodies.set(sys.star.name, {
          def: sys.star,
		  systemId: sys.id,
          farMesh: star,
          atmo: null,
          ring: null,
          orbitAngle: 0,
          orbitNode: null,
          proc: null,
        });

        // Local light: cada estrella ilumina SOLO su sistema (light linking)
		const local = new BABYLON.PointLight(sys.id + "_light", new BABYLON.Vector3(0,0,0), scn);
		local.parent = star;
		local.intensity = (sys.star.lightIntensity != null) ? sys.star.lightIntensity : 1.85;
		local.range = (sys.star.lightRange != null) ? sys.star.lightRange : 900;
		local.includedOnlyMeshes = [];
		local.setEnabled(true);
        systemLights.push({ id: sys.id, light: local, root, range: local.range });
        systemLightById.set(sys.id, local);

        // opcional: que la propia estrella est√© iluminada/coherente (si quieres)
        linkMeshToSystemLight(sys.id, star);

        // Planets
        for (const pDef of sys.planets) {
          pDef._sysSpeed = sys.speedScale || 1;
          const orbitNode = new BABYLON.TransformNode(pDef.name + "_orbit", scn);
          orbitNode.parent = root;
          orbitNode.position.set(0,0,0);
          orbitNodes.set(pDef.name, orbitNode);

          const created = createLowPolyFarPlanet(scn, pDef, orbitNode);
          const mesh = created.land;
          const ocean = created.ocean;

          mesh.isPickable = false;
          if (ocean) ocean.isPickable = false;
          // sin sombras para sistemas lejanos (mucho m√°s barato)
          mesh.receiveShadows = false;
          if (ocean) ocean.receiveShadows = false;
          // Light linking: esta luz s√≥lo ilumina meshes de este sistema
          local.includedOnlyMeshes.push(mesh);
          if (ocean) local.includedOnlyMeshes.push(ocean);

          bodies.set(pDef.name, {
            def: pDef,
			systemId: sys.id,
            farMesh: mesh,
            farOcean: ocean,
            atmo: null,
            ring: null,
            orbitAngle: Math.random() * Math.PI * 2,
            orbitNode,
            proc: null,
          });
		  
      // ‚úÖ Esto es lo que faltaba: enlazar meshes a su luz de sistema
      linkMeshToSystemLight(sys.id, mesh);
      if (ocean) linkMeshToSystemLight(sys.id, ocean);
      //if (ring)  linkMeshToSystemLight(sys.id, ring);

      // si tienes atm√≥sfera mesh:
      // if (atmo) linkMeshToSystemLight(sys.id, atmo);

          // Congela materiales en far (barato)
          if (mesh.material && mesh.material.freeze) mesh.material.freeze();
}

        // Congela star
        star.freezeWorldMatrix();
        star.doNotSyncBoundingInfo = true;
        if (star.material && star.material.freeze) star.material.freeze();
      }

      for (const sys of extraSystems) createStarSystem(sys);


      // ====================================================================
      // 4) Labels + UI populate (incluye sistemas extra)
      // ====================================================================
      // IMPORTANT: aseg√∫rate de incluir lunas en este listado si quieres que entren en el control de labels
      // Ejemplo: allDefs = [...planetas/estrellas..., ...moonDefs]
      const allDefs = bodyDefs
        .concat(extraSystems.flatMap(s => [s.star, ...s.planets]))
        .concat((typeof moonDefs !== "undefined") ? moonDefs : []);

	  for (const def of allDefs) {
        const opt = document.createElement("option");
        opt.value = def.name;
        opt.innerText = def.name;
        ui.planetSelect.appendChild(opt);
        const b = bodies.get(def.name);
        const mesh = b && b.farMesh;
        registerLabel(def.name, def.kind, mesh);
      }
      ui.planetSelect.value = "Arrakis";

      // ====================================================================
      // 5) Modes: orbit / fly / surface
      // ====================================================================
      const mode = { value: "orbit" }; // orbit | fly | surface
      function setMode(m) {
        mode.value = m;
        ui.modePill.textContent = (m === "orbit") ? "√ìrbita" : (m === "fly" ? "Vuelo" : "Superficie");

        // detach all
        try { cameraOrbit.detachControl(canvas); } catch(e){}
        try { cameraFly.detachControl(canvas); } catch(e){}
        try { cameraSurface.detachControl(canvas); } catch(e){}

        if (m === "orbit") {
          // Si volvemos a √ìrbita, soltamos el pointer-lock para no "pelearnos" con la UI.
          if (document.pointerLockElement === canvas) {
            try { document.exitPointerLock?.(); } catch(e) {}
          }
          scn.activeCamera = cameraOrbit;
          cameraOrbit.attachControl(canvas, true);
        } else if (m === "fly") {
          scn.activeCamera = cameraFly;
          cameraFly.attachControl(canvas, true);
        } else {
          scn.activeCamera = cameraSurface;
          cameraSurface.attachControl(canvas, true);
        }
      }

      // Pointer lock (como index-old): click en el canvas para capturar rat√≥n en Vuelo/Superficie
      scn.onPointerDown = () => {
        if (mode.value !== "fly" && mode.value !== "surface") return;
        if (document.pointerLockElement !== canvas) {
          canvas.requestPointerLock?.();
        }
      };

      // (hook listo por si quieres hacer UI cuando se suelta)
      document.addEventListener("pointerlockchange", () => {});


      ui.camOrbitBtn.addEventListener("click", () => setMode("orbit"));
      ui.camFlyBtn.addEventListener("click", () => setMode("fly"));
      ui.camSurfaceBtn.addEventListener("click", () => setMode("surface"));

      ui.speedRange.addEventListener("input", (e) => {
        timeScale = parseFloat(e.target.value);
        ui.speedVal.textContent = timeScale.toFixed(1) + "x";
      });
      ui.speedVal.textContent = timeScale.toFixed(1) + "x";

      // ====================================================================
      // 4b) Toggle labels: OFF = ninguno; ON = estrellas + planetas cercanos
      // ====================================================================
      // Ajustes (baratos):
      const LABEL_NEAREST_PLANETS = 8;     // cu√°ntos planetas mostrar como "cercanos"
      const LABEL_MAX_DIST = 1200;         // adem√°s, muestra planetas dentro de esta distancia (en unidades de tu escena)
      const LABEL_UPDATE_MS = 220;         // throttle del c√°lculo

      function setAllLabelsVisible(v) {
        for (const { rect } of labelsByName.values()) rect.isVisible = !!v;
      }

      function updateLabelVisibility(force = false) {
        if (!showLabels) { setAllLabelsVisible(false); return; }
        const cam = scn.activeCamera;
        if (!cam) return;

        const now = performance.now();
        if (!force && scn._lblTick && (now - scn._lblTick) < LABEL_UPDATE_MS) return;
        scn._lblTick = now;

        const camPos = cam.position;
        const maxD2 = LABEL_MAX_DIST * LABEL_MAX_DIST;

        // 1) estrellas siempre visibles
        for (const [name, meta] of labelsByName.entries()) {
          if (meta.kind === "sun") meta.rect.isVisible = true;
        }

        // 2) ranking de cercanos (planetas + lunas)
        const ranked = [];
        for (const [name, b] of bodies.entries()) {
          if (!b || !b.def || !b.farMesh) continue;
          const k = b.def.kind;
          if (k !== "planet" && k !== "moon") continue;
          const p = b.farMesh.getAbsolutePosition();
          const d2 = BABYLON.Vector3.DistanceSquared(camPos, p);
          ranked.push({ name, d2 });
        }
        ranked.sort((a,b)=>a.d2-b.d2);

        const visiblePlanets = new Set();
        for (let i=0; i<ranked.length && i<LABEL_NEAREST_PLANETS; i++) visiblePlanets.add(ranked[i].name);
        for (const r of ranked) {
          if (r.d2 <= maxD2) visiblePlanets.add(r.name);
          else break; // ya est√° ordenado
        }

        // 3) aplica visibilidad (TODO lo que no sea estrella => depende del set)
        for (const [name, meta] of labelsByName.entries()) {
          if (meta.kind === "sun") continue; // ya visible
          meta.rect.isVisible = visiblePlanets.has(name);
        }
      }

      // UI hook
      if (ui.toggleLabels) {
        showLabels = !!ui.toggleLabels.checked;
        ui.labelsPill.textContent = showLabels ? "ON" : "OFF";
        ui.toggleLabels.addEventListener("change", () => {
          showLabels = !!ui.toggleLabels.checked;
          ui.labelsPill.textContent = showLabels ? "ON" : "OFF";
          updateLabelVisibility(true);
        });
      }

      // ====================================================================
      // 6) Approach: teleport camera to target (fly/surface)
      // ====================================================================
      function getTargetBody() {
        const name = ui.planetSelect.value;
        return bodies.get(name);
      }

      function getActiveSystemId() {
        const b = getTargetBody();
        return (b && b.systemId) ? b.systemId : "Canopus"
      }

      function approachTarget(preferredMode = null) {
        const b = getTargetBody();
        if (!b) return;

        const targetPos = b.farMesh.getAbsolutePosition().clone();
        const r = b.def.radius;

        if (preferredMode) setMode(preferredMode);

        // place camera near surface
        const dir = new BABYLON.Vector3(0.2, 0.25, -1).normalize();
        const camPos = targetPos.add(dir.scale(r * 4.2));

        if (mode.value === "orbit") {
          cameraOrbit.setTarget(targetPos);
          cameraOrbit.radius = Math.max(8, r * 6);
        } else if (mode.value === "fly") {
          cameraFly.position.copyFrom(camPos);
          cameraFly.setTarget(targetPos);
        } else {
          // surface mode: place player root above ground
          const up = dir.scale(-1).normalize();
          playerRoot.position.copyFrom(targetPos.add(up.scale(r * 1.15)));
          cameraSurface.setTarget(targetPos);

          // reset player orientation
          playerRoot.rotationQuaternion = BABYLON.Quaternion.Identity();
          cameraSurface.rotation.set(0,0,0);

          // enable procedural planet for this target if rocky
          ensureProceduralForBody(b);
          enableProceduralOnly(b.def.name);
        }


        // near detail swap: eval inmediato tras aproximar
        try { updateNearDetailForTarget(true); } catch(e) {}
      }

// ====================================================================
// Near detail swap (solo target cercano en orbit/fly)
// ====================================================================
function addUnique(arr, item) {
  if (!arr || !item) return;
  if (!arr.includes(item)) arr.push(item);
}

function setNearDetailEnabled(body, enabled) {
  if (!body || !body.def || !body.farMesh) return;

  // en surface ya existe el procedural chunked; no duplicamos
  if (mode.value === "surface") enabled = false;

  if (enabled) {
    if (!body.nearLand) {
      const created = createHighDetailNearPlanet(scn, body.def, body.orbitNode);
      body.nearLand = created.land;
      body.nearOcean = created.ocean;

      body.nearLand.isPickable = false;
      if (body.nearOcean) body.nearOcean.isPickable = false;

      // lighting include lists (muy importante para sistemas extra)
      if (body.systemId === "Canopus") {
        addUnique(mainLitMeshes, body.nearLand);
        if (body.nearOcean) addUnique(mainLitMeshes, body.nearOcean);
        try { shadowGen.addShadowCaster(body.nearLand); } catch(e){}
        body.nearLand.receiveShadows = true;
        if (body.nearOcean) body.nearOcean.receiveShadows = true;
      } else {
        linkMeshToSystemLight(body.systemId, body.nearLand);
        if (body.nearOcean) linkMeshToSystemLight(body.systemId, body.nearOcean);
      }

      // Freeze near materials AFTER linking lights (para estabilidad/perf)
      try { if (body.nearLand.material) body.nearLand.material.freeze(); } catch(e){}
      try { if (body.nearOcean && body.nearOcean.material) body.nearOcean.material.freeze(); } catch(e){}
    }

    // toggle meshes
    body.farMesh.setEnabled(false);
    if (body.farOcean) body.farOcean.setEnabled(false);
    body.nearLand.setEnabled(true);
    if (body.nearOcean) body.nearOcean.setEnabled(true);
    body._nearEnabled = true;
  } else {
    if (body.nearLand) body.nearLand.setEnabled(false);
    if (body.nearOcean) body.nearOcean.setEnabled(false);
    body.farMesh.setEnabled(true);
    if (body.farOcean) body.farOcean.setEnabled(true);
    body._nearEnabled = false;
  }
}

function updateNearDetailForTarget(force=false) {
  const b = getTargetBody();
  if (!b || !b.def || !b.farMesh) return;

  // solo planetas/lunas (si quieres solo planetas, quita moon)
  if (b.def.kind !== "planet" && b.def.kind !== "moon") return;

  const cam = scn.activeCamera;
  if (!cam) return;

  const now = performance.now();
  if (!force && scn._nearTick && (now - scn._nearTick) < 180) return;
  scn._nearTick = now;

  // si cambi√≥ el target, apaga el near del anterior (para no acumular)
  if (scn._nearTargetName && scn._nearTargetName !== b.def.name) {
    const prev = bodies.get(scn._nearTargetName);
    if (prev) setNearDetailEnabled(prev, false);
  }
  scn._nearTargetName = b.def.name;

  const center = b.farMesh.getAbsolutePosition();
  const dist = BABYLON.Vector3.Distance(cam.position, center);

  const r = b.def.radius || 50;
  const onDist  = r * (b.def.nearEnableMult  || 14.0);
  const offDist = r * (b.def.nearDisableMult || 18.0);

  if (!b._nearEnabled && dist < onDist) setNearDetailEnabled(b, true);
  else if (b._nearEnabled && dist > offDist) setNearDetailEnabled(b, false);
}


      ui.approachBtn.addEventListener("click", () => {
        // If currently orbit, go fly for approach (nice default)
        if (mode.value === "orbit") setMode("fly");
        approachTarget(null);
      });

      // ====================================================================
      // 7) Procedural planet activation (Surface mode)
      // ====================================================================
      function ensureProceduralForBody(body) {
        if (!body.def.rocky) return;
        if (body.proc) return;

        const proc = new ProceduralPlanet(scn, body.def.name, body.def.radius, shadowGen);

        // Preset desde bodyDefs
        if (body.def.biomePreset) proc.biomePreset = body.def.biomePreset;
        if (body.def.biome) proc.biome = body.def.biome;
        // Macro shaping: puedes definir def.macro o legacy continent/islands fields
        if (body.def.macro) proc.macro = body.def.macro;

        if (body.def.terrainScale != null) proc.terrainScale = body.def.terrainScale;
        if (body.def.seaLevel != null) proc.seaLevel = body.def.seaLevel;
        if (body.def.noiseFrequency != null) proc.noiseFrequency = body.def.noiseFrequency;
        if (body.def.noiseOctaves != null) proc.noiseOctaves = body.def.noiseOctaves;
        // en superficie mantenemos low-poly pero con chunks
        // Rendimiento: menos v√©rtices y menos niveles
        proc.chunkResolution = 12;
        proc.maxDetailLevel = 5;
        proc._maxSplitsPerFrame = 6;

        // Atmosfera desactivada por ahora

        body.proc = proc;
      }

      function enableProceduralOnly(name) {
        for (const [n, b] of bodies.entries()) {
          if (b.proc) b.proc.setEnabled(false);
          // also hide far mesh for active rocky planet to avoid z-fighting when near surface
          if (b.def.rocky) b.farMesh.setEnabled(true);
        }

        const b = bodies.get(name);
        if (!b || !b.proc) return;

        // show proc, hide far sphere (and its atmo) for this planet
        b.proc.setEnabled(true);
        b.farMesh.setEnabled(false);
      }

      // When switching to surface mode, approach and enable LOD for selected planet
      ui.camSurfaceBtn.addEventListener("click", () => {
        // ensure procedural is prepared
        const b = getTargetBody();
        if (b && b.def.rocky) ensureProceduralForBody(b);
        setMode("surface");
        approachTarget("surface");
      });

      // If user changes planet while in surface mode, switch planet
      ui.planetSelect.addEventListener("change", () => {
        if (mode.value === "surface") {
          const b = getTargetBody();
          if (b && b.def.rocky) ensureProceduralForBody(b);
          approachTarget("surface");
        }
      });

      // ====================================================================
      // 8) Surface movement + gravity (C-ready)
      // ====================================================================
      const input = {
        forward:false, back:false, left:false, right:false,
        sprint:false, jump:false,
      };

      window.addEventListener("keydown", (e) => {
        if (e.code === "KeyW") input.forward = true;
        if (e.code === "KeyS") input.back = true;
        if (e.code === "KeyA") input.left = true;
        if (e.code === "KeyD") input.right = true;
        if (e.code === "ShiftLeft" || e.code === "ShiftRight") input.sprint = true;
        if (e.code === "Space") input.jump = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "KeyW") input.forward = false;
        if (e.code === "KeyS") input.back = false;
        if (e.code === "KeyA") input.left = false;
        if (e.code === "KeyD") input.right = false;
        if (e.code === "ShiftLeft" || e.code === "ShiftRight") input.sprint = false;
        if (e.code === "Space") input.jump = false;
      });

      let playerVel = new BABYLON.Vector3(0,0,0);
      let onGround = false;

      function surfaceStep(dt) {
        const b = getTargetBody();
        if (!b) return;

        // center of planet in world
        const center = b.farMesh.getAbsolutePosition().clone();
        // if procedural enabled, its root matches farMesh position
        if (b.proc && b.proc.enabled) center.copyFrom(b.proc.root.position);

        const pos = playerRoot.position.clone();
        const toCenter = center.subtract(pos);
        const dist = toCenter.length();
        const down = toCenter.normalize(); // gravity direction
        const up = down.scale(-1);

        // Orient playerRoot so its "up" matches local up (smooth)
        // We'll build a basis where Y=up, Z=forward projected, X=right
        const forwardWorld = cameraSurface.getForwardRay(1).direction;
        const forwardOnTangent = forwardWorld.subtract(up.scale(BABYLON.Vector3.Dot(forwardWorld, up)));
        const fLen = forwardOnTangent.length();
        const forward = (fLen > 1e-4) ? forwardOnTangent.normalize() : BABYLON.Vector3.Cross(new BABYLON.Vector3(1,0,0), up).normalize();
        const right = BABYLON.Vector3.Cross(up, forward).normalize();

        // rotation quaternion from basis
        // Babylon CDN: algunas versiones no traen Matrix.FromXYZAxes.
        // Construimos la matriz de base (column-major) a mano:
        // X = right, Y = up, Z = forward
        const m = new BABYLON.Matrix();
        const mm = m.m;
        mm[0]  = right.x;  mm[1]  = right.y;  mm[2]  = right.z;  mm[3]  = 0;
        mm[4]  = up.x;     mm[5]  = up.y;     mm[6]  = up.z;     mm[7]  = 0;
        mm[8]  = forward.x;mm[9]  = forward.y;mm[10] = forward.z;mm[11] = 0;
        mm[12] = 0;        mm[13] = 0;        mm[14] = 0;        mm[15] = 1;
        const desiredQ = BABYLON.Quaternion.FromRotationMatrix(m);
        playerRoot.rotationQuaternion = BABYLON.Quaternion.Slerp(playerRoot.rotationQuaternion, desiredQ, 0.18);

        // Raycast to ground against procedural chunks if available, else against far mesh
        const rayLen = Math.max(60, b.def.radius * 6);
        const ray = new BABYLON.Ray(pos, down, rayLen);

        let hit = null;
        if (b.proc && b.proc.enabled) {
          hit = scn.pickWithRay(ray, (mesh) => {
            return mesh && mesh.name.startsWith("chunk_") && mesh.parent === b.proc.root;
          });
        } else {
          hit = scn.pickWithRay(ray, (mesh) => mesh === b.farMesh);
        }

        onGround = false;
        const eyeHeight = 2.0;

        if (hit && hit.hit && hit.pickedPoint) {
          const dGround = BABYLON.Vector3.Distance(pos, hit.pickedPoint);
          if (dGround < eyeHeight + 0.8) {
            onGround = true;
            const targetPos = hit.pickedPoint.add(up.scale(eyeHeight));
            // smooth snap to avoid LOD popping
            playerRoot.position = BABYLON.Vector3.Lerp(playerRoot.position, targetPos, 0.25);
            // damp gravity velocity on ground
            playerVel = playerVel.scale(0.75);
          }
        }

        // Gravity
        const g = 9.8;
        if (!onGround) {
          playerVel.addInPlace(down.scale(g * dt));
        } else {
          // Jump
          if (input.jump) {
            playerVel.addInPlace(up.scale(7.0));
            onGround = false;
          }
        }

        // Tangential movement
        const baseSpeed = input.sprint ? 11.0 : 6.0;
        let move = new BABYLON.Vector3(0,0,0);
        if (input.forward) move.addInPlace(forward);
        if (input.back) move.addInPlace(forward.scale(-1));
        if (input.left) move.addInPlace(right.scale(-1));
        if (input.right) move.addInPlace(right);

        if (move.length() > 1e-4) {
          move = move.normalize().scale(baseSpeed * dt);
          playerRoot.position.addInPlace(move);
        }

        // Apply gravity velocity
        playerRoot.position.addInPlace(playerVel.scale(dt));
      }

      // ====================================================================
      // 9) Orbit simulation (simple, for visuals)
      // ====================================================================
      function updateOrbits(dt) {
        if (timeScale <= 0) return;

        // Planets around sun
        for (const [name, b] of bodies.entries()) {
          if (b.def.kind !== "planet") continue;

          const sysS = b.def._sysSpeed || 1;
          b.orbitAngle += (b.def.orbitSpeed * sysS) * dt * timeScale;
          b.orbitNode.rotation.y = b.orbitAngle;

          // spin
          b.farMesh.rotation.y += (b.def.rotSpeed || 0.01) * dt * timeScale;
          if (b.ring) b.ring.rotation.z += 0.3 * dt * timeScale;

          // if procedural exists, keep it aligned with far mesh position and rotation
          if (b.proc) {
            b.proc.root.position.copyFrom(b.farMesh.getAbsolutePosition());
            b.proc.root.rotationQuaternion = b.farMesh.rotationQuaternion ? b.farMesh.rotationQuaternion.clone() : BABYLON.Quaternion.FromEulerAngles(0, b.farMesh.rotation.y, 0);
          }
        }

        // Moons around their parent planet
        for (const [moonName, moonOrbitNode] of moonOrbitNodes.entries()) {
          const m = bodies.get(moonName);
          if (!m) continue;

          const sysSm = m.def._sysSpeed || 1;
          m.orbitAngle += (m.def.orbitSpeed * sysSm) * dt * timeScale;
          moonOrbitNode.rotation.y = m.orbitAngle;

          // spin
          m.farMesh.rotation.y += m.def.rotSpeed * dt * timeScale;
        }
		
      }

      // ====================================================================
      // 10) 
      // ====================================================================
      // 9b) Camera safety: evitar atravesar planetas (colisi√≥n esf√©rica barata)
      // ====================================================================
      const CAM_COLLISION_PADDING = 0.9; // uds
      function enforcePlanetCollision(cam) {
        if (!cam) return;
        const p = cam.position;

        for (const [, b] of bodies.entries()) {
          if (!b || !b.farMesh || !b.def || !b.def.radius) continue;
          if (b.def.kind !== "planet" && b.def.kind !== "moon") continue;

          const c = b.farMesh.getAbsolutePosition();
          const dx = p.x - c.x, dy = p.y - c.y, dz = p.z - c.z;
          const d2 = dx*dx + dy*dy + dz*dz;

          const minR = (b.def.radius + CAM_COLLISION_PADDING);
          const minR2 = minR * minR;

          // early out si lejos
          if (d2 > (minR2 + 2500)) continue;

          if (d2 < minR2) {
            const d = Math.max(0.0001, Math.sqrt(d2));
            const inv = 1.0 / d;
            cam.position.x = c.x + dx * inv * minR;
            cam.position.y = c.y + dy * inv * minR;
            cam.position.z = c.z + dz * inv * minR;
          }
        }
      }

	  // Render loop logic
      // ====================================================================
      setMode("orbit");

      // initial approach nice view
      approachTarget(null);

      scn.onBeforeRenderObservable.add(() => {
        const dt = engine.getDeltaTime() / 1000;

        // keep sunlight at sun
        sunLight.position.copyFrom(sunMesh.position);

        // animate halo (subtle breathing)
        const t = performance.now() * 0.001;
        halo.scaling.set(1 + Math.sin(t*0.8)*0.01, 1 + Math.sin(t*0.9)*0.01, 1 + Math.sin(t*0.7)*0.01);

        // orbits always (even in fly), but you can pause by setting timeScale=0
        updateAllOrbitsAbsolute(performance.now() * 0.001);

        // surface mode: enable procedural only for selected rocky planet
        let chunks = 0;
        if (mode.value === "surface") {
          const b = getTargetBody();
          if (b && b.def.rocky) {
            ensureProceduralForBody(b);
            enableProceduralOnly(b.def.name);
            if (b.proc) {
              b.proc.update(scn.activeCamera);
              chunks = b.proc.countActiveChunks();
            }
          }
          surfaceStep(dt);
        } else {
          // not surface: hide procedural planets to save CPU
          for (const [n, b] of bodies.entries()) {
            if (b.proc) b.proc.setEnabled(false);
            if (b.def.rocky) b.farMesh.setEnabled(true);
          }
        }

        
// Luces locales: con 100 sistemas, NO puedes tener 100 point lights activos.
// Activamos solo las 3 luces m√°s cercanas (incluye Canopus) y desactivamos el resto.
if (!scn._lightTick || (performance.now() - scn._lightTick) > 300) {
  scn._lightTick = performance.now();
  const cam = scn.activeCamera;
  if (cam) {
    const camPos = cam.position;
    const ranked = systemLights
      .map(s => ({ s, d2: BABYLON.Vector3.DistanceSquared(camPos, s.root.getAbsolutePosition()) }))
      .sort((a,b)=>a.d2-b.d2)
      .slice(0, 3)
      .map(x=>x.s);

    const activeIds = new Set(ranked.map(x=>x.id));
    for (const s of systemLights) {
      const should = activeIds.has(s.id);
      if (s.light && s.light.isEnabled() !== should) s.light.setEnabled(should);
    }
    if (ui.lightsPill) ui.lightsPill.textContent = `Luces cercanas: ${ranked.map(x=>x.id).join(", ")}`;
  }
}

// Colisi√≥n c√°mara-planetas (barata, solo sistemas cercanos)
if (typeof enforcePlanetCollision === "function") {
  enforcePlanetCollision(scn.activeCamera);
}

        // Rendimiento: no actualizar el DOM cada frame
        if (!scn._dbgT || (performance.now() - scn._dbgT) > 350) {
          scn._dbgT = performance.now();
          ui.debugInfo.textContent = `Chunks activos: ${chunks} | FPS: ${engine.getFps().toFixed(0)}`;
        }
		
        // Labels: throttle (barato)
        updateLabelVisibility(false);
        updateNearDetailForTarget(false);
      });


	  // Orbit update barato para TODOS usando tiempo absoluto
	  function updateAllOrbitsAbsolute(nowSec) {
        if (timeScale <= 0) return;

        const activeSys = getActiveSystemId();
        const t = nowSec * timeScale;
		
        // Sistemas lejanos: 10 Hz (throttle por sistema)
        const FAR_STEP = 1 / 10;
        if (!scn._farOrbitLastBySystem) scn._farOrbitLastBySystem = new Map();
        const lastBySystem = scn._farOrbitLastBySystem;
        const allowCache = new Map(); // sysId -> bool (para no recalcular por cuerpo)

        function allowSystem(sysId) {
          if (sysId === activeSys) return true;
          if (allowCache.has(sysId)) return allowCache.get(sysId);
          const last = lastBySystem.get(sysId) || 0;
          const ok = (nowSec - last) >= FAR_STEP;
          if (ok) lastBySystem.set(sysId, nowSec);
          allowCache.set(sysId, ok);
          return ok;
        }	
		
        for (const [name, b] of bodies.entries()) {
          if (!b || !b.def) continue;
          const def = b.def;
		  
          const sysId = b.systemId || "Canopus";
          if (!allowSystem(sysId)) continue;

          const sysS = def._sysSpeed || 1;
          const phase = b.orbitAngle || 0;

          if (def.kind === "sun") {
            if (b.farMesh) b.farMesh.rotation.y = t * (def.rotSpeed || 0.02);
            continue;
          }

          if (b.orbitNode) {
            const ang = phase + t * (def.orbitSpeed || 0.001) * sysS;
            b.orbitNode.rotation.y = ang;
          }

          if (b.farMesh) {
            b.farMesh.rotation.y = phase + t * (def.rotSpeed || 0.01);
          }

          // Procedural: solo tiene sentido mantenerlo alineado para el sistema activo
          if (b.proc && sysId === activeSys) {
            b.proc.root.position.copyFrom(b.farMesh.getAbsolutePosition());
            b.proc.root.rotationQuaternion = b.farMesh.rotationQuaternion
              ? b.farMesh.rotationQuaternion.clone()
              : BABYLON.Quaternion.FromEulerAngles(0, b.farMesh.rotation.y, 0);
          }
        }
      }

      return scn;
    };

    const scene = createScene();
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>