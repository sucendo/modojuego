<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Solar Babylon - Orbit + Free Fly + Surface (Chunks/LOD)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#050505}
    #renderCanvas{width:100%;height:100%;touch-action:none;display:block}
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family: 'Segoe UI', sans-serif;
      color:#eee; background:rgba(0,0,0,.65); border:1px solid rgba(255,255,255,.15);
      padding:12px; border-radius:10px; backdrop-filter: blur(4px);
      width: 360px;
    }
    h1{font-size:14px;margin:0 0 10px 0;color:#fa0}
    .row{display:flex;align-items:center;gap:8px;margin:7px 0;font-size:12px}
    .btn{cursor:pointer;background:#2b2b2b;color:#fff;border:1px solid #555;padding:6px 10px;border-radius:6px;font-size:11px}
    .btn:hover{background:#444}
    .btn.primary{border-color:#a80;background:#3a2b10}
    .btn.primary:hover{background:#4a3412}
    select.btn{appearance:none}
    label{color:#ddd}
    .info{font-size:10px;color:#aaa;margin-top:8px;line-height:1.35}
    .split{display:flex;gap:8px}
    .split > *{flex:1}
    #debugInfo{margin-top:8px;font-size:10px;color:#cfc}
    .chk{width:18px;height:18px}
    .pill{display:inline-block;padding:2px 6px;border:1px solid rgba(255,255,255,.15);border-radius:999px;font-size:10px;color:#ddd}
  </style>
</head>
<body>
  <div id="ui">
    <h1>ü™ê Solar Babylon <span class="pill" id="modePill">√ìrbita</span></h1>

    <div class="row split">
      <button id="camOrbit" class="btn primary">√ìrbita</button>
      <button id="camFly" class="btn">Vuelo libre</button>
      <button id="camSurface" class="btn">Superficie</button>
    </div>

    <div class="row">
      <label>Tiempo</label>
      <input id="speedRange" type="range" min="0" max="50" value="1" step="0.1" style="flex:1">
      <span id="speedVal" class="pill">1.0x</span>
    </div>

    <div class="row">
      <label>Objetivo</label>
      <select id="planetSelect" class="btn" style="flex:1"></select>
      <button id="approachBtn" class="btn">Aproximar</button>
    </div>

    <div class="row">
      <label style="flex:1">Nombres</label>
      <input id="toggleLabels" class="chk" type="checkbox" checked>
      <span id="labelsPill" class="pill">ON</span>
    </div>

    <div class="info">
      <b>Vuelo libre:</b> WASD mover, rat√≥n mirar, Shift correr, Espacio subir, Ctrl bajar.<br>
      <b>Superficie:</b> WASD mover, rat√≥n mirar, Espacio saltar, Shift correr. Gravedad hacia el centro.<br>
      <b>LOD/chunks:</b> solo en el planeta activo en modo Superficie para no matar la CPU.
    </div>

    <div id="debugInfo">Chunks activos: 0 | FPS: 0</div>
  </div>

  <canvas id="renderCanvas"></canvas>

  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
  <script src="https://cdn.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>

  <script>
    // ====================================================================
    // 0) Engine
    // ====================================================================
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true, {
      preserveDrawingBuffer: false,
      stencil: false,
      powerPreference: "high-performance",
      adaptToDeviceRatio: true,
    });
    // Rendimiento: baja resoluci√≥n interna en pantallas densas
    try {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      // 1.0 = nativo, 1.25-1.6 suele ser un buen equilibrio
      engine.setHardwareScalingLevel(dpr > 1.25 ? 1.35 : 1.0);
    } catch(e) {}

    // ====================================================================
    // 1) Noise (determinista) + FBM
    // ====================================================================
    function hash3(x, y, z) {
      x = Math.floor(x); y = Math.floor(y); z = Math.floor(z);
      const s = Math.sin(x * 127.1 + y * 311.7 + z * 74.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smooth(t){ return t*t*(3-2*t); }
    function noise3(x, y, z) {
      const xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
      const xf = x - xi, yf = y - yi, zf = z - zi;
      const u = smooth(xf), v = smooth(yf), w = smooth(zf);

      const n000 = hash3(xi,yi,zi),     n100 = hash3(xi+1,yi,zi);
      const n010 = hash3(xi,yi+1,zi),   n110 = hash3(xi+1,yi+1,zi);
      const n001 = hash3(xi,yi,zi+1),   n101 = hash3(xi+1,yi,zi+1);
      const n011 = hash3(xi,yi+1,zi+1), n111 = hash3(xi+1,yi+1,zi+1);

      const x00 = lerp(n000, n100, u), x10 = lerp(n010, n110, u);
      const x01 = lerp(n001, n101, u), x11 = lerp(n011, n111, u);
      const y0  = lerp(x00, x10, v),   y1  = lerp(x01, x11, v);
      return lerp(y0, y1, w);
    }
    function fbm3(x, y, z, oct=6, pers=0.5, lac=2.0) {
      let total = 0, f = 1, a = 1, maxV = 0;
      for (let i=0;i<oct;i++){
        total += noise3(x*f, y*f, z*f) * a;
        maxV += a;
        a *= pers;
        f *= lac;
      }
      return total / Math.max(1e-6, maxV); // 0..1
    }

    // ====================================================================
    // 2) Chunks / Quadtree terrain (cube-sphere)
    // ====================================================================
    class PlanetChunk {
      constructor(parentPlanet, radius, detailLevel, localUp, bounds, material, seed) {
        this.scene = parentPlanet.scene;
        this.parentPlanet = parentPlanet;
        this.localUp = localUp;
        this.bounds = bounds; // {minX,maxX,minY,maxY} in [0..1]
        this.detailLevel = detailLevel;
        this.radius = radius;
        this.material = material;
        this.seed = seed;

        this.children = [];
        this.isLeaf = true;
        this.mesh = null;

        // split distance tuned for web
        this.splitDistance = radius * (1.9 / Math.pow(1.85, detailLevel));
        this.mergeDistance = this.splitDistance * 1.35; // hysteresis
        this.buildMesh();
      }

      buildMesh() {
        const resolution = this.parentPlanet.chunkResolution; // vertices per side
        const positions = [];
        const indices = [];
        const normals = [];
        const uvs = [];
        const colors = []; // vertex colors (biomas)

        const axisA = new BABYLON.Vector3(this.localUp.y, this.localUp.z, this.localUp.x);
        const axisB = BABYLON.Vector3.Cross(this.localUp, axisA);

        for (let y = 0; y <= resolution; y++) {
          for (let x = 0; x <= resolution; x++) {
            const px = x / resolution;
            const py = y / resolution;

            const localX = this.bounds.minX + (this.bounds.maxX - this.bounds.minX) * px;
            const localY = this.bounds.minY + (this.bounds.maxY - this.bounds.minY) * py;

            const pointOnCube = this.localUp
              .add(axisA.scale((localX - 0.5) * 2))
              .add(axisB.scale((localY - 0.5) * 2));

            const pointOnSphere = pointOnCube.clone().normalize();

            // Terrain
            let elevation = 0;
            if (this.parentPlanet.hasTerrain) {
              const f = this.parentPlanet.noiseFrequency;
              const n = fbm3(
                pointOnSphere.x * f + this.seed,
                pointOnSphere.y * f + this.seed,
                pointOnSphere.z * f + this.seed,
                this.parentPlanet.noiseOctaves
              );

              // mountains
              elevation = (n * 2 - 1) * this.parentPlanet.terrainScale;
              // clamp m√≠nimo (permite negativos si seaLevel es negativo)
              elevation = Math.max(elevation, this.parentPlanet.seaLevel);
            }

            const finalPos = pointOnSphere.scale(this.radius * (1 + elevation));
            positions.push(finalPos.x, finalPos.y, finalPos.z);

            // normals initial, recomputed later
            normals.push(pointOnSphere.x, pointOnSphere.y, pointOnSphere.z);

            // (simple) face UVs; good enough for material blending, not for full textures
            uvs.push(px, py);
			
            // Biomes via vertex colors (look ‚Äúprocedural ficticio‚Äù)
            const c = this.parentPlanet.getBiomeColor(pointOnSphere, elevation);
            colors.push(c.r, c.g, c.b, 1.0);
          }
        }

        for (let y = 0; y < resolution; y++) {
          for (let x = 0; x < resolution; x++) {
            const i = x + y * (resolution + 1);
            indices.push(i, i + 1, i + resolution + 1);
            indices.push(i + 1, i + resolution + 2, i + resolution + 1);
          }
        }

        const mesh = new BABYLON.Mesh(`chunk_L${this.detailLevel}`, this.scene);
        const vd = new BABYLON.VertexData();
        vd.positions = positions;
        vd.indices = indices;
        vd.normals = normals;
        vd.uvs = uvs;
		vd.colors = colors;
        vd.applyToMesh(mesh);

        // recompute normals for terrain
        const tempNormals = [];
        BABYLON.VertexData.ComputeNormals(positions, indices, tempNormals);
        mesh.updateVerticesData(BABYLON.VertexBuffer.NormalKind, tempNormals);
        // Low-poly look (faceted). Evitar hacerlo en LOD muy alto para no matar CPU.
        if (this.detailLevel <= 4 && this.parentPlanet.chunkResolution <= 16) {
          try { mesh.convertToFlatShadedMesh(); } catch(e) {}
        }

        mesh.material = this.material;
        mesh.parent = this.parentPlanet.root;
        mesh.isPickable = true;

        // we do raycast picking, no heavy physics impostors
        mesh.checkCollisions = false;

        if (this.parentPlanet.shadowGen && this.parentPlanet.shadowsEnabled) {
          this.parentPlanet.shadowGen.addShadowCaster(mesh);
          mesh.receiveShadows = true;
        } else {
          mesh.receiveShadows = false;
        }

        this.mesh = mesh;
      }

      updateLOD(cameraPos) {
        if (!this.mesh) return;

        // Measure distance to surface patch: camera to chunk bounding sphere center approximation
        const dist = BABYLON.Vector3.Distance(cameraPos, this.mesh.getBoundingInfo().boundingSphere.centerWorld);

        if (dist < this.splitDistance && this.detailLevel < this.parentPlanet.maxDetailLevel) {
          if (this.isLeaf) this.parentPlanet._requestSplit(this);
          if (!this.isLeaf) for (const c of this.children) c.updateLOD(cameraPos);
        } else if (dist > (this.mergeDistance || (this.splitDistance * 1.35))) {
          if (!this.isLeaf) this.merge();
        }
      }

      split() {
        this.isLeaf = false;
        this.mesh.setEnabled(false);

        const next = this.detailLevel + 1;
        const b = this.bounds;
        const midX = (b.minX + b.maxX) / 2;
        const midY = (b.minY + b.maxY) / 2;

        const b1 = { minX: b.minX, maxX: midX, minY: b.minY, maxY: midY };
        const b2 = { minX: midX, maxX: b.maxX, minY: b.minY, maxY: midY };
        const b3 = { minX: b.minX, maxX: midX, minY: midY, maxY: b.maxY };
        const b4 = { minX: midX, maxX: b.maxX, minY: midY, maxY: b.maxY };

        this.children = [
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b1, this.material, this.seed),
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b2, this.material, this.seed),
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b3, this.material, this.seed),
          new PlanetChunk(this.parentPlanet, this.radius, next, this.localUp, b4, this.material, this.seed),
        ];
      }

      merge() {
        this.isLeaf = true;
        this.mesh.setEnabled(true);
        for (const c of this.children) c.dispose();
        this.children = [];
      }

      dispose() {
        if (this.mesh) {
          if (this.parentPlanet.shadowGen) this.parentPlanet.shadowGen.removeShadowCaster(this.mesh);
          this.mesh.dispose();
          this.mesh = null;
        }
        for (const c of this.children) c.dispose();
      }
    }

    class ProceduralPlanet {
      constructor(scene, name, radius, shadowGen) {
        this.scene = scene;
        this.name = name;
        this.radius = radius;
        this.shadowGen = shadowGen;
        this.shadowsEnabled = false;

        this.root = new BABYLON.TransformNode(name + "_procRoot", scene);
        this.faces = [];

        // Tuning
        this.hasTerrain = true;
        this.terrainScale = 0.15;  // Aumentado para monta√±as m√°s altas
        this.seaLevel = -0.02;     // clamp (negativo => permite ‚Äúmar‚Äù visual)
        this.noiseFrequency = 3.5; // Frecuencia m√°s alta para m√°s detalle rocoso
        this.noiseOctaves = 7;     // M√°s octavas para fractales m√°s complejos

        this.chunkResolution = 18; // 18 => (19x19) vertices per chunk
        this.maxDetailLevel = 6;   // keep sane on web
        this.lodDistanceMul = 5.5;

        // Material para chunks de superficie (StandardMaterial = m√°s barato que PBR)
        this.material = new BABYLON.StandardMaterial(name + "_procMat", scene);
        this.material.diffuseColor = new BABYLON.Color3(1, 1, 1);
        this.material.specularColor = new BABYLON.Color3(0.05, 0.05, 0.05);
        this.material.useVertexColor = true;
        // Congelar una vez creado (reduce overhead)
        try { this.material.freeze(); } catch(e) {}

        // Preset de biomas (se sobreescribe por planeta)
        this.biomePreset = "default";

        // Atmosphere (optional)
        this.atmo = null;

        // seed per planet
        this.seed = (name.length * 17.13) % 1000;

        const dirs = [
          new BABYLON.Vector3(0, 1, 0), new BABYLON.Vector3(0, -1, 0),
          new BABYLON.Vector3(1, 0, 0), new BABYLON.Vector3(-1, 0, 0),
          new BABYLON.Vector3(0, 0, 1), new BABYLON.Vector3(0, 0, -1)
        ];

        for (const dir of dirs) {
          this.faces.push(new PlanetChunk(
            this,
            this.radius,
            0,
            dir,
            { minX: 0, maxX: 1, minY: 0, maxY: 1 },
            this.material,
            this.seed
          ));
        }

        this.enabled = true;
        // Rendimiento: limitar splits por frame para evitar tirones
        this._splitQueue = [];
        this._maxSplitsPerFrame = 6;
        this.setEnabled(false); // start hidden, enabled only in surface mode
      }
	  
      // Color por bioma (inspirado en Dune / planetas ficticios)
      getBiomeColor(pOnSphere, elevation) {
        const clamp01 = (x) => Math.max(0, Math.min(1, x));
        const lerp3 = (a,b,t) => new BABYLON.Color3(
          lerp(a.r,b.r,t), lerp(a.g,b.g,t), lerp(a.b,b.b,t)
        );

        // normaliza altura a 0..1 aprox
        const h = elevation; // suele estar en [-0.02 .. +0.16] seg√∫n preset
        const h01 = clamp01((h - this.seaLevel) / Math.max(1e-6, (this.terrainScale * 1.2)));

        // latitud 0..1 (para nieve en polos si aplica)
        const lat = clamp01(Math.abs(pOnSphere.y));

        // presets
        if (this.biomePreset === "arrakis") {
          // Desierto: arena + roca oscura en monta√±as, casi sin agua
          const sand = new BABYLON.Color3(0.82, 0.70, 0.46);
          const dune = new BABYLON.Color3(0.90, 0.78, 0.52);
          const rock = new BABYLON.Color3(0.35, 0.29, 0.22);
          const t = clamp01(Math.pow(h01, 1.2));
          // dunas (ligero ‚Äúbandeado‚Äù)
          const band = (Math.sin((pOnSphere.x + pOnSphere.z) * 18.0) * 0.5 + 0.5) * 0.08;
          const base = lerp3(sand, dune, clamp01(t + band));
          return lerp3(base, rock, clamp01((h01 - 0.65) * 2.2));
        }

        if (this.biomePreset === "caladan") {
          // Oce√°nico: agua profunda + costas claras + verde h√∫medo + nieve en picos/polos
          const deep = new BABYLON.Color3(0.03, 0.12, 0.22);
          const water = new BABYLON.Color3(0.05, 0.22, 0.35);
          const shore = new BABYLON.Color3(0.78, 0.72, 0.55);
          const green = new BABYLON.Color3(0.16, 0.48, 0.18);
          const rock  = new BABYLON.Color3(0.30, 0.28, 0.25);
          const snow  = new BABYLON.Color3(0.92, 0.92, 0.92);

          if (h < 0.0) {
            const d = clamp01((-h) * 10);
            return lerp3(water, deep, d);
          }
          // costa cerca de 0
          const coast = clamp01(1 - Math.abs(h) * 55);
          let land = (h01 < 0.55) ? green : lerp3(green, rock, clamp01((h01 - 0.55) * 1.8));
          land = lerp3(land, shore, coast);
          // nieve por altura + polos
          const snowMask = clamp01((h01 - 0.82) * 4.0) * clamp01((lat - 0.25) * 1.4 + 0.3);
          return lerp3(land, snow, snowMask);
        }

        if (this.biomePreset === "giedi") {
          // Industrial oscuro: basaltos, ceniza, ‚Äúbrillos‚Äù verdosos
          const ash = new BABYLON.Color3(0.10, 0.10, 0.11);
          const basalt = new BABYLON.Color3(0.18, 0.17, 0.16);
          const metal = new BABYLON.Color3(0.22, 0.23, 0.24);
          const toxic = new BABYLON.Color3(0.10, 0.22, 0.12);
          const t = clamp01(Math.pow(h01, 1.1));
          let c = lerp3(ash, basalt, t);
          c = lerp3(c, metal, clamp01((h01 - 0.6) * 2.0));
          // ‚Äúmanchas‚Äù verdosas sutiles
          const stain = clamp01((fbm3(pOnSphere.x*5+this.seed, pOnSphere.y*5+this.seed, pOnSphere.z*5+this.seed, 3) - 0.55) * 3.0);
          c = lerp3(c, toxic, stain * 0.35);
          return c;
        }

        if (this.biomePreset === "ice") {
          // Helado: hielo + roca
          const ice = new BABYLON.Color3(0.78, 0.86, 0.92);
          const snow = new BABYLON.Color3(0.94, 0.95, 0.96);
          const rock = new BABYLON.Color3(0.32, 0.32, 0.35);
          const t = clamp01(h01);
          let c = lerp3(ice, snow, clamp01((t - 0.2) * 1.4));
          c = lerp3(c, rock, clamp01((t - 0.75) * 2.0));
          return c;
        }

        if (this.biomePreset === "ix") {
          // Ix: fr√≠o/tecnol√≥gico (acero + hielo + roca)
          const steel = new BABYLON.Color3(0.38, 0.42, 0.46);
          const rock  = new BABYLON.Color3(0.24, 0.25, 0.28);
          const ice   = new BABYLON.Color3(0.82, 0.88, 0.94);
          const t = clamp01(Math.pow(h01, 1.1));
          let c = lerp3(steel, rock, clamp01((t - 0.35) * 1.5));
          const frost = clamp01((lat - 0.18) * 1.6) * clamp01((0.55 - h01) * 2.0);
          c = lerp3(c, ice, frost);
          return c;
        }

        if (this.biomePreset === "kaitain") {
          // Kaitain: templado imperial (praderas, tierras claras, mares)
          const water = new BABYLON.Color3(0.05, 0.18, 0.30);
          const deep  = new BABYLON.Color3(0.02, 0.08, 0.16);
          const shore = new BABYLON.Color3(0.80, 0.74, 0.56);
          const grass = new BABYLON.Color3(0.20, 0.55, 0.22);
          const soil  = new BABYLON.Color3(0.58, 0.52, 0.38);
          const rock  = new BABYLON.Color3(0.32, 0.30, 0.28);

          if (h < 0.0) {
            const d = clamp01((-h) * 10);
            return lerp3(water, deep, d);
          }
          const coast = clamp01(1 - Math.abs(h) * 65);
          let land = (h01 < 0.48) ? grass : lerp3(grass, soil, clamp01((h01 - 0.48) * 1.7));
          land = lerp3(land, rock, clamp01((h01 - 0.78) * 2.2));
          land = lerp3(land, shore, coast);
          return land;
        }

        if (this.biomePreset === "salusa") {
          // Salusa Secundus: √°spero, c√°rcavas, roca rojiza
          const dark = new BABYLON.Color3(0.12, 0.10, 0.10);
          const rust = new BABYLON.Color3(0.42, 0.22, 0.16);
          const rock = new BABYLON.Color3(0.30, 0.22, 0.20);
          const t = clamp01(Math.pow(h01, 1.2));
          let c = lerp3(dark, rust, clamp01(t + 0.12));
          c = lerp3(c, rock, clamp01((h01 - 0.62) * 2.2));
          // ceniza/tormentas sutiles
          const ash = clamp01((fbm3(pOnSphere.x*4+this.seed, pOnSphere.y*4+this.seed, pOnSphere.z*4+this.seed, 3) - 0.55) * 3.2);
          c = lerp3(c, dark, ash * 0.25);
          return c;
        }

        if (this.biomePreset === "richese") {
          // Richese: archipi√©lagos, mares turquesa, costas claras
          const deep  = new BABYLON.Color3(0.02, 0.14, 0.20);
          const water = new BABYLON.Color3(0.04, 0.28, 0.34);
          const aqua  = new BABYLON.Color3(0.08, 0.42, 0.40);
          const shore = new BABYLON.Color3(0.86, 0.80, 0.62);
          const green = new BABYLON.Color3(0.18, 0.56, 0.22);
          const rock  = new BABYLON.Color3(0.30, 0.30, 0.28);

          if (h < 0.0) {
            const d = clamp01((-h) * 10);
            return lerp3(water, deep, d);
          }
          const coast = clamp01(1 - Math.abs(h) * 80);
          let land = (h01 < 0.55) ? green : lerp3(green, rock, clamp01((h01 - 0.55) * 1.9));
          land = lerp3(land, shore, coast);
          // lagunas turquesa (manchas)
          const lagoon = clamp01((fbm3(pOnSphere.x*6+this.seed, pOnSphere.y*6+this.seed, pOnSphere.z*6+this.seed, 2) - 0.58) * 3.4);
          land = lerp3(land, aqua, lagoon * 0.18);
          return land;
        }

        if (this.biomePreset === "lava") {
          // Lava world: basalto/ceniza + mares de lava (emissive se aplica en el material del oc√©ano)
          const ash   = new BABYLON.Color3(0.08, 0.08, 0.09);
          const basalt= new BABYLON.Color3(0.14, 0.14, 0.15);
          const rock  = new BABYLON.Color3(0.22, 0.21, 0.21);
          const hot   = new BABYLON.Color3(0.75, 0.22, 0.04);  // costras calientes
          const glow  = new BABYLON.Color3(1.00, 0.38, 0.06);  // lava brillante (solo color base)

          // h < 0 => ‚Äúmar‚Äù (lava)
          if (h < 0.0) {
            // m√°s brillante cerca del borde (poco profundo)
            const shallow = clamp01(1.0 - clamp01((-h) * 18.0));
            // manchas/venas en la lava
            const veins = clamp01((fbm3(pOnSphere.x*7+this.seed, pOnSphere.y*7+this.seed, pOnSphere.z*7+this.seed, 3) - 0.55) * 3.0);
            let c = lerp3(new BABYLON.Color3(0.35,0.06,0.02), glow, shallow);
            c = lerp3(c, new BABYLON.Color3(1.0,0.65,0.15), veins*0.55);
            return c;
          }

          // tierra: ceniza abajo -> basalto -> roca -> ‚Äúhot caps‚Äù en cimas
          let land = lerp3(ash, basalt, clamp01(h01 * 1.2));
          land = lerp3(land, rock, clamp01((h01 - 0.45) * 1.6));

          // cimas ‚Äúm√°s calientes / erosionadas‚Äù
          const peak = clamp01((h01 - 0.72) / 0.22);
          land = lerp3(land, hot, peak);
          return land;
        }		

        // default (rocoso simple)
        const low = new BABYLON.Color3(0.35, 0.35, 0.37);
        const high = new BABYLON.Color3(0.55, 0.55, 0.55);
        return lerp3(low, high, h01);
      }

      setEnabled(on) {
        this.enabled = on;
        this.root.setEnabled(on);
        for (const f of this.faces) this._setChunkTreeEnabled(f, on);
        if (this.atmo) this.atmo.setEnabled(on);
      }

// Sombras por sistema: se activan/desactivan sin recrear el planeta
setShadowsEnabled(on) {
  this.shadowsEnabled = !!on;
  if (!this.shadowGen) return;

  const sg = this.shadowGen;
  const apply = (chunk) => {
    if (chunk.mesh) {
      if (this.shadowsEnabled) {
        sg.addShadowCaster(chunk.mesh);
        chunk.mesh.receiveShadows = true;
      } else {
        try { sg.removeShadowCaster(chunk.mesh); } catch(e) {}
        chunk.mesh.receiveShadows = false;
      }
    }
    if (!chunk.isLeaf) for (const c of chunk.children) apply(c);
  };
  for (const f of this.faces) apply(f);
}

      _setChunkTreeEnabled(chunk, on) {
        if (chunk.mesh) chunk.mesh.setEnabled(on && chunk.isLeaf);
        if (!chunk.isLeaf) for (const c of chunk.children) this._setChunkTreeEnabled(c, on);
      }

      _requestSplit(chunk) {
        // Evita duplicados
        if (chunk._queued) return;
        chunk._queued = true;
        this._splitQueue.push(chunk);
      }

      update(camera) {
        if (!this.enabled) return;

        // update lod only if camera is near
        const dist = BABYLON.Vector3.Distance(camera.position, this.root.position);
        if (dist < this.radius * this.lodDistanceMul) {
          for (const f of this.faces) f.updateLOD(camera.position);
        }

        // Procesa splits con presupuesto por frame (evita picos)
        let budget = this._maxSplitsPerFrame;
        while (budget-- > 0 && this._splitQueue.length) {
          const ch = this._splitQueue.shift();
          if (!ch) break;
          ch._queued = false;
          if (ch.isLeaf) ch.split();
        }
      }

      countActiveChunks() {
        let total = 0;
        for (const f of this.faces) total += this._countLeaves(f);
        return total;
      }
      _countLeaves(chunk) {
        if (chunk.isLeaf) return (chunk.mesh && chunk.mesh.isEnabled()) ? 1 : 0;
        let c = 0;
        for (const ch of chunk.children) c += this._countLeaves(ch);
        return c;
      }

      dispose() {
        for (const f of this.faces) f.dispose();
        this.faces = [];
        if (this.atmo) this.atmo.dispose();
        this.root.dispose();
      }
    }

    
    // ====================================================================
    // 3) Low-poly far planets (vertex-displaced + vertex colors)
    // ====================================================================
    function createLowPolyFarPlanet(scene, def, orbitNode) {
      const seg = def.farSegments || 48;
      const land = BABYLON.MeshBuilder.CreateSphere(def.name + "_land", { diameter: def.radius * 2, segments: seg }, scene);
      land.parent = orbitNode;
      land.position.set(def.orbitR, 0, 0);

      // Material (vertex colors)
      const landMat = new BABYLON.StandardMaterial(def.name + "_landMat", scene);
      landMat.diffuseColor = new BABYLON.Color3(1,1,1);
      landMat.specularColor = new BABYLON.Color3(0.06,0.06,0.06);
      landMat.useVertexColor = true;
      land.material = landMat;

      // Optional micro bump to avoid "plastic" look
      if (def.microBump) {
        const bt = loadTextureOrNull(scene, def.microBump);
        if (bt) {
          bt.uScale = 6;
          bt.vScale = 6;
          landMat.bumpTexture = bt;
          landMat.bumpTexture.level = 0.8;
        }
      }

      const positions = land.getVerticesData(BABYLON.VertexBuffer.PositionKind);
      const normals   = land.getVerticesData(BABYLON.VertexBuffer.NormalKind);
      if (!positions || !normals) return { land, ocean: null };

      const colors = new Array((positions.length/3) * 4);

      // Dummy for palette reuse
      const dummy = {
        seed: (def.name.length * 17.13) % 1000,
        biomePreset: def.biomePreset || "default",
        seaLevel: (def.seaLevel ?? 0.0),
        terrainScale: (def.terrainScale ?? 0.12),
      };

      const f = def.noiseFrequency ?? 2.6;
      const oct = def.noiseOctaves ?? 6;
      const amp = def.terrainScale ?? 0.12;
      const sea = def.seaLevel ?? 0.0;

      // Helpers
      const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
      const quant = (x,step)=> (step>0? (Math.round(x/step)*step) : x);

      for (let i=0; i<positions.length; i+=3) {
        // unit direction
        const nx = normals[i], ny = normals[i+1], nz = normals[i+2];

        // domain warp (reduces repetition)
        const w = (fbm3(nx*f*1.2 + dummy.seed, ny*f*1.2 + dummy.seed, nz*f*1.2 + dummy.seed, 3) * 2 - 1) * 0.25;
        const wx = nx + w, wy = ny + w*0.35, wz = nz - w*0.2;

        const n0 = (fbm3(wx*f + dummy.seed, wy*f + dummy.seed, wz*f + dummy.seed, oct) * 2 - 1);
        // ridged mountains
        const r0 = 1.0 - Math.abs(n0);
        const ridge = Math.pow(clamp(r0,0,1), 2.2);

        // extra detail
        const n1 = (fbm3(wx*f*2.4 + 19.7 + dummy.seed, wy*f*2.4 + 3.3 + dummy.seed, wz*f*2.4 + 11.1 + dummy.seed, 4) * 2 - 1);

        // base elevation
        let elev = (n0 * 0.55 + ridge * 0.55 + n1 * 0.12) * amp;

        // Planet-specific flavor
        if (dummy.biomePreset === "arrakis") {
          // dunes banding
          const band = (Math.sin((wx + wz) * 16.0) * 0.5 + 0.5) * 0.10;
          elev += band * amp * 0.55;
        }
        if (dummy.biomePreset === "giedi" || dummy.biomePreset === "salusa") {
          // harsher craters/erosion feel
          const pits = (fbm3(wx*f*4.0 + 99.0 + dummy.seed, wy*f*4.0 + 17.0 + dummy.seed, wz*f*4.0 + 33.0 + dummy.seed, 3) - 0.55);
          elev += pits * amp * 0.20;
        }

        // clamp by seaLevel (visual basins)
        elev = Math.max(elev, sea);

        // low-poly quantization for chunky facets
        elev = quant(elev, amp * 0.11);

        const scale = def.radius * (1 + elev);
        positions[i]   = nx * scale;
        positions[i+1] = ny * scale;
        positions[i+2] = nz * scale;

        const c = ProceduralPlanet.prototype.getBiomeColor.call(dummy, new BABYLON.Vector3(nx,ny,nz), elev);
        const ci = (i/3)*4;
        colors[ci] = c.r; colors[ci+1] = c.g; colors[ci+2] = c.b; colors[ci+3] = 1.0;
      }

      land.updateVerticesData(BABYLON.VertexBuffer.PositionKind, positions);
      land.setVerticesData(BABYLON.VertexBuffer.ColorKind, colors);
      // recompute normals after displacement
      BABYLON.VertexData.ComputeNormals(positions, land.getIndices(), normals);
      land.updateVerticesData(BABYLON.VertexBuffer.NormalKind, normals);
      try { land.convertToFlatShadedMesh(); } catch(e){}

      // Optional ocean sphere
      let ocean = null;
	  if (def.ocean) {
		const seaFrac = Math.max(0.6, 1 + sea + 0.002);
		ocean = BABYLON.MeshBuilder.CreateSphere(
			def.name + "_ocean",
			{ diameter: def.radius * 2 * seaFrac, segments: Math.max(24, Math.floor(seg * 0.7)) },
			scene
		);
		ocean.parent = orbitNode;
		ocean.position.set(def.orbitR, 0, 0);
		ocean.isPickable = false;
		
		const oceanKind = def.oceanKind || "water";
		const om = new BABYLON.PBRMaterial(def.name + "_oceanMat", scene);
		
		if (oceanKind === "lava" || def.biomePreset === "lava") {
			// --- LAVA: emisivo, sin refracci√≥n/translucidez, m√°s rugoso ---
			om.albedoColor = new BABYLON.Color3(0.10, 0.03, 0.02); // base oscura
			om.metallic = 0.0;
			om.roughness = 0.55; // lava "espesa" (menos espejo)
			om.alpha = 1.0;
			om.transparencyMode = BABYLON.PBRMaterial.PBR_OPAQUE;
			om.backFaceCulling = true;
		
			const lavaCol = (def.lavaColor || new BABYLON.Color3(1.0, 0.35, 0.08));
			om.emissiveColor = lavaCol.scale(def.lavaIntensity ?? 1.8);
		
			// Si quieres ‚Äúvetas‚Äù brillantes + animaci√≥n
			if (def.lavaTexture) {
			const lt = loadTextureOrNull(scene, def.lavaTexture);
			if (lt) {
				lt.uScale = 6; lt.vScale = 6;
				om.emissiveTexture = lt;
				const spd = def.lavaFlowSpeed ?? 0.06;
				scene.onBeforeRenderObservable.add(() => {
				const dt = scene.getEngine().getDeltaTime() * 0.001;
				lt.uOffset += dt * spd;
				lt.vOffset += dt * (spd * 0.65);
				});
			}
			}
		
			// Importante: lava NO es transl√∫cida
			om.indexOfRefraction = 1.0;
			om.translucencyIntensity = 0.0;
		
		} else {
			// --- AGUA: tu configuraci√≥n actual ---
			om.albedoColor = def.oceanColor || new BABYLON.Color3(0.05,0.18,0.28);
			om.metallic = 0.15;
			om.roughness = 0.2;
			om.alpha = 0.9;
			om.useAlphaFromAlbedoTexture = false;
			om.transparencyMode = BABYLON.PBRMaterial.PBR_ALPHABLEND;
			om.backFaceCulling = true;
			om.indexOfRefraction = 1.33;
			om.translucencyIntensity = 0.5;
		}
		
		ocean.material = om;
		ocean.receiveShadows = true;
	  }
		

      return { land, ocean };
    }
    // ====================================================================
    // 3) Helpers (textures/materials/atmospheres)
    // ====================================================================
    function loadTextureOrNull(scene, url, { hasAlpha=false } = {}) {
      try {
        const t = new BABYLON.Texture(url, scene, true, false, BABYLON.Texture.TRILINEAR_SAMPLINGMODE,
          null,
          () => console.warn("[texture] no se pudo cargar:", url)
        );
        t.hasAlpha = !!hasAlpha;
        return t;
      } catch (e) {
        console.warn("[texture] error creando textura:", url, e);
        return null;
      }
    }

    function makePlanetPBR(scene, name, maps) {
      const mat = new BABYLON.PBRMaterial(name, scene);
      mat.metallic = 0.0;
      mat.roughness = maps?.roughness ?? 0.95;
      mat.specularIntensity = maps?.specularIntensity ?? 0.15;

      if (maps?.albedo) {
        const a = loadTextureOrNull(scene, maps.albedo);
        if (a) mat.albedoTexture = a;
      } else {
        mat.albedoColor = maps?.fallbackColor ?? new BABYLON.Color3(0.6,0.6,0.6);
      }

      if (maps?.normal) {
        const n = loadTextureOrNull(scene, maps.normal);
        if (n) {
          mat.bumpTexture = n;
          mat.bumpTexture.level = maps.bumpLevel ?? 1.0;
        }
      }
      if (maps?.bump) {
        const b = loadTextureOrNull(scene, maps.bump);
        if (b) {
          mat.bumpTexture = b;
          mat.bumpTexture.level = maps.bumpLevel ?? 0.8;
        }
      }

      return mat;
    }

    function makeAtmosphere(scene, parentNode, radius, color3, alpha=0.35) {
      const atmo = BABYLON.MeshBuilder.CreateSphere(parentNode.name + "_Atmo", { diameter: radius * 2.18, segments: 48 }, scene);
      atmo.parent = parentNode;
      atmo.isPickable = false;

      const mat = new BABYLON.StandardMaterial(parentNode.name + "_AtmoMat", scene);
      mat.diffuseColor = BABYLON.Color3.Black();
      mat.specularColor = BABYLON.Color3.Black();
      mat.emissiveColor = color3;
      mat.alpha = alpha;
      mat.backFaceCulling = false;

      // Fresnel-ish edge glow
      mat.emissiveFresnelParameters = new BABYLON.FresnelParameters();
      mat.emissiveFresnelParameters.bias = 0.2;
      mat.emissiveFresnelParameters.power = 2.0;
      mat.emissiveFresnelParameters.leftColor = BABYLON.Color3.Black();
      mat.emissiveFresnelParameters.rightColor = color3;

      atmo.material = mat;
      return atmo;
    }

    // ====================================================================
    // 4) Scene
    // ====================================================================
    const ui = {
      camOrbitBtn: document.getElementById("camOrbit"),
      camFlyBtn: document.getElementById("camFly"),
      camSurfaceBtn: document.getElementById("camSurface"),
      speedRange: document.getElementById("speedRange"),
      speedVal: document.getElementById("speedVal"),
      planetSelect: document.getElementById("planetSelect"),
      approachBtn: document.getElementById("approachBtn"),
      debugInfo: document.getElementById("debugInfo"),
      modePill: document.getElementById("modePill"),
      toggleLabels: document.getElementById("toggleLabels"),
      labelsPill: document.getElementById("labelsPill"),
    };

    let timeScale = 1.0;

    const createScene = () => {
      const scn = new BABYLON.Scene(engine);
      // Rendimiento: evita trabajo extra de picking continuo
      scn.skipPointerMovePicking = true;
      scn.blockMaterialDirtyMechanism = true;
      // Fondo realmente negro (evita el "cielo gris" cuando sube la exposici√≥n/bloom)
      scn.clearColor = new BABYLON.Color4(0, 0, 0, 1);
	  
      // Iluminaci√≥n Global (IBL) muy suave (sin crear skybox/ground)
      scn.environmentIntensity = 0.15;

      // Background stars (point cloud, estilo "inicio"; sin URLs externas)
      const starsPCS = new BABYLON.PointsCloudSystem("stars", 1, scn);
      const starCount = 12000; // rendimiento
      const starRadius = 2800;
      let starsMesh = null;

      starsPCS.addPoints(starCount, (p) => {
        // distribuci√≥n esf√©rica (m√°s estrellas lejos)
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);

        const r = starRadius * (0.35 + 0.65 * Math.pow(Math.random(), 0.35));
        p.position.x = r * Math.sin(phi) * Math.cos(theta);
        p.position.y = r * Math.cos(phi);
        p.position.z = r * Math.sin(phi) * Math.sin(theta);

        // brillo con ligera variaci√≥n
        const a = 0.55 + Math.random() * 0.45;
        p.color = new BABYLON.Color4(1, 1, 1, a);
      });

      starsPCS.buildMeshAsync().then((m) => {
        starsMesh = m;
        starsMesh.isPickable = false;
        starsMesh.alwaysSelectAsActiveMesh = true;

        const starsMat = new BABYLON.StandardMaterial("starsMat", scn);
        starsMat.emissiveColor = new BABYLON.Color3(0.9, 0.9, 0.9);
        starsMat.disableLighting = true;
        starsMat.pointsCloud = true;

		starsMat.pointSize = 1.15;
        starsMesh.material = starsMat;
      });
	  
      // Mantener las estrellas "infinito" siguiendo la c√°mara
      scn.onBeforeRenderObservable.add(() => {
        updateAllOrbitsAbsolute(performance.now() * 0.001);
        if (starsMesh && scn.activeCamera) {
          starsMesh.position.copyFrom(scn.activeCamera.position);
        }
      });

      // Cameras
      const cameraOrbit = new BABYLON.ArcRotateCamera("camOrbit", -Math.PI/2, Math.PI/3, 260, BABYLON.Vector3.Zero(), scn);
      cameraOrbit.lowerRadiusLimit = 8;
      cameraOrbit.upperRadiusLimit = 2500;
      cameraOrbit.wheelDeltaPercentage = 0.01;
      cameraOrbit.attachControl(canvas, true);

      const cameraFly = new BABYLON.UniversalCamera("camFly", new BABYLON.Vector3(0, 60, -220), scn);
      cameraFly.minZ = 0.1;
      cameraFly.speed = 2.2;
      cameraFly.angularSensibility = 4000;
      cameraFly.keysUp = [87];    // W
      cameraFly.keysDown = [83];  // S
      cameraFly.keysLeft = [65];  // A
      cameraFly.keysRight = [68]; // D
      // add vertical controls
      cameraFly.keysUpward = [32];       // Space up
      cameraFly.keysDownward = [17, 67]; // Ctrl or C down

      // Surface camera: use a playerRoot for proper orientation
      const playerRoot = new BABYLON.TransformNode("playerRoot", scn);
      playerRoot.rotationQuaternion = BABYLON.Quaternion.Identity();

      const cameraSurface = new BABYLON.UniversalCamera("camSurface", new BABYLON.Vector3(0, 2, 0), scn);
      cameraSurface.parent = playerRoot;
      cameraSurface.minZ = 0.05;
      cameraSurface.speed = 0; // we implement movement ourselves
      cameraSurface.angularSensibility = 3500;

      scn.activeCamera = cameraOrbit;

      // Lights
      const sunLight = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scn);
      sunLight.intensity = 2.2;
      sunLight.range = 8000;

      
      // Light linking: Canopus s√≥lo ilumina su propio sistema (mejora rendimiento y evita 'todo gira/ilumina Canopus')
      const mainLitMeshes = [];
      sunLight.includedOnlyMeshes = mainLitMeshes;
      const hemi = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scn);
      hemi.intensity = 0.10;
      hemi.diffuse = new BABYLON.Color3(0.1, 0.1, 0.2); // Tinte azulado para ambiente espacial
      hemi.groundColor = new BABYLON.Color3(0,0,0);

      // Un pel√≠n de ambiente para que no queden negros en superficie sin "subir" el cielo
      scn.ambientColor = new BABYLON.Color3(0.05, 0.05, 0.06);
// Shadows (por sistema; se activan SOLO en el sistema que est√°s explorando)
// Core (Canopus) usa sunLight
const coreShadowGen = new BABYLON.ShadowGenerator(2048, sunLight);
coreShadowGen.usePoissonSampling = true;
coreShadowGen.bias = 0.00025;
coreShadowGen.normalBias = 0.01;

// Por defecto: desactivado hasta que "Canopus" sea el sistema activo
coreShadowGen.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
coreShadowGen.getShadowMap().renderList = [];
      // Glow desactivado por rendimiento (ya tenemos halo del sol)
      // const glow = new BABYLON.GlowLayer("glow", scn);
      // glow.intensity = 0.12;

      // Textures (put these in: /textures/planets/)
      const T = (f) => "textures/planets/" + f;

      const mapsByName = {
        // Texturas opcionales (si las pones en /textures/planets/)
        // Si no existen, el c√≥digo hace fallback a colores.
        "Canopus": { /* albedo: T("2k_sun.jpg") */ },
      };

      // Bodies definition (not to scale; tuned for visuals)
            // ===================================================
      // Systems definition (single source of truth)
      // - Canopus is treated like any other system (extraSystems[0])
      // - bodyDefs se mantiene como "flatten" para el pipeline actual (UI, surface, etc.)
      // ===================================================
      const coreSystem = {
        id: "Canopus",
        speedScale: 1,
        pos: new BABYLON.Vector3(0, 0, 0),
        star: {
          name:"Canopus", kind:"sun", radius: 50,
          orbitR: 0, orbitSpeed: 0, rotSpeed: 0.002,
          rocky:false,
        },
        planets: [
          // Planetas de la novela
          {
            name:"Arrakis", kind:"planet", radius: 6.2,
            orbitR: -340, orbitSpeed: 0.00060, rotSpeed: 0.080,
            rocky:true,
            biomePreset:"arrakis",
            near:{ chunkResolution:14, maxDetailLevel:6, maxSplitsPerFrame:8, lodDistanceMul:6.2, swapMul:7.2 },
            terrainScale: 0.22,
            seaLevel: 0.01,          // sin oc√©ano
            noiseFrequency: 2.9,
            noiseOctaves: 6,
            farSegments: 48,
            ocean:false,
            oceanColor: new BABYLON.Color3(0.04,0.12,0.18),
            microBump: T("detail_rock3.png"),
          },
          {
            name:"Caladan", kind:"planet", radius: 7.0,
            orbitR: 400, orbitSpeed: 0.00052, rotSpeed: -0.107,
            rocky:true,
            biomePreset:"caladan",
            terrainScale: 0.13,
            seaLevel: 0.0355,        // mucho mar
            noiseFrequency: 2.1,
            noiseOctaves: 6,
            farSegments: 52,
            ocean:true,
            oceanColor: new BABYLON.Color3(0.04,0.20,0.30),
            microBump: T("detail_craters.png"),
          },
          {
            name:"Giedi Prime", kind:"planet", radius: 6.6,
            orbitR: 465, orbitSpeed: 0.00046, rotSpeed: 0.092,
            rocky:true,
            biomePreset:"giedi",
            terrainScale: 0.20,
            seaLevel: 0.008,        // charcos/mares m√≠nimos
            noiseFrequency: 3.2,
            noiseOctaves: 5,
            farSegments: 50,
            ocean:true,
            oceanColor: new BABYLON.Color3(0.02,0.08,0.05),
            microBump: T("detail_rock2.png"),
          },
          {
            name:"Ix", kind:"planet", radius: 5.9,
            orbitR: 530, orbitSpeed: 0.00040, rotSpeed: 0.204,
            rocky:true,
            biomePreset:"ix",
            terrainScale: 0.16,
            seaLevel: -0.012,
            noiseFrequency: 2.7,
            noiseOctaves: 6,
            farSegments: 48,
            ocean:true,
            oceanColor: new BABYLON.Color3(0.03,0.12,0.18),
            microBump: T("detail_snow.png"),
          },
          {
            name:"Kaitain", kind:"planet", radius: 6.3,
            orbitR: 595, orbitSpeed: 0.00035, rotSpeed: 0.106,
            rocky:true,
            biomePreset:"kaitain",
            terrainScale: 0.12,
            seaLevel: -0.022,
            noiseFrequency: 2.2,
            noiseOctaves: 6,
            farSegments: 50,
            ocean:true,
            oceanColor: new BABYLON.Color3(0.04,0.18,0.26),
            microBump: T("detail_craters.png"),
          },
          {
            name:"Salusa Secundus", kind:"planet", radius: 6.0,
            orbitR: 670, orbitSpeed: 0.00030, rotSpeed: 0.109,
            rocky:true,
            biomePreset:"salusa",
            terrainScale: 0.24,
            seaLevel: 0.01,          // sin oc√©ano
            noiseFrequency: 3.0,
            noiseOctaves: 6,
            farSegments: 48,
            ocean:false,
            microBump: T("detail_rock3.png"),
          },
          {
            name:"Richese", kind:"planet", radius: 6.4,
            orbitR: 760, orbitSpeed: 0.00026, rotSpeed: 0.108,
            rocky:true,
            biomePreset:"richese",
            terrainScale: 0.11,
            seaLevel: -0.01250,        // planeta muy oce√°nico
            noiseFrequency: 2.0,
            noiseOctaves: 6,
            farSegments: 52,
            ocean:true,
            oceanColor: new BABYLON.Color3(0.05,0.26,0.30),
            microBump: T("detail_craters.png"),
            // --- Continentes + archipi√©lagos (solo Richese) ---
            continentFreq: 0.55,        // muy baja: forma masas grandes
            continentStrength: 0.55,    // cu√°nto ‚Äúlevanta‚Äù el continente
            islandsFreq: 4.8,           // alta: islas
            islandsStrength: 0.22       // cu√°nto ‚Äúmuerde‚Äù cerca de costa
          },
			{
			  name:"Vulcanis", kind:"planet", radius: 6.1,
			  orbitR: 820, orbitSpeed: 0.00022, rotSpeed: 0.11,
			  rocky:true,
			  biomePreset:"lava",
			  terrainScale: 0.20,
			  seaLevel: -0.0980,          // bajo 0 => ‚Äúmar‚Äù de lava
			  noiseFrequency: 2.9,
			  noiseOctaves: 6,
			  farSegments: 52,
			  ocean:true,
			  oceanKind:"lava",          // <- clave
			  lavaIntensity: 2.0,        // brillo
			  lavaFlowSpeed: 0.06,       // animaci√≥n
			  lavaColor: new BABYLON.Color3(1.0, 0.35, 0.08), // tono lava
			  microBump: T("detail_rock2.png"),
			},
        ],
        moons: [
          // Lunas de Arrakis (novela: 2 lunas; una con "Hand of God" y otra llamada Muad'dib)
          { name:"First Moon", kind:"moon", radius: 1.55, orbitR: 14.5, orbitSpeed: 0.060, rotSpeed: 0.010, atmo:false, rocky:true, parent:"Arrakis" },
          { name:"Muad'dib",   kind:"moon", radius: 1.05, orbitR: 10.2, orbitSpeed: 0.085, rotSpeed: 0.012, atmo:false, rocky:true, parent:"Arrakis" },
        ],
      };

      // Bodies definition (flattened, no a escala; valores ajustados a visual)
      const bodyDefs = [
        coreSystem.star,
        ...coreSystem.planets,
        ...coreSystem.moons
      ];

      const extraSystems = [
        coreSystem,
        {
          id: "Ecaz",
          speedScale: 6,
          pos: new BABYLON.Vector3(1400, 120, -900),
          star: { name: "Star Ecaz", kind:"sun", radius: 28, emissive: new BABYLON.Color3(1.0,0.86,0.55) },
          planets: [
            { name:"Ecaz ‚Äì Ecaz", kind:"planet", radius: 5.2, orbitR: 120, orbitSpeed: 0.00080, rotSpeed: 0.050, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 24 },
            { name:"Ecaz ‚Äì Tupile", kind:"planet", radius: 4.3, orbitR: 170, orbitSpeed: 0.00060, rotSpeed: 0.040, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 24 },
            { name:"Ecaz ‚Äì Sikun", kind:"planet", radius: 3.8, orbitR: 230, orbitSpeed: 0.00048, rotSpeed: 0.060, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Ecaz ‚Äì Chusuk", kind:"planet", radius: 3.1, orbitR: 290, orbitSpeed: 0.00038, rotSpeed: 0.070, rocky:true, biomePreset:"ix", seaLevel:-0.02, ocean:true, farSegments: 18 },
          ],
		  moons: [
            { name:"Moonka", kind:"moon", radius: 1.55, orbitR: 14.5, orbitSpeed: 0.060, rotSpeed: 0.010, atmo:true, rocky:true, parent:"Ecaz ‚Äì Sikun" },
            { name:"Moonku", kind:"moon", radius: 1.05, orbitR: 10.2, orbitSpeed: 0.085, rotSpeed: 0.003, atmo:false, rocky:true, biomePreset:"salusa", parent:"Ecaz ‚Äì Ecaz" },
		  ],
        },
        {
          id: "Wallach",
          speedScale: 6,
          pos: new BABYLON.Vector3(-1550, 40, -1050),
          star: { name: "Star Wallach", kind:"sun", radius: 30, emissive: new BABYLON.Color3(0.95,0.92,0.78) },
          planets: [
            { name:"Wallach ‚Äì Wallach IX", kind:"planet", radius: 5.0, orbitR: 110, orbitSpeed: 0.00085, rotSpeed: 0.045, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 24 },
            { name:"Wallach ‚Äì Panope", kind:"planet", radius: 4.2, orbitR: 165, orbitSpeed: 0.00062, rotSpeed: 0.055, rocky:true, biomePreset:"caladan", seaLevel:-0.02, ocean:true, farSegments: 22 },
            { name:"Wallach ‚Äì Lankiveil", kind:"planet", radius: 4.6, orbitR: 235, orbitSpeed: 0.00048, rotSpeed: 0.040, rocky:true, biomePreset:"ix", seaLevel:0.015, ocean:false, farSegments: 22 },
          ],
        },
        {
          id: "Tleilax",
          speedScale: 6,
          pos: new BABYLON.Vector3(1120, -80, 1280),
          star: { name: "Star Tleilax", kind:"sun", radius: 26, emissive: new BABYLON.Color3(1.0,0.70,0.55) },
          planets: [
            { name:"Tleilax ‚Äì Tleilax", kind:"planet", radius: 4.9, orbitR: 120, orbitSpeed: 0.00075, rotSpeed: 0.060, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 24 },
            { name:"Tleilax ‚Äì Bandalong", kind:"planet", radius: 3.7, orbitR: 175, orbitSpeed: 0.00056, rotSpeed: 0.070, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Tleilax ‚Äì Sietch", kind:"planet", radius: 3.0, orbitR: 245, orbitSpeed: 0.00042, rotSpeed: 0.085, rocky:true, biomePreset:"arrakis", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Ginaz",
          speedScale: 6,
          pos: new BABYLON.Vector3(-1250, 90, 1320),
          star: { name: "Star Ginaz", kind:"sun", radius: 27, emissive: new BABYLON.Color3(0.90,0.92,1.0) },
          planets: [
            { name:"Ginaz ‚Äì Ginaz", kind:"planet", radius: 4.6, orbitR: 115, orbitSpeed: 0.00082, rotSpeed: 0.055, rocky:true, biomePreset:"kaitain", seaLevel:-0.015, ocean:true, farSegments: 22 },
            { name:"Ginaz ‚Äì Naraj", kind:"planet", radius: 3.9, orbitR: 175, orbitSpeed: 0.00060, rotSpeed: 0.070, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Ginaz ‚Äì Wedlock", kind:"planet", radius: 3.4, orbitR: 250, orbitSpeed: 0.00045, rotSpeed: 0.080, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Grumman",
          speedScale: 6,
          pos: new BABYLON.Vector3(1850, -120, 250),
          star: { name: "Star Grumman", kind:"sun", radius: 29, emissive: new BABYLON.Color3(1.0,0.94,0.80) },
          planets: [
            { name:"Grumman ‚Äì Grumman", kind:"planet", radius: 4.8, orbitR: 120, orbitSpeed: 0.00080, rotSpeed: 0.050, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 22 },
            { name:"Grumman ‚Äì Kralizec", kind:"planet", radius: 4.1, orbitR: 190, orbitSpeed: 0.00058, rotSpeed: 0.065, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Grumman ‚Äì Selusa", kind:"planet", radius: 3.3, orbitR: 265, orbitSpeed: 0.00042, rotSpeed: 0.090, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Buzzell",
          speedScale: 6,
          pos: new BABYLON.Vector3(-2100, -60, 250),
          star: { name: "Star Buzzell", kind:"sun", radius: 25, emissive: new BABYLON.Color3(0.95,0.78,0.55) },
          planets: [
            { name:"Buzzell ‚Äì Buzzell", kind:"planet", radius: 4.0, orbitR: 105, orbitSpeed: 0.00092, rotSpeed: 0.060, rocky:true, biomePreset:"arrakis", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Buzzell ‚Äì Harmonthep", kind:"planet", radius: 5.4, orbitR: 175, orbitSpeed: 0.00060, rotSpeed: 0.040, rocky:true, biomePreset:"kaitain", seaLevel:-0.02, ocean:true, farSegments: 24 },
            { name:"Buzzell ‚Äì Lampadas", kind:"planet", radius: 3.6, orbitR: 255, orbitSpeed: 0.00045, rotSpeed: 0.080, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Junction",
          speedScale: 6,
          pos: new BABYLON.Vector3(0, 160, 2100),
          star: { name: "Star Junction", kind:"sun", radius: 24, emissive: new BABYLON.Color3(0.85,0.90,1.0) },
          planets: [
            { name:"Junction ‚Äì Junction", kind:"planet", radius: 4.2, orbitR: 120, orbitSpeed: 0.00088, rotSpeed: 0.055, rocky:true, biomePreset:"ix", seaLevel:0.015, ocean:false, farSegments: 22 },
            { name:"Junction ‚Äì Poritrin", kind:"planet", radius: 5.8, orbitR: 195, orbitSpeed: 0.00058, rotSpeed: 0.040, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 24 },
            { name:"Junction ‚Äì Ecaz Minor", kind:"planet", radius: 3.0, orbitR: 275, orbitSpeed: 0.00042, rotSpeed: 0.085, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 18 },
          ],
        },
        {
          id: "Lampadas",
          speedScale: 6,
          pos: new BABYLON.Vector3(2200, 60, -1350),
          star: { name: "Star Lampadas", kind:"sun", radius: 28, emissive: new BABYLON.Color3(1.0,0.82,0.60) },
          planets: [
            { name:"Lampadas ‚Äì Lampadas", kind:"planet", radius: 4.9, orbitR: 125, orbitSpeed: 0.00082, rotSpeed: 0.050, rocky:true, biomePreset:"kaitain", seaLevel:-0.015, ocean:true, farSegments: 22 },
            { name:"Lampadas ‚Äì Rossak", kind:"planet", radius: 4.4, orbitR: 190, orbitSpeed: 0.00058, rotSpeed: 0.060, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Lampadas ‚Äì Bela", kind:"planet", radius: 3.5, orbitR: 270, orbitSpeed: 0.00042, rotSpeed: 0.080, rocky:true, biomePreset:"salusa", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Poritrin",
          speedScale: 6,
          pos: new BABYLON.Vector3(-2300, 120, -1750),
          star: { name: "Star Poritrin", kind:"sun", radius: 26, emissive: new BABYLON.Color3(0.95,0.88,0.70) },
          planets: [
            { name:"Poritrin ‚Äì Poritrin", kind:"planet", radius: 5.6, orbitR: 130, orbitSpeed: 0.00076, rotSpeed: 0.040, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 24 },
            { name:"Poritrin ‚Äì Grumman Minor", kind:"planet", radius: 3.6, orbitR: 205, orbitSpeed: 0.00054, rotSpeed: 0.070, rocky:true, biomePreset:"kaitain", seaLevel:-0.01, ocean:true, farSegments: 18 },
            { name:"Poritrin ‚Äì Tleilax Outpost", kind:"planet", radius: 3.1, orbitR: 280, orbitSpeed: 0.00040, rotSpeed: 0.085, rocky:true, biomePreset:"giedi", seaLevel:0.02, ocean:false, farSegments: 18 },
          ],
        },
        {
          id: "Naraj",
          speedScale: 6,
          pos: new BABYLON.Vector3(2550, -80, 1750),
          star: { name: "Star Naraj", kind:"sun", radius: 24, emissive: new BABYLON.Color3(0.88,0.95,1.0) },
          planets: [
            { name:"Naraj ‚Äì Naraj", kind:"planet", radius: 4.1, orbitR: 110, orbitSpeed: 0.00090, rotSpeed: 0.060, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 20 },
            { name:"Naraj ‚Äì Ixian Forge", kind:"planet", radius: 3.8, orbitR: 170, orbitSpeed: 0.00062, rotSpeed: 0.070, rocky:true, biomePreset:"ix", seaLevel:0.02, ocean:false, farSegments: 18 },
            { name:"Naraj ‚Äì Caladan Drift", kind:"planet", radius: 5.0, orbitR: 240, orbitSpeed: 0.00045, rotSpeed: 0.040, rocky:true, biomePreset:"caladan", seaLevel:-0.03, ocean:true, farSegments: 22 },
          ],
        },
      
      ];


      // Create meshes
      const bodies = new Map(); // name => body
      const orbitNodes = new Map(); // name => node rotated around sun
      const moonOrbitNodes = new Map(); // moon around parent
      let sunMesh = null; // set when Canopus is created via createStarSystem(coreSystem)
      let halo = null; // core-system halo mesh (created in createStarSystem for Canopus)

      // Ensure sunLight follows sun (in case you move it later)
      if (sunMesh) sunLight.position.copyFrom(sunMesh.position);
      // GUI labels (optional)
      const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ui", true, scn);
      function createLabel(text, mesh) {
        const rect = new BABYLON.GUI.Rectangle("lbl_" + text);
        rect.background = "rgba(0,0,0,0.35)";
        rect.thickness = 1;
        rect.color = "rgba(255,255,255,0.25)";
        rect.cornerRadius = 8;
        rect.height = "22px";
        rect.width = "120px";
        rect.isHitTestVisible = false;

        const tb = new BABYLON.GUI.TextBlock();
        tb.text = text;
        tb.color = "#fff";
        tb.fontSize = 12;
        rect.addControl(tb);

        gui.addControl(rect);
        rect.linkWithMesh(mesh);
        rect.linkOffsetY = -20;
        return rect;
      }

              // ============================================================
// Labels: registro + visibilidad (throttle)
// - Estrellas siempre visibles
// - Planetas y lunas: solo los cercanos (por ranking + distancia)
// - Permite apagar/encender desde UI
// ============================================================
const labelsByName = new Map(); // name -> { rect, kind, mesh }
let showLabels = true;

function registerLabel(name, kind, mesh) {
  if (!mesh) return null;
  let meta = labelsByName.get(name);
  if (!meta) {
    const rect = createLabel(name, mesh);
    meta = { rect, kind, mesh };
    labelsByName.set(name, meta);
  } else {
    meta.kind = kind || meta.kind;
    meta.mesh = mesh || meta.mesh;
  }
  return meta.rect;
}

const LABEL_NEAREST_BODIES = 10;   // cu√°ntos planetas/lunas mostrar como "cercanos"
const LABEL_MAX_DIST = 1200;       // adem√°s, muestra cuerpos dentro de esta distancia
const LABEL_UPDATE_MS = 220;       // throttle del c√°lculo

function setAllLabelsVisible(v) {
  for (const { rect } of labelsByName.values()) rect.isVisible = !!v;
}


function updateLabelVisibility(force = false) {
  if (!showLabels) { setAllLabelsVisible(false); return; }
  const cam = scn.activeCamera;
  if (!cam) return;

  const now = performance.now();
  if (!force && scn._lblTick && (now - scn._lblTick) < LABEL_UPDATE_MS) return;
  scn._lblTick = now;

  const camPos = cam.position;
  const maxD2 = LABEL_MAX_DIST * LABEL_MAX_DIST;
  const planes = cam.getFrustumPlanes();

  const tb = getTargetBody();
  const targetName = tb ? tb.def.name : null;
  const targetSystemId = tb && tb.def ? tb.def._systemId : null;
  const activeSys = _activeSystemId || computeActiveSystemId();

  // Reset
  for (const [n, b] of bodies.entries()) {
    if (b.label) b.label.isVisible = false;
  }

  function isOnScreen(mesh) {
    try { return mesh && mesh.isInFrustum(planes); } catch(e) { return false; }
  }

  // 1) Estrellas: prioridad a sistema activo + sistema del objetivo
  for (const [n, b] of bodies.entries()) {
    if (b.def.type !== "star") continue;
    const d2 = BABYLON.Vector3.DistanceSquared(camPos, b.farMesh.getAbsolutePosition());
    const on = isOnScreen(b.farMesh);
    const sysId = b.def._systemId || b.def.name;

    const show =
      (sysId === activeSys) ||
      (targetSystemId && sysId === targetSystemId) ||
      (on && d2 < maxD2);

    if (b.label) b.label.isVisible = show;
  }

  // 2) Candidatos (planetas + lunas) con scoring
  const candidates = [];
  for (const [n, b] of bodies.entries()) {
    if (!b.label) continue;
    if (b.def.type === "star") continue;

    const pos = b.farMesh.getAbsolutePosition();
    const d2 = BABYLON.Vector3.DistanceSquared(camPos, pos);
    const on = isOnScreen(b.farMesh);
    const sysId = b.def._systemId || null;

    // Lunas: solo cerca del planeta padre, o si son el objetivo
    if (b.def.type === "moon") {
      const parent = bodies.get(b.def.parent);
      if (!parent) continue;

      const parentPos = parent.farMesh.getAbsolutePosition();
      const parentDist = BABYLON.Vector3.Distance(camPos, parentPos);
      const closeToParent = parentDist < Math.max(parent.def.radius * 12.0, 220);

      const allowed = closeToParent || (targetName === b.def.name) || (tb && tb.def && tb.def.name === parent.def.name);
      if (!allowed) continue;

      // adem√°s: que est√© razonablemente visible
      if (!on && sysId !== activeSys && targetName !== b.def.name) continue;
      if (d2 > maxD2) continue;

      let score = d2 * (closeToParent ? 0.55 : 1.15);
      if (sysId === activeSys) score *= 0.70;
      if (on) score *= 0.70;
      if (targetName === b.def.name) score = -1;

      candidates.push({ b, score });
      continue;
    }

    // Planetas: prioridad al sistema activo + lo que est√° en pantalla
    if (b.def.type === "planet") {
      const eligible =
        (sysId === activeSys && (d2 < maxD2 * 4 || on)) ||
        (on && d2 < maxD2) ||
        (targetName === b.def.name);

      if (!eligible) continue;

      let score = d2;
      if (sysId === activeSys) score *= 0.60;
      if (on) score *= 0.70;
      if (targetName === b.def.name) score = -1;

      candidates.push({ b, score });
    }
  }

  candidates.sort((a, b) => a.score - b.score);

  // 3) Enciende hasta N (sin perder objetivo)
  let shown = 0;
  const max = LABEL_MAX_ONSCREEN;

  for (const c of candidates) {
    if (!c.b.label) continue;
    if (c.b.label.isVisible) continue; // ya visible (p.ej. estrella)
    if (shown >= max) break;
    c.b.label.isVisible = true;
    shown++;
  }

  // 4) Asegura objetivo visible siempre (si existe)
  if (tb && tb.label) tb.label.isVisible = true;
}

// UI hook
if (ui.toggleLabels) {
  showLabels = !!ui.toggleLabels.checked;
  if (ui.labelsPill) ui.labelsPill.textContent = showLabels ? "ON" : "OFF";
  ui.toggleLabels.addEventListener("change", () => {
    showLabels = !!ui.toggleLabels.checked;
    if (ui.labelsPill) ui.labelsPill.textContent = showLabels ? "ON" : "OFF";
    updateLabelVisibility(true);
  });
}

      // Fill selector + labels
      ui.planetSelect.innerHTML = "";
      
      // ====================================================================
      // 3b) Create extra star systems (FAR-only por defecto)
      // ====================================================================
      
const systemRoots = new Map(); // systemId -> root node
const systemLights = []; // {light, root, range}

// Runtime por sistema: sombras y lista de meshes (para activar/desactivar barato)
const systemRuntime = new Map(); // systemId -> { root, light, shadowGen, meshes:Set<Mesh>, oceans:Set<Mesh> }
function getSystemRuntime(id) {
  let rt = systemRuntime.get(id);
  if (!rt) {
    rt = { root: null, light: null, shadowGen: null, meshes: new Set(), oceans: new Set() };
    systemRuntime.set(id, rt);
  }
  return rt;
}
function getSystemShadowGen(systemId) {
  if (!systemId || systemId === "Canopus") return coreShadowGen;
  const rt = systemRuntime.get(systemId);
  return rt ? rt.shadowGen : null;
}
      function createStarSystem(sys, opts = {}) {
        const isCore = !!opts.core || sys.id === "Canopus";
        const root = new BABYLON.TransformNode("sys_" + sys.id, scn);
        root.position.copyFrom(sys.pos || BABYLON.Vector3.Zero());
        systemRoots.set(sys.id, root);

        // Star mesh
        const starSeg = isCore ? 64 : 48;
        const star = BABYLON.MeshBuilder.CreateSphere(sys.star.name, { diameter: sys.star.radius * 2, segments: starSeg }, scn);
        star.parent = root;
        star.position.set(0,0,0);
        star.isPickable = false;

        // Star material
        if (isCore) {
          // Canopus: look procedural + halo (como antes)
          const sunMat = new BABYLON.PBRMaterial("sunMat", scn);
          sunMat.unlit = true;
          sunMat.emissiveColor = new BABYLON.Color3(1, 0.6, 0.1);

          const sunNoise = new BABYLON.NoiseProceduralTexture("sunNoise", 512, scn);
          sunNoise.animationSpeedFactor = 0.8;
          sunNoise.brightness = 0.5;
          sunMat.emissiveTexture = sunNoise;
          star.material = sunMat;

          halo = BABYLON.MeshBuilder.CreatePlane("Canopus_Halo", { size: sys.star.radius * 3.6 }, scn);
          halo.parent = star;
          halo.isPickable = false;
          halo.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

          const haloTex = new BABYLON.DynamicTexture("haloTex", { width: 512, height: 512 }, scn, false);
          const ctx = haloTex.getContext();
          const g = ctx.createRadialGradient(256,256,0,256,256,256);
          g.addColorStop(0.00, "rgba(255,210,140,0.55)");
          g.addColorStop(0.25, "rgba(255,165, 70,0.22)");
          g.addColorStop(0.55, "rgba(255,120, 40,0.10)");
          g.addColorStop(1.00, "rgba(0,0,0,0.00)");
          ctx.fillStyle = g; ctx.fillRect(0,0,512,512);
          haloTex.update();

          const haloMat = new BABYLON.StandardMaterial("haloMat", scn);
          haloMat.diffuseTexture = haloTex;
          haloMat.emissiveTexture = haloTex;
          haloMat.opacityTexture = haloTex;
          haloMat.disableLighting = true;
          haloMat.backFaceCulling = false;
          haloMat.alpha = 0.75;
          haloMat.alphaMode = BABYLON.Engine.ALPHA_ADD;
          haloMat.needDepthPrePass = true;
          halo.material = haloMat;

          // Attach main light to Canopus
          sunMesh = star;
          mainLitMeshes.push(star);
          sunLight.parent = star;
          sunLight.position.set(0,0,0);
        } else {
          const starMat = new BABYLON.StandardMaterial(sys.star.name + "_mat", scn);
          starMat.emissiveColor = sys.star.emissive || new BABYLON.Color3(1,0.9,0.7);
          starMat.diffuseColor = BABYLON.Color3.Black();
          starMat.specularColor = BABYLON.Color3.Black();
          starMat.disableLighting = true;
          star.material = starMat;
        }

        bodies.set(sys.star.name, {
          def: sys.star,
          farMesh: star,
          atmo: null,
          ring: null,
          orbitAngle: 0,
          orbitNode: null,
          proc: null,
        });

        
// Local/system light (extras) ‚Äî Canopus usa sunLight
let local = null;
const rt = getSystemRuntime(sys.id);
rt.root = root;

// Tag systemId en defs (para labels/near/shadows)
sys.star._systemId = sys.id;

if (!isCore) {
  local = new BABYLON.PointLight(sys.id + "_light", new BABYLON.Vector3(0,0,0), scn);
  local.parent = star;
  local.intensity = (sys.star.lightIntensity != null) ? sys.star.lightIntensity : 1.85;
  local.range = (sys.star.lightRange != null) ? sys.star.lightRange : 900;
  local.includedOnlyMeshes = [];
  local.setEnabled(true);

  // ShadowGen por sistema (se activar√° solo cuando este sistema sea el activo)
  const sg = new BABYLON.ShadowGenerator(1024, local);
  sg.usePoissonSampling = true;
  sg.bias = 0.00028;
  sg.normalBias = 0.012;
  sg.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
  sg.getShadowMap().renderList = [];

  rt.light = local;
  rt.shadowGen = sg;

  systemLights.push({ light: local, root, range: local.range });
} else {
  rt.light = sunLight;
  rt.shadowGen = coreShadowGen;
}

        
function linkToLight(mesh, ocean) {
  if (!mesh) return;
  // Registrar para toggles por sistema
  rt.meshes.add(mesh);
  if (ocean) rt.oceans.add(ocean);

  if (isCore) {
    mainLitMeshes.push(mesh);
    if (ocean) mainLitMeshes.push(ocean);
  } else if (local) {
    local.includedOnlyMeshes.push(mesh);
    if (ocean) local.includedOnlyMeshes.push(ocean);
  }
}

function applyShadows(mesh, ocean) {
  if (!mesh) return;

  // Prepara lista de casters, pero NO renderiza sombras salvo sistema activo
  const sg = isCore ? coreShadowGen : (rt.shadowGen || null);
  if (sg) {
    sg.addShadowCaster(mesh);
  }

  // Por defecto: apagado. Se activar√° s√≥lo en el sistema activo.
  mesh.receiveShadows = false;
  if (ocean) ocean.receiveShadows = false;
}

function createRings(def, planetMesh) {
          if (!def || !planetMesh) return null;
          if (!(def.rings && def.ringTex)) return null;

          const ring = BABYLON.MeshBuilder.CreateDisc(def.name+"_Rings", { radius: def.radius * 3.3, tessellation: 128 }, scn);
          ring.parent = planetMesh;
          ring.rotation.x = Math.PI / 2;
          ring.isPickable = false;

          const ringMat = new BABYLON.StandardMaterial(def.name+"_RingMat", scn);
          ringMat.backFaceCulling = false;
          ringMat.disableLighting = true;
          ringMat.emissiveColor = new BABYLON.Color3(0.9,0.85,0.75).scale(0.75);
          ringMat.alpha = 0.95;

          const rt = loadTextureOrNull(scn, def.ringTex, { hasAlpha: true });
          if (rt) {
            ringMat.diffuseTexture = rt;
            ringMat.opacityTexture = rt;
            ringMat.useAlphaFromDiffuseTexture = true;
            ringMat.alphaMode = BABYLON.Engine.ALPHA_COMBINE;
          }
          ring.material = ringMat;
          return ring;
        }

        // Planets
        for (const pDef of (sys.planets || [])) {
          pDef._systemId = sys.id;
          pDef._sysSpeed = sys.speedScale || 1;

          const orbitNode = new BABYLON.TransformNode(pDef.name + "_orbit", scn);
          orbitNode.parent = root;
          orbitNode.position.set(0,0,0);
          orbitNodes.set(pDef.name, orbitNode);

          const created = createLowPolyFarPlanet(scn, pDef, orbitNode);
          const mesh = created.land;
          const ocean = created.ocean;

          mesh.isPickable = false;
          if (ocean) ocean.isPickable = false;

          applyShadows(mesh, ocean);
          linkToLight(mesh, ocean);

          // rings (core only, por ahora)
          const ring = isCore ? createRings(pDef, mesh) : null;

          bodies.set(pDef.name, {
            def: pDef,
            farMesh: mesh,
            atmo: null,
            ring,
            orbitAngle: Math.random() * Math.PI * 2,
            orbitNode,
            proc: null,
          });

          // Congela materiales en far para sistemas lejanos
          if (!isCore) {
            if (mesh.material && mesh.material.freeze) mesh.material.freeze();
            if (ocean && ocean.material && ocean.material.freeze) ocean.material.freeze();
          }
        }

        // Moons (solo si sys.moons existe; coreSystem las usa)
        for (const mDef of (sys.moons || [])) {
          if (!mDef.parent) continue;
          mDef._systemId = sys.id;
          mDef._sysSpeed = sys.speedScale || 1;

          const parentBody = bodies.get(mDef.parent);
          if (!parentBody) {
            console.warn("[moon] parent no encontrado:", mDef.parent, "para", mDef.name);
            continue;
          }

          const moonOrbitNode = new BABYLON.TransformNode(mDef.name + "_moonOrbit", scn);
          moonOrbitNode.parent = parentBody.farMesh;
          moonOrbitNode.position.set(0,0,0);
          moonOrbitNodes.set(mDef.name, moonOrbitNode);

          const created = createLowPolyFarPlanet(scn, mDef, moonOrbitNode);
          const mesh = created.land;
          const ocean = created.ocean;

          mesh.isPickable = false;
          if (ocean) ocean.isPickable = false;

          applyShadows(mesh, ocean);
          linkToLight(mesh, ocean);

          bodies.set(mDef.name, {
            def: mDef,
            farMesh: mesh,
            atmo: null,
            ring: null,
            orbitAngle: Math.random() * Math.PI * 2,
            orbitNode: moonOrbitNode,
            proc: null,
          });

          if (!isCore) {
            if (mesh.material && mesh.material.freeze) mesh.material.freeze();
            if (ocean && ocean.material && ocean.material.freeze) ocean.material.freeze();
          }
        }

        // Congela star solo en sistemas lejanos (Canopus tiene textura animada)
        if (!isCore) {
          star.freezeWorldMatrix();
          star.doNotSyncBoundingInfo = true;
          if (star.material && star.material.freeze) star.material.freeze();
        }
      }
      for (const sys of extraSystems) {
        createStarSystem(sys, { core: sys.id === "Canopus" });
      }



      // ====================================================================
      // 4) Labels + UI populate (incluye sistemas extra)
      // ====================================================================
      const allDefs = bodyDefs.concat(
        extraSystems
          .filter(s => s.id !== "Canopus")
          .flatMap(s => [s.star, ...(s.planets || []), ...((s.moons) || [])])
      );

	  for (const def of allDefs) {
        const opt = document.createElement("option");
        opt.value = def.name;
        opt.innerText = def.name;
        ui.planetSelect.appendChild(opt);
        const lb = bodies.get(def.name);
        if (lb && lb.farMesh) registerLabel(def.name, def.kind, lb.farMesh);
      }
      ui.planetSelect.value = "Arrakis";
      updateLabelVisibility(true);

      // ====================================================================
      // 5) Modes: orbit / fly / surface
      // ====================================================================
      const mode = { value: "orbit" }; // orbit | fly | surface
      function setMode(m) {
        mode.value = m;
        ui.modePill.textContent = (m === "orbit") ? "√ìrbita" : (m === "fly" ? "Vuelo" : "Superficie");

        // detach all
        try { cameraOrbit.detachControl(canvas); } catch(e){}
        try { cameraFly.detachControl(canvas); } catch(e){}
        try { cameraSurface.detachControl(canvas); } catch(e){}

        if (m === "orbit") {
          // Si volvemos a √ìrbita, soltamos el pointer-lock para no "pelearnos" con la UI.
          if (document.pointerLockElement === canvas) {
            try { document.exitPointerLock?.(); } catch(e) {}
          }
          scn.activeCamera = cameraOrbit;
          cameraOrbit.attachControl(canvas, true);
        } else if (m === "fly") {
          scn.activeCamera = cameraFly;
          cameraFly.attachControl(canvas, true);
        } else {
          scn.activeCamera = cameraSurface;
          cameraSurface.attachControl(canvas, true);
        }
      }

      // Pointer lock (como index-old): click en el canvas para capturar rat√≥n en Vuelo/Superficie
      scn.onPointerDown = () => {
        if (mode.value !== "fly" && mode.value !== "surface") return;
        if (document.pointerLockElement !== canvas) {
          canvas.requestPointerLock?.();
        }
      };

      // (hook listo por si quieres hacer UI cuando se suelta)
      document.addEventListener("pointerlockchange", () => {});


      ui.camOrbitBtn.addEventListener("click", () => setMode("orbit"));
      ui.camFlyBtn.addEventListener("click", () => setMode("fly"));
      ui.camSurfaceBtn.addEventListener("click", () => setMode("surface"));

      ui.speedRange.addEventListener("input", (e) => {
        timeScale = parseFloat(e.target.value);
        ui.speedVal.textContent = timeScale.toFixed(1) + "x";
      });
      ui.speedVal.textContent = timeScale.toFixed(1) + "x";

      // ====================================================================
      // 6) Approach: teleport camera to target (fly/surface)
      // ====================================================================
      function getTargetBody() {
        const name = ui.planetSelect.value;
        return bodies.get(name);
      }


// ==========================
// Sistema activo (para sombras/labels)
// ==========================
let _activeSystemId = null;

function computeActiveSystemId() {
  const cam = scn.activeCamera;
  const tb = getTargetBody();

  // Prioridad: modo superficie => sistema del objetivo
  if (mode === "surface" && tb && tb.def && tb.def._systemId) return tb.def._systemId;

  // Si est√°s cerca del root de un sistema, ese manda
  if (cam) {
    const camPos = cam.position;
    let bestId = null;
    let bestD2 = Infinity;
    for (const [sid, root] of systemRoots.entries()) {
      const p = root.getAbsolutePosition();
      const d2 = BABYLON.Vector3.DistanceSquared(camPos, p);
      if (d2 < bestD2) { bestD2 = d2; bestId = sid; }
    }
    // umbral razonable para "estoy explorando este sistema"
    if (bestId && bestD2 < (1100 * 1100)) return bestId;
  }

  // Fallback: sistema del objetivo (si hay)
  if (tb && tb.def && tb.def._systemId) return tb.def._systemId;

  return "Canopus";
}

function updateActiveSystemShadows() {
  const sid = computeActiveSystemId();
  if (sid === _activeSystemId) {
    // Aun as√≠, necesitamos sincronizar sombras de procedural cuando se enciende/apaga
    for (const [n, b] of bodies.entries()) {
      if (b.proc) {
        const should = (b.def._systemId === sid) && b.proc.root && b.proc.root.isEnabled();
        b.proc.setShadowsEnabled(should);
      }
    }
    return;
  }
  _activeSystemId = sid;

  // 1) Desactiva/activa por sistema (shadow map + receiveShadows)
  for (const [id, rt] of systemRuntime.entries()) {
    const sg = rt.shadowGen;
    if (!sg) continue;

    const on = (id === sid);
    const sm = sg.getShadowMap();

    if (on) {
      sm.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME;
      sm.renderList = Array.from(rt.meshes);
    } else {
      sm.refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
      sm.renderList = [];
    }

    // Recepci√≥n de sombras: s√≥lo en sistema activo
    for (const m of rt.meshes) m.receiveShadows = on;
    for (const o of rt.oceans) o.receiveShadows = on;
  }

  // 2) Procedural: s√≥lo si est√° habilitado Y sistema activo
  for (const [n, b] of bodies.entries()) {
    if (!b.proc) continue;
    const should = (b.def._systemId === sid) && b.proc.root && b.proc.root.isEnabled();
    b.proc.setShadowsEnabled(should);
  }
}

      function approachTarget(preferredMode = null) {
        const b = getTargetBody();
        if (!b) return;

        const targetPos = b.farMesh.getAbsolutePosition().clone();
        const r = b.def.radius;

        if (preferredMode) setMode(preferredMode);

        // place camera near surface
        const dir = new BABYLON.Vector3(0.2, 0.25, -1).normalize();
        const camPos = targetPos.add(dir.scale(r * 4.2));

        if (mode.value === "orbit") {
          cameraOrbit.setTarget(targetPos);
          cameraOrbit.radius = Math.max(8, r * 6);
        } else if (mode.value === "fly") {
          cameraFly.position.copyFrom(camPos);
          cameraFly.setTarget(targetPos);
        } else {
          // surface mode: place player root above ground
          const up = dir.scale(-1).normalize();
          playerRoot.position.copyFrom(targetPos.add(up.scale(r * 1.15)));
          cameraSurface.setTarget(targetPos);

          // reset player orientation
          playerRoot.rotationQuaternion = BABYLON.Quaternion.Identity();
          cameraSurface.rotation.set(0,0,0);

          // enable procedural planet for this target if rocky
          ensureProceduralForBody(b);
          enableProceduralOnly(b.def.name);
        }
      }

      ui.approachBtn.addEventListener("click", () => {
        // If currently orbit, go fly for approach (nice default)
        if (mode.value === "orbit") setMode("fly");
        approachTarget(null);
      });

      // ====================================================================
      // 7) Procedural planet activation (Surface mode)
      // ====================================================================
      function ensureProceduralForBody(body) {
        if (!body.def.rocky) return;
        if (body.proc) return;

        const proc = new ProceduralPlanet(scn, body.def.name, body.def.radius, getSystemShadowGen(body.def._systemId));

        // Preset desde bodyDefs
        if (body.def.biomePreset) proc.biomePreset = body.def.biomePreset;
        if (body.def.terrainScale != null) proc.terrainScale = body.def.terrainScale;
        if (body.def.seaLevel != null) proc.seaLevel = body.def.seaLevel;
        if (body.def.noiseFrequency != null) proc.noiseFrequency = body.def.noiseFrequency;
        if (body.def.noiseOctaves != null) proc.noiseOctaves = body.def.noiseOctaves;
// Close-up tuning (por planeta; fallback a defaults)
const near = body.def.near || {};
proc.chunkResolution = (near.chunkResolution != null) ? near.chunkResolution : 12;
proc.maxDetailLevel  = (near.maxDetailLevel  != null) ? near.maxDetailLevel  : 5;
proc._maxSplitsPerFrame = (near.maxSplitsPerFrame != null) ? near.maxSplitsPerFrame : 6;
proc.lodDistanceMul = (near.lodDistanceMul != null) ? near.lodDistanceMul : 5.5;

        // Atmosfera desactivada por ahora

        body.proc = proc;
      }

      function enableProceduralOnly(name) {
        for (const [n, b] of bodies.entries()) {
          if (b.proc) b.proc.setEnabled(false);
          // also hide far mesh for active rocky planet to avoid z-fighting when near surface
          if (b.def.rocky) b.farMesh.setEnabled(true);
        }

        const b = bodies.get(name);
        if (!b || !b.proc) return;

        // show proc, hide far sphere (and its atmo) for this planet
        b.proc.setEnabled(true);
        b.farMesh.setEnabled(false);
      }

      // When switching to surface mode, approach and enable LOD for selected planet
      ui.camSurfaceBtn.addEventListener("click", () => {
        // ensure procedural is prepared
        const b = getTargetBody();
        if (b && b.def.rocky) ensureProceduralForBody(b);
        setMode("surface");
        approachTarget("surface");
      });

      // If user changes planet while in surface mode, switch planet
      ui.planetSelect.addEventListener("change", () => {
        if (mode.value === "surface") {
          const b = getTargetBody();
          if (b && b.def.rocky) ensureProceduralForBody(b);
          approachTarget("surface");
        }
      });

      // ====================================================================
      // 8) Surface movement + gravity (C-ready)
      // ====================================================================
      const input = {
        forward:false, back:false, left:false, right:false,
        sprint:false, jump:false,
      };

      window.addEventListener("keydown", (e) => {
        if (e.code === "KeyW") input.forward = true;
        if (e.code === "KeyS") input.back = true;
        if (e.code === "KeyA") input.left = true;
        if (e.code === "KeyD") input.right = true;
        if (e.code === "ShiftLeft" || e.code === "ShiftRight") input.sprint = true;
        if (e.code === "Space") input.jump = true;
      });
      window.addEventListener("keyup", (e) => {
        if (e.code === "KeyW") input.forward = false;
        if (e.code === "KeyS") input.back = false;
        if (e.code === "KeyA") input.left = false;
        if (e.code === "KeyD") input.right = false;
        if (e.code === "ShiftLeft" || e.code === "ShiftRight") input.sprint = false;
        if (e.code === "Space") input.jump = false;
      });

      let playerVel = new BABYLON.Vector3(0,0,0);
      let onGround = false;

      function surfaceStep(dt) {
        const b = getTargetBody();
        if (!b) return;

        // center of planet in world
        const center = b.farMesh.getAbsolutePosition().clone();
        // if procedural enabled, its root matches farMesh position
        if (b.proc && b.proc.enabled) center.copyFrom(b.proc.root.position);

        const pos = playerRoot.position.clone();
        const toCenter = center.subtract(pos);
        const dist = toCenter.length();
        const down = toCenter.normalize(); // gravity direction
        const up = down.scale(-1);

        // Orient playerRoot so its "up" matches local up (smooth)
        // We'll build a basis where Y=up, Z=forward projected, X=right
        const forwardWorld = cameraSurface.getForwardRay(1).direction;
        const forwardOnTangent = forwardWorld.subtract(up.scale(BABYLON.Vector3.Dot(forwardWorld, up)));
        const fLen = forwardOnTangent.length();
        const forward = (fLen > 1e-4) ? forwardOnTangent.normalize() : BABYLON.Vector3.Cross(new BABYLON.Vector3(1,0,0), up).normalize();
        const right = BABYLON.Vector3.Cross(up, forward).normalize();

        // rotation quaternion from basis
        // Babylon CDN: algunas versiones no traen Matrix.FromXYZAxes.
        // Construimos la matriz de base (column-major) a mano:
        // X = right, Y = up, Z = forward
        const m = new BABYLON.Matrix();
        const mm = m.m;
        mm[0]  = right.x;  mm[1]  = right.y;  mm[2]  = right.z;  mm[3]  = 0;
        mm[4]  = up.x;     mm[5]  = up.y;     mm[6]  = up.z;     mm[7]  = 0;
        mm[8]  = forward.x;mm[9]  = forward.y;mm[10] = forward.z;mm[11] = 0;
        mm[12] = 0;        mm[13] = 0;        mm[14] = 0;        mm[15] = 1;
        const desiredQ = BABYLON.Quaternion.FromRotationMatrix(m);
        playerRoot.rotationQuaternion = BABYLON.Quaternion.Slerp(playerRoot.rotationQuaternion, desiredQ, 0.18);

        // Raycast to ground against procedural chunks if available, else against far mesh
        const rayLen = Math.max(60, b.def.radius * 6);
        const ray = new BABYLON.Ray(pos, down, rayLen);

        let hit = null;
        if (b.proc && b.proc.enabled) {
          hit = scn.pickWithRay(ray, (mesh) => {
            return mesh && mesh.name.startsWith("chunk_") && mesh.parent === b.proc.root;
          });
        } else {
          hit = scn.pickWithRay(ray, (mesh) => mesh === b.farMesh);
        }

        onGround = false;
        const eyeHeight = 2.0;

        if (hit && hit.hit && hit.pickedPoint) {
          const dGround = BABYLON.Vector3.Distance(pos, hit.pickedPoint);
          if (dGround < eyeHeight + 0.8) {
            onGround = true;
            const targetPos = hit.pickedPoint.add(up.scale(eyeHeight));
            // smooth snap to avoid LOD popping
            playerRoot.position = BABYLON.Vector3.Lerp(playerRoot.position, targetPos, 0.25);
            // damp gravity velocity on ground
            playerVel = playerVel.scale(0.75);
          }
        }

        // Gravity
        const g = 9.8;
        if (!onGround) {
          playerVel.addInPlace(down.scale(g * dt));
        } else {
          // Jump
          if (input.jump) {
            playerVel.addInPlace(up.scale(7.0));
            onGround = false;
          }
        }

        // Tangential movement
        const baseSpeed = input.sprint ? 11.0 : 6.0;
        let move = new BABYLON.Vector3(0,0,0);
        if (input.forward) move.addInPlace(forward);
        if (input.back) move.addInPlace(forward.scale(-1));
        if (input.left) move.addInPlace(right.scale(-1));
        if (input.right) move.addInPlace(right);

        if (move.length() > 1e-4) {
          move = move.normalize().scale(baseSpeed * dt);
          playerRoot.position.addInPlace(move);
        }

        // Apply gravity velocity
        playerRoot.position.addInPlace(playerVel.scale(dt));
      }

      // ====================================================================
      // 9) Orbit simulation (simple, for visuals)
      // ====================================================================
      function updateOrbits(dt) {
        if (timeScale <= 0) return;

        // Planets around sun
        for (const [name, b] of bodies.entries()) {
          if (b.def.kind !== "planet") continue;

          const sysS = b.def._sysSpeed || 1;
          b.orbitAngle += (b.def.orbitSpeed * sysS) * dt * timeScale;
          b.orbitNode.rotation.y = b.orbitAngle;

          // spin
          b.farMesh.rotation.y += (b.def.rotSpeed || 0.01) * dt * timeScale;
          if (b.ring) b.ring.rotation.z += 0.3 * dt * timeScale;

          // if procedural exists, keep it aligned with far mesh position and rotation
          if (b.proc) {
            b.proc.root.position.copyFrom(b.farMesh.getAbsolutePosition());
            b.proc.root.rotationQuaternion = b.farMesh.rotationQuaternion ? b.farMesh.rotationQuaternion.clone() : BABYLON.Quaternion.FromEulerAngles(0, b.farMesh.rotation.y, 0);
          }
        }

        // Moons around their parent planet
        for (const [moonName, moonOrbitNode] of moonOrbitNodes.entries()) {
          const m = bodies.get(moonName);
          if (!m) continue;

          const sysSm = m.def._sysSpeed || 1;
          m.orbitAngle += (m.def.orbitSpeed * sysSm) * dt * timeScale;
          moonOrbitNode.rotation.y = m.orbitAngle;

          // spin
          m.farMesh.rotation.y += m.def.rotSpeed * dt * timeScale;
        }
		
      }

      // ====================================================================
      // 10) 
      // ====================================================================
      // 9b) Camera safety: evitar atravesar planetas (colisi√≥n esf√©rica barata)
      // ====================================================================
      const CAM_COLLISION_PADDING = 0.9; // uds
      function enforcePlanetCollision(cam) {
        if (!cam) return;
        const p = cam.position;

        for (const [, b] of bodies.entries()) {
          if (!b || !b.farMesh || !b.def || !b.def.radius) continue;
          if (b.def.kind !== "planet" && b.def.kind !== "moon") continue;

          const c = b.farMesh.getAbsolutePosition();
          const dx = p.x - c.x, dy = p.y - c.y, dz = p.z - c.z;
          const d2 = dx*dx + dy*dy + dz*dz;

          const minR = (b.def.radius + CAM_COLLISION_PADDING);
          const minR2 = minR * minR;

          // early out si lejos
          if (d2 > (minR2 + 2500)) continue;

          if (d2 < minR2) {
            const d = Math.max(0.0001, Math.sqrt(d2));
            const inv = 1.0 / d;
            cam.position.x = c.x + dx * inv * minR;
            cam.position.y = c.y + dy * inv * minR;
            cam.position.z = c.z + dz * inv * minR;
          }
        }
      }

	  // Render loop logic
      // ====================================================================
      setMode("orbit");

      // initial approach nice view
      approachTarget(null);

      scn.onBeforeRenderObservable.add(() => {
        const dt = engine.getDeltaTime() / 1000;

        // keep sunlight at sun
        if (sunMesh) sunLight.position.copyFrom(sunMesh.position);

        // animate halo (subtle breathing)
        const t = performance.now() * 0.001;
        if (halo) {
          halo.scaling.set(1 + Math.sin(t*0.8)*0.01, 1 + Math.sin(t*0.9)*0.01, 1 + Math.sin(t*0.7)*0.01);
        }

        // orbits always (even in fly), but you can pause by setting timeScale=0
        // updateOrbits(dt); // (desactivado: usamos updateAllOrbitsAbsolute para evitar doble trabajo)

        // surface mode: enable procedural only for selected rocky planet
        let chunks = 0;
        if (mode.value === "surface") {
          const b = getTargetBody();
          if (b && b.def.rocky) {
            ensureProceduralForBody(b);
            enableProceduralOnly(b.def.name);
            if (b.proc) {
              b.proc.update(scn.activeCamera);
              chunks = b.proc.countActiveChunks();
            }
          }
          surfaceStep(dt);

} else {
  // Fly/orbit: procedural SOLO para el objetivo y solo en close-up
  const tb = getTargetBody();
  const camPos = scn.activeCamera ? scn.activeCamera.position : null;

  // Apaga todo primero
  for (const [n, b] of bodies.entries()) {
    if (b.proc) b.proc.setEnabled(false);
    if (b.def.rocky) b.farMesh.setEnabled(true);
  }

  // Enciende solo el target si procede
  if (tb && camPos && tb.def.rocky) {
    ensureProceduralForBody(tb);
    const near = tb.def.near || {};
    const swapMul = (near.swapMul != null) ? near.swapMul : 6.5;

    const planetPos = tb.farMesh.getAbsolutePosition();
    const dist = BABYLON.Vector3.Distance(camPos, planetPos);

    if (dist < tb.def.radius * swapMul) {
      tb.farMesh.setEnabled(false);
      tb.proc.setEnabled(true);
      // sombras: se gestionan por sistema activo (ver updateActiveSystemShadows)
      tb.proc.update(scn.activeCamera);
    }
  }
}

                // Sombras: solo sistema activo
        updateActiveSystemShadows();

        // Labels: throttle (barato)
updateLabelVisibility(false);

// Rendimiento: no actualizar el DOM cada frame
        if (!scn._dbgT || (performance.now() - scn._dbgT) > 350) {
          scn._dbgT = performance.now();
          ui.debugInfo.textContent = `Chunks activos: ${chunks} | FPS: ${engine.getFps().toFixed(0)}`;
        }
      });


	  // Orbit update barato para TODOS usando tiempo absoluto
	  function updateAllOrbitsAbsolute(nowSec) {
	    const t = nowSec * timeScale;
	    
	    for (const [name, b] of bodies.entries()) {
		  if (!b || !b.def) continue;
		  const def = b.def;
	    
		  if (def.kind === "sun") {
		  if (b.farMesh) b.farMesh.rotation.y = t * (def.rotSpeed || 0.02);
		  continue;
		  }
	    
		  if (b.orbitNode) {
		  const ang = t * (def.orbitSpeed || 0.001);
		  b.orbitNode.rotation.y = ang;
		  }
	    
		  if (b.farMesh) {
		  b.farMesh.rotation.y = t * (def.rotSpeed || 0.01);
		  }
	    }
	  }

      return scn;
    };

    const scene = createScene();
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>