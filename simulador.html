<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Simulador de Vuelo con CesiumJS</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
  </style>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
<div id="cesiumContainer"></div>
<div id="hud" style="
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-family: monospace;
  padding: 10px;
  font-size: 14px;
  z-index: 999;
  border-radius: 5px;
">
  <div><strong>Coordenadas:</strong> <span id="coords">---</span></div>
  <div><strong>Altitud:</strong> <span id="alt">---</span> m</div>
  <div><strong>Velocidad:</strong> <span id="spd">---</span> km/h</div>
  <div><strong>Potencia:</strong>  <span id="throttle">---</span>%</div>
  <div><strong>Pitch:</strong> <span id="pitch">---</span>°</div>
  <div><strong>Yaw:</strong> <span id="yaw">---</span>°</div>
  <div><strong>Roll:</strong> <span id="roll">---</span>°</div>
  <div>AoA: <span id="aoa">0.0</span>°</div>
  <div>Roll rate: <span id="rollRate">0.0</span>°/s</div>
  <div>Pitch rate: <span id="pitchRate">0.0</span>°/s</div>
  <div>Yaw rate: <span id="yawRate">0.0</span>°/s</div>
  <div>G-load: <span id="gLoad">0.00 g</span></div>
</div>

  <!-- ─── Controles móviles ───────────────────────────────────────────────────── -->
  <div id="mobileControls" style="position:fixed; bottom:10px; right:10px; display:none; flex-direction:column; align-items:center; gap:10px; z-index:1000;">
    <button id="btnResetGyro" title="Reset Gyro">
      <i class="material-icons">refresh</i>
    </button>
    <button id="btnFullscreen" title="Toggle Fullscreen">
      <i class="material-icons">fullscreen</i>
    </button>
	<input type="range" id="throttleSlider" min="0" max="100" value="0" style="
    position:fixed;
    top:10%;
    right:10px;
    height:80vh;
    writing-mode:bt-lr;
    transform:rotate(270deg);
    display:none;
    z-index:1000;
	"/>
  </div>  

<script>
	(async function main() {
	  // 0. Variables globales de física y cámara:
	  let verticalSpeed = 0;
	  const gravity = 9.8;
	  const liftFactor = 20;
	  const dragFactor = 0.1;
	  const activeSmokeSystems = [];

	  // Ángulos y radio de órbita:
	  let orbitAngles = { yaw: -Math.PI / 2, pitch: 0.2 }; // vista inicial detrás del avión
	  const orbitRadius = 25;
	  let isDragging = false;
	  let dragStart = { x: 0, y: 0 };

		// 1. Crear Cesium Viewer:
		Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiYTQ0YWUyYi0wYjcwLTQ3NDEtYmEzMS1kZDJlYzhkNTkyMzgiLCJpZCI6MzA5MDg4LCJpYXQiOjE3NDkwMjU5NDh9.vtAd5T0-iIYfa8YbSDhK1HEUeOgqR3Whk4OAehbKZ3w'; // Reemplaza con tu token real
		const viewer = new Cesium.Viewer('cesiumContainer', {
		  terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(1),
		  animation: false,
		  timeline: false,
		  baseLayerPicker: false,
		  geocoder: false,
		  homeButton: false,
		  infoBox: false,
		  sceneModePicker: false,
		  selectionIndicator: false,
		  navigationHelpButton: false,
		  navigationInstructionsInitiallyVisible: false,
		  fullscreenButton: false,
		  shadows: true,
		  shouldAnimate: true,
		});

		// Añadir edificios OSM:
		const osmBuildings = await Cesium.createOsmBuildingsAsync();
		viewer.scene.primitives.add(osmBuildings);

		// 2. Desactivar controles por defecto de Cesium:
		viewer.scene.screenSpaceCameraController.enableRotate = false;
		viewer.scene.screenSpaceCameraController.enableTranslate = false;
		viewer.scene.screenSpaceCameraController.enableZoom = false;
		viewer.scene.screenSpaceCameraController.enableTilt = false;
		viewer.scene.screenSpaceCameraController.enableLook = false;
		
		// 3. Usar ScreenSpaceEventHandler para capturar arrastre de ratón:
		  const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

		  handler.setInputAction((evt) => {
			isDragging = true;
			dragStart.x = evt.position.x;
			dragStart.y = evt.position.y;
		  }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

		  handler.setInputAction(() => {
			isDragging = false;
		  }, Cesium.ScreenSpaceEventType.LEFT_UP);

		  handler.setInputAction((evt) => {
			if (!isDragging) return;
			const dx = evt.startPosition.x - evt.endPosition.x;
			const dy = evt.startPosition.y - evt.endPosition.y;
			orbitAngles.yaw -= dx * 0.005;
			orbitAngles.pitch += dy * 0.005;
			orbitAngles.pitch = Cesium.Math.clamp(orbitAngles.pitch, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
			// Actualizar dragStart para la siguiente llamada:
			dragStart.x = evt.endPosition.x;
			dragStart.y = evt.endPosition.y;
		  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

		// 4. Variables de estado del avión y controles:
		let aircraft, position, orientationQuat;
		let forwardSpeed = 0;      // velocidad actual de avance (m/s)
		let throttle = 0;          // potencia del motor [0 .. 1]
		const maxThrust = 7500;    // Empuje máximo (puedes ajustar sobre la marcha)
		const dragCoefficient = 0.02; // Coeficiente de resistencia aerodinámica
		// ─── Parámetros aerodinámicos ────────────────────────────
		const rho0 = 1.225;       // kg/m³ al nivel del mar
		const wingArea = 50;      // m²
		const wingSpan = 15;      // m (ancho de ala, ajústalo a tu modelo)
		const CL0 = 0.2;          // coef. de lift a AoA = 0
		const CL_ALPHA = 5.7;     // pendiente de coef. lift (por radian)
		const mass = 18300;        // kg
		const fuselageArea   = 10;    // m² (área frontal del fuselaje, ajústalo a tu modelo)
		const CD0Fuselaje    = 0.025; // coeficiente de drag parásito del fuselaje

	 	const keys = {};
	 
		//window.addEventListener('keydown', (e) => (keys[e.code] = true));
		//window.addEventListener('keyup', (e) => (keys[e.code] = false));


		// 5. Función para crear el modelo principal (F-22):
		async function createModel() {
		  viewer.entities.removeAll();
		  // 1. Definir posición inicial (tal cual ya lo tienes)
			position = Cesium.Cartesian3.fromDegrees(-3.7038, 40.4168, 5000);

			// 2. Crear un HeadingPitchRoll con pitch = 0, roll = 0, y el heading que tú elijas.
			//    Aquí usamos heading = 0 (hacia Norte). Si quisieras que mire Este, usa 90°.
			const initialHeading = 0; // en grados
			const hpr = new Cesium.HeadingPitchRoll(
			  Cesium.Math.toRadians(initialHeading),
			  0,    // pitch = 0 → plano al terreno
			  0     // roll = 0 → sin rotación lateral
			);

			// 3. Calcular el cuaternión “horizontal” sobre la superficie local
			orientationQuat = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

			// 4. ¡Crear el modelo!
			aircraft = viewer.entities.add({
			  name: 'F-22 Raptor',
			  position: new Cesium.CallbackProperty(() => position, false),
			  orientation: new Cesium.CallbackProperty(() => orientationQuat, false),
			  model: {
				uri: 'models/simulador/f22_model.glb',
				minimumPixelSize: 64,
				maximumScale: 10000,
				scale: 1,
			  },
			});
		}
		await createModel();
		
		// 6. Función para los proyectiles:
		const projectiles = [];

		function shootProjectile() {
			if (!position || !orientationQuat) return;

			  // 6.1. Obtenemos el eje “forward” del avión (eje X local)
			  const rotMat = Cesium.Matrix3.fromQuaternion(orientationQuat);
				const forward = Cesium.Matrix3.multiplyByVector(
				  rotMat,
				  Cesium.Cartesian3.UNIT_X,
				  new Cesium.Cartesian3()
				);

			  // 6.2. Offset para que el proyectil salga justo del morro (p. ej. 15 m delante del centro)
			  const muzzleOffset = Cesium.Cartesian3.multiplyByScalar(
				forward,
				15,
				new Cesium.Cartesian3()
			  );
			  const initialPosition = Cesium.Cartesian3.add(
				position,
				muzzleOffset,
				new Cesium.Cartesian3()
			  );

			// 6.3. Velocidad inicial de la bala: hereda forwardSpeed del avión
			// 1) Velocidad heredada del avión
			const planeVelocity = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  forwardSpeed,
			  new Cesium.Cartesian3()
			);

			// 2) Velocidad de boca de la M61 Vulcan (~1030 m/s) = (~3708 km/h)
			const muzzleVelocity = 1030; // km/h real
			const pushExtra = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  muzzleVelocity,
			  new Cesium.Cartesian3()
			);

			// 3) Velocidad inicial = avión + salida del cañón
			const initialVelocity = Cesium.Cartesian3.add(
			  planeVelocity,
			  pushExtra,
			  new Cesium.Cartesian3()
			);

			  // 6.4. Creamos la entidad del proyectil
			  let currentPosition = Cesium.Cartesian3.clone(initialPosition);
			  const entity = viewer.entities.add({
					position: new Cesium.CallbackProperty(() => currentPosition, false),
					orientation: new Cesium.CallbackProperty(() => {
					  // Orientar el modelo de la bala para que "mire" hacia adelante
					  return Cesium.Transforms.headingPitchRollQuaternion(
						currentPosition,
						new Cesium.HeadingPitchRoll(0, 0, 0)
					  );
					}, false),
					model: {
					  uri: 'models/simulador/silver_projectile.glb',
					  scale: 5.25,
					  minimumPixelSize: 1
					}
			  });

			// 6.5. Añadimos al array para actualizar cada frame
			projectiles.push({
				entity,
				velocity: Cesium.Cartesian3.clone(initialVelocity),
				update: function(deltaTime) {
					  this.velocity.z -= gravity * deltaTime;

					  const step = Cesium.Cartesian3.multiplyByScalar(
						this.velocity,
						deltaTime,
						new Cesium.Cartesian3()
					  );
					  currentPosition = Cesium.Cartesian3.add(
						currentPosition,
						step,
						new Cesium.Cartesian3()
					  );

					  const carto = Cesium.Cartographic.fromCartesian(currentPosition);
					  const terrainHeight = viewer.scene.globe.getHeight(carto);

					  if (terrainHeight !== undefined && carto.height <= terrainHeight + 1) {
						viewer.entities.remove(entity);
						createSmokeAt(currentPosition, false); // Humo normal (blanco)
						return false;
					  }

					  // 1. Intento con raycast
					  const rayDirection = Cesium.Cartesian3.normalize(this.velocity, new Cesium.Cartesian3());
					  const ray = new Cesium.Ray(currentPosition, rayDirection);
					  const hit = viewer.scene.pickFromRay(ray);

					  // 2. Intento con screen pick si ray falla
					  let hitOSM = false;

					  if (hit && hit.primitive === osmBuildings) {
						hitOSM = true;
					  } else {
						const screenPos = viewer.scene.cartesianToCanvasCoordinates(currentPosition);
						if (Cesium.defined(screenPos)) {
						  const picked = viewer.scene.pick(screenPos);
						  if (Cesium.defined(picked) && picked.primitive === osmBuildings) {
							hitOSM = true;
						  }
						}
					  }

					  if (hitOSM) {
						viewer.entities.remove(entity);
						createSmokeAt(currentPosition, true);
						console.log("¡Impacto en edificio OSM detectado!");
						return false;
					  }

					  if (Cesium.Cartesian3.distance(currentPosition, initialPosition) > 20000) {
						viewer.entities.remove(entity);
						return false;
					  }

					  return true;
					}
			});
		}

		// 7. Función para crear los efectos de los proyectiles
		
		function createSmokeAt(position, isBlackSmoke = false) {
			  const carto = Cesium.Cartographic.fromCartesian(position);
			  const terrainHeight = viewer.scene.globe.getHeight(carto);
			  const adjustedPosition = Cesium.Cartesian3.fromRadians(
				carto.longitude,
				carto.latitude,
				terrainHeight + 1.0 // justo sobre el suelo
			  );

			  const smokeParticles = [];
			  const maxParticles = isBlackSmoke ? 1: 20;
			  const particleUri = isBlackSmoke ? 'models/simulador/incendio.glb' : 'models/simulador/smoke_particle.glb';
			  const lifespan = isBlackSmoke ? 60: 3;

			  for (let i = 0; i < maxParticles; i++) {
				// Offset horizontal amplio, pero Z muy pequeño si es humo negro
				const zOffset = isBlackSmoke ? 0 : Math.random() * 10;
				const offset = Cesium.Cartesian3.fromElements(
				  (Math.random() - 0.5) * 10,
				  (Math.random() - 0.5) * 10,
				  zOffset
				);

				const particlePosition = Cesium.Cartesian3.add(adjustedPosition, offset, new Cesium.Cartesian3());
   
				const entity = {
				  position: particlePosition,
				  velocity: new Cesium.Cartesian3(
					(Math.random() - 0.5) * 1.5,
					(Math.random() - 0.5) * 1.5,
					1 + Math.random() * 3
				  ),
				  age: 0,
				  lifespan: lifespan + Math.random() * 5,
				  scale: 1 + Math.random() * 0.5,
				  modelEntity: null,
				  isBlackSmoke
				};

				entity.modelEntity = viewer.entities.add({
				  position: new Cesium.CallbackProperty(() => entity.position, false),
				 orientation: new Cesium.CallbackProperty(() => {
				   // Ajusta 'entity.position' como punto de referencia
				   return Cesium.Transforms.headingPitchRollQuaternion(
					 entity.position,
					 new Cesium.HeadingPitchRoll(
					   Cesium.Math.toRadians(90), // heading = 90°
					   Cesium.Math.toRadians(90),   // pitch = 90º
					   0                          // roll  = 0
					 )
				   );
				 }, false),
				  model: {
					uri: particleUri,
					scale: new Cesium.CallbackProperty(() => {
					  const growth = 1 + entity.age * 0.2;
					  return entity.scale * growth;
					}, false),
					minimumPixelSize: 10,					
					color: isBlackSmoke
						 ? Cesium.Color.BLACK.withAlpha(0.8)
						 : Cesium.Color.WHITE.withAlpha(0.5),
					colorBlendMode: Cesium.ColorBlendMode.MIX,
					colorBlendAmount: 0.8
				  }
				});

				entity.update = (deltaTime) => {
				  entity.age += deltaTime;
				  if (entity.age >= entity.lifespan) {
					viewer.entities.remove(entity.modelEntity);
					return false;
				  }

				  const deltaMove = Cesium.Cartesian3.multiplyByScalar(entity.velocity, deltaTime, new Cesium.Cartesian3());
				  entity.position = Cesium.Cartesian3.add(entity.position, deltaMove, new Cesium.Cartesian3());

				  // Reinicia partículas de humo negro para que dure como incendio
				  if (entity.isBlackSmoke && entity.age >= entity.lifespan - 1) {
					entity.age = 0; // Reiniciar edad
					entity.position = Cesium.Cartesian3.add(position, offset, new Cesium.Cartesian3());
				  }

				  return true;
				};

				smokeParticles.push(entity);
			  }

			  activeSmokeSystems.push(smokeParticles);
		}


		// 8. Contoles 
		
		window.addEventListener("keydown", (e) => {
		  keys[e.code] = true;
		  if (e.code === "Space") shootProjectile();
		  if (e.code === "Enter") {
			autoLevel = true;
		  }
		  // Si el piloto vuelve a dar una orden manual, cancelamos el auto-nivelado
		  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","KeyQ","KeyE"].includes(e.code)) {
			autoLevel = false;
		  }
		});
		
		  // Listener para liberación de teclas: limpiar el flag
		  window.addEventListener("keyup", (e) => {
			if (keys[e.code]) {
			  keys[e.code] = false;
			}
		  });
		
		// ─── Tensor de inercia (valores de ejemplo, en kg·m²) ─────────────────────────
		const I = Cesium.Matrix3.fromArray([
		  1.2e5,   0,      0,
			0,   9.0e4,   0,
			0,     0,   1.5e5
		]);
		const Iinv = Cesium.Matrix3.inverse(I, new Cesium.Matrix3());

		// Superficies de control y brazos de palanca (m² y m)
		const S_aileron   = 4.0,  l_aileron   = 5.0;
		const S_elevator  = 3.5,  l_elevator  = 7.0;
		const S_rudder    = 2.0,  l_rudder    = 6.0;
		
		// ─── Parámetros para pitching moment de fuselaje ──────────────────────────────
		const Cm_ALPHA      = 0.05;      // coef. moment pitching por rad
		const l_fuselage    = 8.0;       // brazo de palanca fuselaje (m)

		// Coeficiente de damping rotacional
		const C_d_rot = 0.5;
		
		// ─── Parámetros de motor con spool-up/spool-down ──────────────────────────────
		// Empuje actual del motor (N)
		let thrustCurrent = 0.0;

		// Estado de la velocidad angular en el cuerpo
		let ω = new Cesium.Cartesian3(0, 0, 0);
		// ─── Límites de velocidad angular (rad/s) ───────────────────────────────────
		const maxRollRate  = Cesium.Math.toRadians(90);   // ±90°/s
		const maxPitchRate = Cesium.Math.toRadians(60);   // ±60°/s
		const maxYawRate   = Cesium.Math.toRadians(45);   // ±45°/s
		
		// ─── Estado de deflexión actual de superficies (rad) ─────────────────────────
		let δa_current = 0.0, δe_current = 0.0, δr_current = 0.0;
		// Máxima velocidad de deflexión: 30° por segundo
		const maxDeflectionRate = Cesium.Math.toRadians(30);
				
		// Flag para auto-nivelado
		let autoLevel = false;
		
		// ──────────────────────────────────────────────────────────────────────────────
		
		// ─── Variables para giroscopio móvil ──────────────────────────────────────────
		let useGyro = false;
		let gyroOffset = { alpha: 0, beta: 0, gamma: 0 };
		let gyroAngles = { roll: 0, pitch: 0, yaw: 0 };
		// Almacenamos el último evento para el reset
		let lastEvent = { alpha: 0, beta: 0, gamma: 0 };

		// Detectar soporte y activar giroscopio
		if (window.DeviceOrientationEvent) {
			window.addEventListener('deviceorientation', (e) => {
				if (e.alpha === null) {
				return;
				}
				// Guardamos el evento para poder resetear offset más tarde
				lastEvent.alpha = e.alpha;
				lastEvent.beta  = e.beta;
				lastEvent.gamma = e.gamma;
		
				useGyro = true;
				document.getElementById('mobileControls').style.display = 'flex';
				document.getElementById('throttleSlider').style.display = 'block';
		
				// Calcular diferencia respecto al offset
				const a = e.alpha - gyroOffset.alpha;
				const b = e.beta  - gyroOffset.beta;
				const g = e.gamma - gyroOffset.gamma;
		
				// Mapear a radianes y ajustar signos para Cesium
				gyroAngles.yaw   = Cesium.Math.toRadians( a       ); // giro horizontal
				gyroAngles.pitch = Cesium.Math.toRadians(-b       ); // tilt adelante/atrás invertido
				gyroAngles.roll  = Cesium.Math.toRadians( g       ); // tilt izquierda/derecha
			});

			// Botón reset gyro
			document.getElementById('btnResetGyro').addEventListener('click', () => {
				// Desactivamos momentáneamente el gyro para no aplicar ápex en este mismo frame
				useGyro = false;
				// Reajustamos el offset a la última lectura válida
				gyroOffset.alpha = lastEvent.alpha;
				gyroOffset.beta  = lastEvent.beta;
				gyroOffset.gamma = lastEvent.gamma;
				// Volvemos a activar el gyro
				useGyro = true;
				console.log('Giroscopio reiniciado y offset actualizado');
			});
		}

		// Botón fullscreen
		document.getElementById('btnFullscreen').addEventListener('click', () => {
			const el = document.documentElement;
			if (!document.fullscreenElement) {
				el.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		});

		// Slider de throttle
		const slider = document.getElementById('throttleSlider');
		slider.addEventListener('input', () => {
			throttle = slider.value / 100;
		});
		
		//--------------------------------------------------------------------------------------

		//10. Control de escenas
		
		let lastTime = performance.now();
		// Para cálculo de cargas G
		let prevPlaneVelocity = new Cesium.Cartesian3(0, 0, 0);

		viewer.scene.postRender.addEventListener(() => {
		  const now = performance.now();
		  const deltaTime = (now - lastTime) / 1000;
		  lastTime = now;
		  if (!position || !orientationQuat) return;

		  // ─── 10.1 Recalcular forward / up / surfaceNormal / carto / hpr ────────────────
		const rotMatrix     = Cesium.Matrix3.fromQuaternion(orientationQuat);
		const forward       = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_X, new Cesium.Cartesian3());
		const right         = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Y, new Cesium.Cartesian3());
		const up            = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
		  const carto     = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
		  const hpr       = Cesium.HeadingPitchRoll.fromQuaternion(orientationQuat);
		  const surfaceNormal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(position, new Cesium.Cartesian3());

		  // ─── 10.2 Cálculo de planeVelocity (antes de lift) ───────────────────────
		  const forwardVelocity  = Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed, new Cesium.Cartesian3());
		  const verticalVelocity = Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed, new Cesium.Cartesian3());
		  const planeVelocity    = Cesium.Cartesian3.add(forwardVelocity, verticalVelocity, new Cesium.Cartesian3());

		  // ─── 10.3 Sustentación (lift) y drag aerodinámico realista ────────────────────────
		  const V = Cesium.Cartesian3.magnitude(planeVelocity);
		  let liftForce = 0;
		  let dragForceScalar = 0;
		  // Ángulo de ataque (radianes)
		  let aoa = 0;		  
		  
		  let liftDir = new Cesium.Cartesian3(0, 0, 0);

		  if (V > 0.1) {
			// a) calculamos AoA
			const flightDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(planeVelocity), new Cesium.Cartesian3());
			let cosAoA = Cesium.Math.clamp(Cesium.Cartesian3.dot(flightDir, forward), -1.0, 1.0);
			aoa = Math.acos(cosAoA);
			
			// ─── Modelo de stall real ───────────────────────────────
			const stallLimit = Cesium.Math.toRadians(15);
			const maxAoA     = Cesium.Math.toRadians(45); // ángulo donde CL cae a cero
			
			// b) coeficiente de lift: lineal hasta stall, luego cae lineal hasta cero
			let CL;
			if (aoa <= stallLimit) {
			CL = CL_ALPHA * aoa;
			} else {
			const CLmax  = CL_ALPHA * stallLimit;
			const excess = aoa - stallLimit;
			CL = CLmax * Math.max(0, 1 - excess / (maxAoA - stallLimit));
			}
			
			// c) coeficiente inducido aproximado: CDi = CL² / (π·AR)
			const AR = (wingSpan || Math.sqrt(wingArea)) ? wingSpan : wingArea;
			const CDi = (CL * CL) / (Math.PI * (AR || wingArea));

			// d) densidad ISA simplificado
			const rho = rho0 * Math.exp(-carto.height / 8500);
			
			// e) presión dinámica
			const qd = 0.5 * rho * V * V;
			
			 // f) fuerzas de lift y drag con drag extra en stall
			 liftForce = qd * wingArea * CL;
			 // g) lift adicional generado por el fuselaje (traslacional, no rotacional)
			 //   usamos Cm_ALPHA como coeficiente de lift por radian para el fuselaje
			 const CL_fuselaje = Cm_ALPHA * aoa;
			 liftForce += qd * fuselageArea * CL_fuselaje;
			 
			// drag base: inducido + parásito de fuselaje
			const baseCD = CDi + CD0Fuselaje * (fuselageArea / wingArea);
			// drag adicional post-stall
			let stallDrag = 0;
			if (aoa > stallLimit) {
				const excess = aoa - stallLimit;
				stallDrag = 2.0 * (excess / (maxAoA - stallLimit)); // ajusta magnitud a gusto
			}
			dragForceScalar = qd * wingArea * (baseCD + stallDrag);

			// g) dirección de lift
			const tmp = new Cesium.Cartesian3();
			Cesium.Cartesian3.cross(planeVelocity, right, tmp);
			Cesium.Cartesian3.cross(tmp, planeVelocity, tmp);
			if (Cesium.Cartesian3.magnitude(tmp) > 1e-3) {
			  Cesium.Cartesian3.normalize(tmp, tmp);
			}
			liftDir = tmp;

			// Dinámica rotacional física (¡aquí aplicamos los torques!) ─────────────────
			updateRotation(deltaTime, qd);
		  }

		  // ─── 10.4 Actualizar verticalSpeed con lift, gravedad y damping ───────────────────
		  verticalSpeed -= gravity * deltaTime;
		  if (liftForce !== 0) {
			verticalSpeed += (liftForce / mass) * deltaTime;
		  }
		  verticalSpeed *= (1 - dragFactor * deltaTime);
		  verticalSpeed = Math.max(-300, Math.min(verticalSpeed, 300));

		  // ─── 10.5 Drag aerodinámico horizontal ───────────────────────────────────────────
		  let dragDir = new Cesium.Cartesian3(0, 0, 0);
		  if (V > 0.1) {
			dragDir = Cesium.Cartesian3.clone(planeVelocity);
			Cesium.Cartesian3.normalize(dragDir, dragDir);
			Cesium.Cartesian3.negate(dragDir, dragDir);
		  }
		  const dragAcc = dragForceScalar / mass;
		  const dragStep = Cesium.Cartesian3.multiplyByScalar(dragDir, dragAcc * deltaTime, new Cesium.Cartesian3());

		  const newVel = Cesium.Cartesian3.add(planeVelocity, dragStep, new Cesium.Cartesian3());
		  forwardSpeed = Math.max(0, Cesium.Cartesian3.dot(newVel, forward));

		  // ─── 10.6 Dinámica de avance con throttle y dragCoefficient simple ─────────────────
		  const thrust = throttle * maxThrust;
		  const simpleDrag = dragCoefficient * forwardSpeed * forwardSpeed;
		  forwardSpeed += (thrust - simpleDrag) * deltaTime;
		  forwardSpeed = Math.max(0, forwardSpeed);

		  // ─── 10.7 Desplazar posición del avión ───────────────────────────────────────────
		  const stepForward  = Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed * deltaTime, new Cesium.Cartesian3());
		  const gravityStep  = Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed * deltaTime, new Cesium.Cartesian3());
		  position = Cesium.Cartesian3.add(position, Cesium.Cartesian3.add(stepForward, gravityStep, new Cesium.Cartesian3()), new Cesium.Cartesian3());

		  // ─── 10.8 Órbita de la cámara alrededor del avión ──────────────────────────────
		  const center = Cesium.Cartesian3.clone(position);
		  const localOffset = new Cesium.Cartesian3(
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.sin(orbitAngles.yaw),
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.cos(orbitAngles.yaw),
			orbitRadius * Math.sin(orbitAngles.pitch)
		  );
		  const offset = Cesium.Matrix3.multiplyByVector(rotMatrix, localOffset, new Cesium.Cartesian3());
		  const cameraPos = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());
		  const dir       = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
		  const upVec     = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
		  viewer.scene.camera.setView({
			destination: cameraPos,
			orientation: { direction: dir, up: upVec }
		  });

		  // ─── 10.9 Límite de altitud ───────────────────────────────────────────────────
		  if (carto.height > 15000 && verticalSpeed > 0) {
			verticalSpeed = 0;
		  }

		  // ─── 10.10 Ajuste de throttle con +/- ──────────────────────────────────────────
		  const throttleStep = 0.5 * deltaTime;
		  if (keys['Equal'] || keys['NumpadAdd'])    throttle = Math.min(throttle + throttleStep, 1.0);
		  if (keys['Minus'] || keys['NumpadSubtract']) throttle = Math.max(throttle - throttleStep, 0.0);

		  // ─── 10.11 Actualizar proyectiles ──────────────────────────────────────────────
		  for (let i = projectiles.length - 1; i >= 0; i--) {
		    const proj = projectiles[i];
		    const alive = proj.update(deltaTime);
		    if (!alive) {
		      projectiles.splice(i, 1);
		    }
		  }
		  
		  // ─── 10.12 Efectos de humo ─────────────────────────────────────────────────────
		  for (let s = activeSmokeSystems.length - 1; s >= 0; s--) {
		    const system = activeSmokeSystems[s];
		    for (let i = system.length - 1; i >= 0; i--) {
		      if (!system[i].update(deltaTime)) {
		        system.splice(i, 1);
		      }
		    }
		    if (system.length === 0) activeSmokeSystems.splice(s, 1);
		  }
		  
		// ─── Detección de terreno y colisión ──────────────────────────────────────
		const terrainHeight = viewer.scene.globe.getHeight(carto);
		const margin = 1.0;
		
		if (terrainHeight !== undefined && carto.height <= terrainHeight + margin) {
			if (verticalSpeed < -10) {
			// Colisión brusca
			forwardSpeed = 0;
			verticalSpeed = 0;
		
			position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight + margin);
			alert("¡Colisión grave! Simulación detenida.");
		
			viewer.scene.postRender.removeEventListener(arguments.callee);
			} else {
			// Aterrizaje suave o rebote leve
			forwardSpeed *= 0.5;
			verticalSpeed *= -0.3;
		
			position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight + margin);
			}
		}

		  // ─── 10.13 HUD ─────────────────────────────────────────────────────────────────
		  // Recalculamos planeVelocity con la nueva forwardSpeed y verticalSpeed
		  const newForwardVel = Cesium.Cartesian3.multiplyByScalar(
		    forward,
		    forwardSpeed,
		    new Cesium.Cartesian3()
		  );
		  const newVerticalVel = Cesium.Cartesian3.multiplyByScalar(
		    surfaceNormal,
		    verticalSpeed,
		    new Cesium.Cartesian3()
		  );
		  const newPlaneVel = Cesium.Cartesian3.add(newForwardVel, newVerticalVel, new Cesium.Cartesian3());
		  const totalSpeed = Cesium.Cartesian3.magnitude(newPlaneVel);

		  const lat = Cesium.Math.toDegrees(carto.latitude).toFixed(5);
		  const lon = Cesium.Math.toDegrees(carto.longitude).toFixed(5);
		  const altVal = carto.height.toFixed(1);
		  const pitchDeg = Cesium.Math.toDegrees(hpr.pitch).toFixed(1);
		  const yawDeg   = Cesium.Math.toDegrees(hpr.heading).toFixed(1);
		  const rollDeg  = Cesium.Math.toDegrees(hpr.roll).toFixed(1);

		  // ─── Nuevos indicadores: velocidades angulares y AoA ─────────────────────────
		  // ω está en rad/s; convertir a deg/s
		  const rollRateDeg  = Cesium.Math.toDegrees(ω.x).toFixed(1);
		  const pitchRateDeg = Cesium.Math.toDegrees(ω.y).toFixed(1);
		  const yawRateDeg   = Cesium.Math.toDegrees(ω.z).toFixed(1);
		  document.getElementById("rollRate").textContent  = rollRateDeg;
		  document.getElementById("pitchRate").textContent = pitchRateDeg;
		  document.getElementById("yawRate").textContent   = yawRateDeg;

		  // AoA en grados
		  document.getElementById("aoa").textContent = Cesium.Math.toDegrees(aoa).toFixed(1);

		  document.getElementById("coords").textContent   = `${lat}, ${lon}`;
		  document.getElementById("alt").textContent      = altVal;
		  document.getElementById("spd").textContent      = (totalSpeed * 3.6).toFixed(0);
		  document.getElementById("throttle").textContent = (throttle * 100).toFixed(0);
		  document.getElementById("pitch").textContent    = pitchDeg;
		  document.getElementById("yaw").textContent      = yawDeg;
		  document.getElementById("roll").textContent     = rollDeg;
		  
		  // ─── Cargas G ───────────────────────────────────────────
		  // aceleración = (v - v_prev)/dt
		  const accel = Cesium.Cartesian3.subtract(planeVelocity, prevPlaneVelocity, new Cesium.Cartesian3());
		  Cesium.Cartesian3.divideByScalar(accel, deltaTime, accel);
		  // vector gravedad en NED (0,0,-g)
		  const gravVec = new Cesium.Cartesian3(0, 0, -gravity);
		  // aceleración total
		  const totalAccel = Cesium.Cartesian3.add(accel, gravVec, new Cesium.Cartesian3());
		  const gLoad = (Cesium.Cartesian3.magnitude(totalAccel) / gravity).toFixed(2);
		  document.getElementById("gLoad").textContent = gLoad + " g";
		  // actualizar prevPlaneVelocity
		  prevPlaneVelocity = Cesium.Cartesian3.clone(planeVelocity);

		});
		
		/**
		 * Recalcula todos los vectores básicos y retorna el estado del frame.
		 */
		function computeFrameState() {
		  const rotMatrix     = Cesium.Matrix3.fromQuaternion(orientationQuat);
		  const forward       = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_X, new Cesium.Cartesian3());
		  const right         = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Y, new Cesium.Cartesian3());
		  const up            = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
		  const surfaceNormal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(position, new Cesium.Cartesian3());
		  const carto         = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
		  const hpr           = Cesium.HeadingPitchRoll.fromQuaternion(orientationQuat);
		  const planeVelocity = Cesium.Cartesian3.add(
			Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed, new Cesium.Cartesian3()),
			Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed, new Cesium.Cartesian3()),
			new Cesium.Cartesian3()
		  );
		  const speed      = Cesium.Cartesian3.magnitude(planeVelocity);
		  const angularVel = Cesium.Cartesian3.clone(ω);
		  // IMPORTANTE: incluimos position y angularVel para updateCamera/updateHUD
		  return { rotMatrix, forward, right, up, surfaceNormal, carto, hpr, planeVelocity, speed, angularVel, position };
		}

		/**
		 * Calcula lift y drag según AoA y stall.
		 */
		function computeAerodynamics({ planeVelocity, forward, carto }) {
		  const V = Cesium.Cartesian3.magnitude(planeVelocity);
		  let aoa = 0, qd = 0, liftForce = 0, dragForce = 0;
		  const stallLimit = Cesium.Math.toRadians(15);
		  const maxAoA     = Cesium.Math.toRadians(45);
		  if (V > 0.1) {
			const flightDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(planeVelocity), new Cesium.Cartesian3());
			aoa = Math.min(Math.acos(Cesium.Math.clamp(Cesium.Cartesian3.dot(flightDir, forward), -1, 1)), maxAoA);
			const rho = rho0 * Math.exp(-carto.height / 8500);
			qd = 0.5 * rho * V * V;
			let CL = aoa <= stallLimit
			  ? CL_ALPHA * aoa
			  : (CL_ALPHA * stallLimit) * Math.max(0, 1 - (aoa - stallLimit) / (maxAoA - stallLimit));
			const AR      = wingSpan || Math.sqrt(wingArea);
			const CDi     = (CL * CL) / (Math.PI * AR);
			const baseCD  = CDi + CD0Fuselaje * (fuselageArea / wingArea);
			const stallD  = aoa > stallLimit ? 2 * ((aoa - stallLimit) / (maxAoA - stallLimit)) : 0;
			liftForce = qd * wingArea * CL + qd * fuselageArea * Cm_ALPHA * aoa;
			dragForce = qd * wingArea * (baseCD + stallD);
		  }
		  return { aoa, qd, liftForce, dragForce };
		}

		/**
		 * @param {number} dt
		 * @param {Object} state
		 * @param {number} state.forward
		 * @param {number} state.surfaceNormal
		 * @param {Object} aero — { liftForce, dragForce, qd, aoa }
		 */
		function updatePhysics(dt, state, { liftForce, dragForce, qd, aoa }) {
		  const { forward, surfaceNormal } = state;
		  // 1) rotación
		  updateRotation(dt, qd, aoa);

		  // 2) vertical
		  verticalSpeed = Cesium.Math.clamp(
			verticalSpeed - gravity * dt + (liftForce / mass) * dt,
			-300, 300
		  );

		  // 3) longitudinal
		  const thrustForce   = throttle * maxThrust;
		  const parasiticDrag = dragCoefficient * forwardSpeed * forwardSpeed;
		  const totalDrag     = dragForce + parasiticDrag;
		  // convertir fuerza neta en aceleración
		  const accelForward  = (thrustForce - totalDrag) / mass;
		  forwardSpeed = Math.max(0, forwardSpeed + accelForward * dt);

		  // 4) posición
		  position = Cesium.Cartesian3.add(
			position,
			Cesium.Cartesian3.add(
			  Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed * dt,  new Cesium.Cartesian3()),
			  Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed * dt, new Cesium.Cartesian3()),
			  new Cesium.Cartesian3()
			),
			new Cesium.Cartesian3()
		  );
		}
		
		/**
		 * Actualiza la cámara para orbitar alrededor del avión.
		 * @param {{ rotMatrix: Cesium.Matrix3, position: Cesium.Cartesian3 }} state
		 */
		function updateCamera(state) {
		  const { rotMatrix, position } = state;

		  // Punto alrededor del que orbita la cámara
		  const center = Cesium.Cartesian3.clone(position);

		  // Offset local en coordenadas del avión
		  const localOffset = new Cesium.Cartesian3(
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.sin(orbitAngles.yaw),
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.cos(orbitAngles.yaw),
			orbitRadius * Math.sin(orbitAngles.pitch)
		  );

		  // Transformar offset al espacio mundial
		  const offset = Cesium.Matrix3.multiplyByVector(
			rotMatrix,
			localOffset,
			new Cesium.Cartesian3()
		  );

		  // Posición final de la cámara
		  const cameraPos = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());

		  // Dirección de la cámara (apunta al avión)
		  const direction = Cesium.Cartesian3.normalize(
			Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
			new Cesium.Cartesian3()
		  );

		  // Vector "up" de la cámara, alineado con el eje Z del avión
		  const up = Cesium.Matrix3.multiplyByVector(
			rotMatrix,
			Cesium.Cartesian3.UNIT_Z,
			new Cesium.Cartesian3()
		  );

		  // Aplicar la vista
		  viewer.scene.camera.setView({
			destination: cameraPos,
			orientation: { direction, up }
		  });
		}

		/**
		 * Actualiza el HUD con los datos de vuelo.
		 *
		 * @param {Object} state
		 * @param {Cesium.Cartographic} state.carto         — Posición geográfica (lat, lon, alt).
		 * @param {Cesium.HeadingPitchRoll} state.hpr       — Orientación (heading, pitch, roll).
		 * @param {number} state.speed                      — Velocidad total (m/s).
		 * @param {Cesium.Cartesian3} state.angularVel      — Velocidad angular en rad/s (x=roll, y=pitch, z=yaw).
		 * @param {Object} aero
		 * @param {number} aero.aoa                         — Ángulo de ataque (rad).
		 * @param {number} gLoad                             — Carga G instantánea.
		 */
		function updateHUD(state, aero, gLoad) {
		  const { carto, hpr, speed, angularVel } = state;

		  // Coordenadas
		  document.getElementById("coords").textContent =
			`${Cesium.Math.toDegrees(carto.latitude).toFixed(5)}, ` +
			`${Cesium.Math.toDegrees(carto.longitude).toFixed(5)}`;

		  // Altitud
		  document.getElementById("alt").textContent = carto.height.toFixed(1);

		  // Velocidad en km/h
		  document.getElementById("spd").textContent = (speed * 3.6).toFixed(0);

		  // Throttle (%)
		  document.getElementById("throttle").textContent = Math.round(throttle * 100);

		  // Ángulos de orientación
		  document.getElementById("pitch").textContent = Cesium.Math.toDegrees(hpr.pitch).toFixed(1);
		  document.getElementById("yaw").textContent   = Cesium.Math.toDegrees(hpr.heading).toFixed(1);
		  document.getElementById("roll").textContent  = Cesium.Math.toDegrees(hpr.roll).toFixed(1);

		  // Ángulo de ataque (AoA)
		  document.getElementById("aoa").textContent = Cesium.Math.toDegrees(aero.aoa).toFixed(1);

		  // Velocidades angulares en °/s
		  document.getElementById("rollRate").textContent  =
			Cesium.Math.toDegrees(angularVel.x).toFixed(1);
		  document.getElementById("pitchRate").textContent =
			Cesium.Math.toDegrees(angularVel.y).toFixed(1);
		  document.getElementById("yawRate").textContent   =
			Cesium.Math.toDegrees(angularVel.z).toFixed(1);

		  // Carga G
		  document.getElementById("gLoad").textContent = gLoad.toFixed(2) + " g";
		}

		/**
		 * Actualiza todos los proyectiles disparados.
		 * @param {number} dt — Tiempo transcurrido en segundos desde el último frame.
		 */
		function updateProjectiles(dt) {
		  // Recorremos de atrás hacia adelante para poder eliminar sin afectar índices
		  for (let i = projectiles.length - 1; i >= 0; i--) {
			const proj = projectiles[i];
			const alive = proj.update(dt);
			if (!alive) {
			  // Si retornó false, ya no debe existir: lo quitamos del array
			  projectiles.splice(i, 1);
			}
		  }
		}

		/**
		 * Actualiza todos los sistemas de humo activos.
		 * @param {number} dt — Tiempo transcurrido en segundos desde el último frame.
		 */
		function updateSmoke(dt) {
		  // Recorremos cada sistema de partículas
		  for (let s = activeSmokeSystems.length - 1; s >= 0; s--) {
			const system = activeSmokeSystems[s];
			// Actualizamos cada partícula en el sistema
			for (let i = system.length - 1; i >= 0; i--) {
			  const particle = system[i];
			  const alive = particle.update(dt);
			  if (!alive) {
				// Si la partícula ha expirado, la eliminamos
				system.splice(i, 1);
			  }
			}
			// Si el sistema quedó vacío, lo eliminamos por completo
			if (system.length === 0) {
			  activeSmokeSystems.splice(s, 1);
			}
		  }
		}
		
		/**
	    * Integra la dinámica rotacional de cuerpo rígido vía Newton–Euler
	    * @param {number} dt  Intervalo de tiempo en segundos
	    * @param {number} qd  Velocidad dinámica del aire para fuerzas de control
	    */
		function updateRotation(dt, qd) {
			// 1) Deflexión de superficies: calcular objetivo y limitar velocidad de cambio
			const maxDef = Math.PI / 18; // ±10°

			// Objetivos de deflexión manual o vía giroscopio
			let δa_target_manual, δe_target_manual, δr_target_manual;
			if (useGyro) {
			δa_target_manual = Cesium.Math.clamp(gyroAngles.roll,  -maxDef, maxDef);
			δe_target_manual = Cesium.Math.clamp(gyroAngles.pitch, -maxDef, maxDef);
			δr_target_manual = Cesium.Math.clamp(gyroAngles.yaw,   -maxDef, maxDef);
			} else {
			δa_target_manual = keys['ArrowLeft']  ? -maxDef : keys['ArrowRight'] ? +maxDef : 0;
			δe_target_manual = keys['ArrowUp']    ? +maxDef : keys['ArrowDown']  ? -maxDef : 0;
			δr_target_manual = keys['KeyQ']       ? +maxDef : keys['KeyE']      ? -maxDef : 0;
			}

			// Objetivos dependiendo de auto-nivelado
			let δa_target = δa_target_manual;
			let δe_target = δe_target_manual;
			let δr_target = δr_target_manual;
			if (autoLevel) {
			  const k_trim = 2.0;
			  δa_target = Cesium.Math.clamp(-k_trim * ω.x, -maxDef, maxDef);
			  δe_target = Cesium.Math.clamp(-k_trim * ω.y, -maxDef, maxDef);
			  δr_target = Cesium.Math.clamp(-k_trim * ω.z, -maxDef, maxDef);
			  if (Cesium.Cartesian3.magnitude(ω) < 0.1) {
				autoLevel = false;
			  }
			}

			// Suavizar hacia el objetivo con velocidad limitada
			const step = maxDeflectionRate * dt;
			δa_current += Cesium.Math.clamp(δa_target - δa_current, -step, step);
			δe_current += Cesium.Math.clamp(δe_target - δe_current, -step, step);
			δr_current += Cesium.Math.clamp(δr_target - δr_current, -step, step);

			// Usar las deflexiones suavizadas
			const δa = δa_current;
			const δe = δe_current;
			const δr = δr_current;

			// 2) Torques aerodinámicos de superficies: τ = qd · S · δ · l
			const τx =  qd * S_aileron  * δa * l_aileron;   // roll
			const τy =  qd * S_elevator * δe * l_elevator;  // pitch (solo de elevador)
			const τz =  qd * S_rudder   * δr * l_rudder;    // yaw
		 
			// 2.5) **Eliminado** momento de fuselaje: ya lo tratamos como lift en la parte de fuerzas
			const totalτy = τy;

			// 3) Damping rotacional lineal: τ_d = -C_d_rot · ω
			const τd = Cesium.Cartesian3.multiplyByScalar(ω, -C_d_rot, new Cesium.Cartesian3());

			// 4) Torque neto en cuerpo (superficies + fuselaje + damping)
			const τ = Cesium.Cartesian3.add(
			  new Cesium.Cartesian3(τx, totalτy, τz),
			  τd,
			  new Cesium.Cartesian3()
			);
	
			  // 5) Compute ω×(I·ω)
			  const Iω = Cesium.Matrix3.multiplyByVector(I, ω, new Cesium.Cartesian3());
			  const ωIω = Cesium.Cartesian3.cross(ω, Iω, new Cesium.Cartesian3());

			  // 6) α = I⁻¹·(τ - ω×(I·ω))
			  const net = Cesium.Cartesian3.subtract(τ, ωIω, new Cesium.Cartesian3());
			  const α = Cesium.Matrix3.multiplyByVector(Iinv, net, new Cesium.Cartesian3());

			   // 7) Integrar velocidad angular
			ω = Cesium.Cartesian3.add(ω, Cesium.Cartesian3.multiplyByScalar(α, dt, new Cesium.Cartesian3()), new Cesium.Cartesian3());

			// 7.1) Limitar velocidades angulares a rangos realistas
			ω.x = Cesium.Math.clamp(ω.x, -maxRollRate,  maxRollRate);
			ω.y = Cesium.Math.clamp(ω.y, -maxPitchRate, maxPitchRate);
			ω.z = Cesium.Math.clamp(ω.z, -maxYawRate,   maxYawRate);

			 // 8) Integración incremental de quaternion usando ejes del cuerpo
			const bodyToWorld = Cesium.Matrix3.fromQuaternion(orientationQuat);
			const axisRoll  = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(1, 0, 0), new Cesium.Cartesian3());
			const axisPitch = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(0, 1, 0), new Cesium.Cartesian3());
			const axisYaw   = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(0, 0, 1), new Cesium.Cartesian3());

			// Quaterniones incrementales alrededor de ejes locales
			const qIncRoll  = Cesium.Quaternion.fromAxisAngle(axisRoll,  ω.x * dt);
			const qIncPitch = Cesium.Quaternion.fromAxisAngle(axisPitch, ω.y * dt);
			const qIncYaw   = Cesium.Quaternion.fromAxisAngle(axisYaw,   ω.z * dt);

			// Aplicar en orden: roll → pitch → yaw
			orientationQuat = Cesium.Quaternion.normalize(
			  Cesium.Quaternion.multiply(
				qIncYaw,
				Cesium.Quaternion.multiply(
				  qIncPitch,
				  Cesium.Quaternion.multiply(qIncRoll, orientationQuat, new Cesium.Quaternion()),
				  new Cesium.Quaternion()
				),
				new Cesium.Quaternion()
			  ),
			  new Cesium.Quaternion()
			);
		}

		/*
		Recursos: 	https://convert3d.org/app
					https://www.figuro.io/Designer
					https://app.sketchup.com/app?_gl=1*8i50n1*_gcl_au*NzcxNzI0MDc4LjE3NDk1NDE5NjA.
					https://www.turbosquid.com/3d-models/f16-fighter-plane-815125
					https://poly.pizza/
					https://gltf-viewer.donmccurdy.com/
		*/
	})();
</script>
</body>
</html>
