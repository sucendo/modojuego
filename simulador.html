<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Simulador de Vuelo con CesiumJS</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
  </style>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
<div id="cesiumContainer"></div>
<div id="hud" style="
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-family: monospace;
  padding: 10px;
  font-size: 14px;
  z-index: 999;
  border-radius: 5px;
">
  <div><strong>Coordenadas:</strong> <span id="coords">---</span></div>
  <div><strong>Altitud:</strong> <span id="alt">---</span> m</div>
  <div><strong>Velocidad:</strong> <span id="spd">---</span> km/h</div>
  <div><strong>Potencia:</strong>  <span id="throttle">---</span>%</div>
  <div><strong>Pitch:</strong> <span id="pitch">---</span>Â°</div>
  <div><strong>Yaw:</strong> <span id="yaw">---</span>Â°</div>
  <div><strong>Roll:</strong> <span id="roll">---</span>Â°</div>
  <div>AoA: <span id="aoa">0.0</span>Â°</div>
  <div>Roll rate: <span id="rollRate">0.0</span>Â°/s</div>
  <div>Pitch rate: <span id="pitchRate">0.0</span>Â°/s</div>
  <div>Yaw rate: <span id="yawRate">0.0</span>Â°/s</div>
  <div>G-load: <span id="gLoad">0.00 g</span></div>
</div>

  <!-- â”€â”€â”€ Controles mÃ³viles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="mobileControls" style="position:fixed; bottom:10px; right:10px; display:none; flex-direction:column; align-items:center; gap:10px; z-index:1000;">
    <button id="btnResetGyro" title="Reset Gyro">
		<i class="material-icons">refresh</i>
    </button>
	<button id="btnShoot" title="Disparar" style="background-color: yellow;">
		<i class="material-icons">bolt</i>
	</button>
    <button id="btnFullscreen" title="Toggle Fullscreen">
		<i class="material-icons">fullscreen</i>
    </button>
	<input type="range" id="throttleSlider" min="0" max="100" value="0" style="
    position: fixed;
    top: 90px;
    width: 50vh;
    transform: rotate(270deg);
    display: block;
    z-index: 1000;
	"/>
  </div>  

<script>
	(async function main() {
	  // 0. Variables globales de fÃ­sica y cÃ¡mara:
	  let verticalSpeed = 0;
	  const gravity = 9.8;
	  const liftFactor = 20;
	  const dragFactor = 0.1;
	  const activeSmokeSystems = [];

	  // Ãngulos y radio de Ã³rbita:
	  let orbitAngles = { yaw: -Math.PI / 2, pitch: 0.2 }; // vista inicial detrÃ¡s del aviÃ³n
	  const orbitRadius = 25;
	  let isDragging = false;
	  let dragStart = { x: 0, y: 0 };

		// 1. Crear Cesium Viewer:
		Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiYTQ0YWUyYi0wYjcwLTQ3NDEtYmEzMS1kZDJlYzhkNTkyMzgiLCJpZCI6MzA5MDg4LCJpYXQiOjE3NDkwMjU5NDh9.vtAd5T0-iIYfa8YbSDhK1HEUeOgqR3Whk4OAehbKZ3w'; // Reemplaza con tu token real
		const viewer = new Cesium.Viewer('cesiumContainer', {
		  terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(1),
		  animation: false,
		  timeline: false,
		  baseLayerPicker: false,
		  geocoder: false,
		  homeButton: false,
		  infoBox: false,
		  sceneModePicker: false,
		  selectionIndicator: false,
		  navigationHelpButton: false,
		  navigationInstructionsInitiallyVisible: false,
		  fullscreenButton: false,
		  shadows: true,
		  shouldAnimate: true,
		});

		// AÃ±adir edificios OSM:
		const osmBuildings = await Cesium.createOsmBuildingsAsync();
		viewer.scene.primitives.add(osmBuildings);

		// 2. Desactivar controles por defecto de Cesium:
		viewer.scene.screenSpaceCameraController.enableRotate = false;
		viewer.scene.screenSpaceCameraController.enableTranslate = false;
		viewer.scene.screenSpaceCameraController.enableZoom = false;
		viewer.scene.screenSpaceCameraController.enableTilt = false;
		viewer.scene.screenSpaceCameraController.enableLook = false;
		
		// â”€â”€â”€ Detectar si es mÃ³vil o tablet â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const isMobileDevice = /Mobi|Android|iPhone|iPad|Tablet/.test(navigator.userAgent);
		// â”€â”€â”€ Mostrar controles en mÃ³viles/tablets â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		if (isMobileDevice) {
			document.getElementById('mobileControls').style.display = 'flex';
			document.getElementById('throttleSlider').style.display = 'block';
		}
		
		// 3. Usar ScreenSpaceEventHandler para capturar arrastre de ratÃ³n:
		  const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

		  handler.setInputAction((evt) => {
			isDragging = true;
			dragStart.x = evt.position.x;
			dragStart.y = evt.position.y;
		  }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

		  handler.setInputAction(() => {
			isDragging = false;
		  }, Cesium.ScreenSpaceEventType.LEFT_UP);

		  handler.setInputAction((evt) => {
			if (!isDragging) return;
			const dx = evt.startPosition.x - evt.endPosition.x;
			const dy = evt.startPosition.y - evt.endPosition.y;
			orbitAngles.yaw -= dx * 0.005;
			orbitAngles.pitch += dy * 0.005;
			orbitAngles.pitch = Cesium.Math.clamp(orbitAngles.pitch, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
			// Actualizar dragStart para la siguiente llamada:
			dragStart.x = evt.endPosition.x;
			dragStart.y = evt.endPosition.y;
		  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

		// 4. Variables de estado del aviÃ³n y controles:
		let aircraft, position, orientationQuat;
		let forwardSpeed = 0;      // velocidad actual de avance (m/s)
		let throttle = 0;          // potencia del motor [0 .. 1]
		const maxThrust = 7500;    // Empuje mÃ¡ximo (puedes ajustar sobre la marcha)
		const dragCoefficient = 0.02; // Coeficiente de resistencia aerodinÃ¡mica
		// â”€â”€â”€ ParÃ¡metros aerodinÃ¡micos â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const rho0 = 1.225;       // kg/mÂ³ al nivel del mar
		const wingArea = 50;      // mÂ²
		const wingSpan = 15;      // m (ancho de ala, ajÃºstalo a tu modelo)
		const CL0 = 0.2;          // coef. de lift a AoA = 0
		const CL_ALPHA = 5.7;     // pendiente de coef. lift (por radian)
		const mass = 18300;        // kg
		const fuselageArea   = 10;    // mÂ² (Ã¡rea frontal del fuselaje, ajÃºstalo a tu modelo)
		const CD0Fuselaje    = 0.025; // coeficiente de drag parÃ¡sito del fuselaje

	 	const keys = {};
	 
		//window.addEventListener('keydown', (e) => (keys[e.code] = true));
		//window.addEventListener('keyup', (e) => (keys[e.code] = false));


		// 5. FunciÃ³n para crear el modelo principal (F-22):
		async function createModel() {
		  viewer.entities.removeAll();
		  // 1. Definir posiciÃ³n inicial (tal cual ya lo tienes)
			position = Cesium.Cartesian3.fromDegrees(-3.7038, 40.4168, 5000);

			// 2. Crear un HeadingPitchRoll con pitch = 0, roll = 0, y el heading que tÃº elijas.
			//    AquÃ­ usamos heading = 0 (hacia Norte). Si quisieras que mire Este, usa 90Â°.
			const initialHeading = 0; // en grados
			const hpr = new Cesium.HeadingPitchRoll(
			  Cesium.Math.toRadians(initialHeading),
			  0,    // pitch = 0 â†’ plano al terreno
			  0     // roll = 0 â†’ sin rotaciÃ³n lateral
			);

			// 3. Calcular el cuaterniÃ³n â€œhorizontalâ€ sobre la superficie local
			orientationQuat = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

			// 4. Â¡Crear el modelo!
			aircraft = viewer.entities.add({
			  name: 'F-22 Raptor',
			  position: new Cesium.CallbackProperty(() => position, false),
			  orientation: new Cesium.CallbackProperty(() => orientationQuat, false),
			  model: {
				uri: 'models/simulador/f22_model.glb',
				minimumPixelSize: 64,
				maximumScale: 10000,
				scale: 1,
			  },
			});
		}
		await createModel();
		
		//-------- Logica de disparo -------------
		// 6. FunciÃ³n para los proyectiles:
		
		/**
		* Comprueba si una posiciÃ³n estÃ¡ sobre un edificio OSM.
		* Hace un raycast descendente desde 1 m sobre la posiciÃ³n.
		*/
		function detectOSMAt(position) {
		// Convertir a coordenadas de pantalla
		const screenPos = viewer.scene.cartesianToCanvasCoordinates(position);
		if (!Cesium.defined(screenPos)) {
			return false;
		}
		// Drill pick para obtener features bajo ese pÃ­xel
		const picks = viewer.scene.drillPick(screenPos);
		for (const pick of picks) {
			// Si es un feature de 3D Tiles (OSM Buildings), devolvemos true
			if (pick instanceof Cesium.Cesium3DTileFeature) {
			return true;
			}
		}
		return false;
		}
		
		/**
		* Maneja el impacto de un proyectil en 'position'.
		* Decide terreno vs edificio, genera humo/incendio y elimina la entidad.
		*/
		function handleImpact(entity, position) {
		// Detectamos si cayÃ³ sobre un edificio OSM
		const isOSM = detectOSMAt(position);
		if (isOSM) {
			console.log("Â¡Impacto en edificio OSM detectado!");
		}
		// Creamos humo o incendio en la posiciÃ³n exacta
		createSmokeAt(position, isOSM);
		// Eliminamos la bala tras breve retardo para ver su Ãºltima posiciÃ³n
		setTimeout(() => viewer.entities.remove(entity), 50);
		}
		
		
		
		const projectiles = [];

		function shootProjectile() {
			if (!position || !orientationQuat) return;

			  // 6.1. Obtenemos el eje â€œforwardâ€ del aviÃ³n (eje X local)
			  const rotMat = Cesium.Matrix3.fromQuaternion(orientationQuat);
				const forward = Cesium.Matrix3.multiplyByVector(
				  rotMat,
				  Cesium.Cartesian3.UNIT_X,
				  new Cesium.Cartesian3()
				);

			 // 6.2. Offset para que el proyectil salga justo del morro (5 m delante del centro)
const muzzleOffset = Cesium.Cartesian3.multiplyByScalar(
  forward,
  2.5, // distancia reducida para acercarlo al morro
  new Cesium.Cartesian3()
);
// PosiciÃ³n base tras el offset frontal
const muzzlePosition = Cesium.Cartesian3.add(
  position,
  muzzleOffset,
  new Cesium.Cartesian3()
);
// Desplazamiento vertical: bajar 2 m en eje local 'up'
const up = Cesium.Matrix3.multiplyByVector(
  rotMat,
  Cesium.Cartesian3.UNIT_Z,
  new Cesium.Cartesian3()
);
const downOffset = Cesium.Cartesian3.multiplyByScalar(
  up,
  -1, // metros a bajar
  new Cesium.Cartesian3()
);
// PosiciÃ³n inicial final del proyectil
const initialPosition = Cesium.Cartesian3.add(
  muzzlePosition,
  downOffset,
  new Cesium.Cartesian3()
);

			// 6.3. Velocidad inicial de la bala: hereda forwardSpeed del aviÃ³n
			// 1) Velocidad heredada del aviÃ³n
			const planeVelocity = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  forwardSpeed,
			  new Cesium.Cartesian3()
			);

			// 2) Velocidad de boca de la M61 Vulcan (~1030 m/s) = (~3708 km/h)
			const muzzleVelocity = 3708/2; // km/h real
			const pushExtra = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  muzzleVelocity,
			  new Cesium.Cartesian3()
			);

			// 3) Velocidad inicial = aviÃ³n + salida del caÃ±Ã³n
			const initialVelocity = Cesium.Cartesian3.add(
			  planeVelocity,
			  pushExtra,
			  new Cesium.Cartesian3()
			);

			  // 6.4. Creamos la entidad del proyectil
			  let currentPosition = Cesium.Cartesian3.clone(initialPosition);
			  const entity = viewer.entities.add({
					position: new Cesium.CallbackProperty(() => currentPosition, false),
					orientation: new Cesium.CallbackProperty(() => {
					  // Orientar el modelo de la bala para que "mire" hacia adelante
					  return Cesium.Transforms.headingPitchRollQuaternion(
						currentPosition,
						new Cesium.HeadingPitchRoll(0, 0, 0)
					  );
					}, false),
					model: {
					  uri: 'models/simulador/silver_projectile.glb',
					  scale: 0.25,
					  minimumPixelSize: 1
					}
			  });

			// 6.5. AÃ±adimos al array para actualizar cada frame
			projectiles.push({
				entity,
				velocity: Cesium.Cartesian3.clone(initialVelocity),
				// Variables para gestionar el impacto
				impacted: false,
				impactTimer: 0,
				update: function(deltaTime) {
					// 1) Actualizamos velocidad y calculamos nueva posiciÃ³n
					this.velocity.z -= gravity * deltaTime;
					const prevPos = Cesium.Cartesian3.clone(currentPosition);
					const step    = Cesium.Cartesian3.multiplyByScalar(
						this.velocity,
						deltaTime,
						new Cesium.Cartesian3()
					);
					currentPosition = Cesium.Cartesian3.add(prevPos, step, new Cesium.Cartesian3());
					
					// distancia recorrida desde el disparo
					const traveled = Cesium.Cartesian3.distance(currentPosition, initialPosition);

					  const carto = Cesium.Cartographic.fromCartesian(currentPosition);
					  const terrainHeight = viewer.scene.globe.getHeight(carto);

					// DetecciÃ³n de choque contra terreno
					const hitTerrain = terrainHeight !== undefined && carto.height <= terrainHeight + 1;
					// Si cayÃ³ contra el suelo (edificio o terreno), manejamos impacto
					if (hitTerrain && !this.impacted) {
					  this.impacted = true;
					  handleImpact(entity, currentPosition);
					  return false;
					}

					// Si ya impactÃ³, contabiliza el tiempo y elimina al siguiente update
					if (this.impacted) {
					this.impactTimer += deltaTime;
						if (this.impactTimer > 0) {
							viewer.entities.remove(entity);
							return false;
						}
					// Deja que se dibuje este frame (para mostrar la posiciÃ³n final)
					}

					// 5) fuera de rango mÃ¡ximo
					  if (Cesium.Cartesian3.distance(currentPosition, initialPosition) > 20000) {
						viewer.entities.remove(entity);
						return false;
					  }

					return true;
				}
			});
		}

		// 7. FunciÃ³n para crear los efectos de los proyectiles	
		/**
		 * @param {Cesium.Cartesian3} position â€” punto de impacto
		 * @param {boolean} isBurn â€” true si es incendio (OSM), false si es humo normal (terreno)
		 */
		function createSmokeAt(position, isBurn = false) {
			const carto = Cesium.Cartographic.fromCartesian(position);
			const terrainHeight = viewer.scene.globe.getHeight(carto);
			const adjustedPosition = Cesium.Cartesian3.fromRadians(
				carto.longitude,
				carto.latitude,
				terrainHeight + 1.0 // justo sobre el suelo
			);
			
			const smokeParticles = [];
			
			if (isBurn) {
				// Incendio estÃ¡tico con fade-in y fade-out
				const entityLifetime = 120;
				const fadeInTime = 5;
				const fadeOutTime = 20;
			
				// Creamos entidad Ãºnica
				const burnEntity = {
				position: adjustedPosition,
				age: 0,
				lifespan: entityLifetime,
				modelEntity: null
				};
			
				burnEntity.modelEntity = viewer.entities.add({
				position: adjustedPosition,
				// Girar 90Â° alrededor del eje Z (roll) para que el modelo quede vertical
				orientation: Cesium.Transforms.headingPitchRollQuaternion(
					adjustedPosition,
					new Cesium.HeadingPitchRoll(
						0,                           // heading
						Cesium.Math.toRadians(90),                           // pitch
						0    // roll = 90Â°
					)
				),
				model: {
					uri: 'models/simulador/incendio.glb',
					scale: new Cesium.CallbackProperty(() => {
						const age = burnEntity.age;
						const t = Math.min(Math.max(age / entityLifetime, 0), 1);
						return Cesium.Math.lerp(0.5, 5.0, t);
					}, false),
					minimumPixelSize: 10,
					// Color dinÃ¡mico para fade
					color: new Cesium.CallbackProperty(() => {
						const age = burnEntity.age;
						let alpha = 1.0;
						if (age < fadeInTime) {
							alpha = age / fadeInTime;
						} else if (age > entityLifetime - fadeOutTime) {
							alpha = (entityLifetime - age) / fadeOutTime;
						}
						return Cesium.Color.BLACK.withAlpha(alpha);
					}, false),
					colorBlendMode: Cesium.ColorBlendMode.MIX,
					colorBlendAmount: 1.0
				}
				});
			
				// ActualizaciÃ³n del incendio
				burnEntity.update = (deltaTime) => {
				burnEntity.age += deltaTime;
				if (burnEntity.age >= burnEntity.lifespan) {
					viewer.entities.remove(burnEntity.modelEntity);
					return false;
				}
				return true;
				};
			
				activeSmokeSystems.push([burnEntity]);
			
			} else {
				// Humo normal como antes
				const maxParticles = 20;
				const particleUri = 'models/simulador/smoke_particle.glb';
				const baseLifespan = 3;
			
				for (let i = 0; i < maxParticles; i++) {
				const offset = Cesium.Cartesian3.fromElements(
					(Math.random() - 0.5) * 10,
					(Math.random() - 0.5) * 10,
					Math.random() * 10
				);
			
				const particlePosition = Cesium.Cartesian3.add(
					adjustedPosition,
					offset,
					new Cesium.Cartesian3()
				);
			
				const particle = {
					position: particlePosition,
					velocity: new Cesium.Cartesian3(
					(Math.random() - 0.5) * 1.5,
					(Math.random() - 0.5) * 1.5,
					1 + Math.random() * 3
					),
					age: 0,
					lifespan: baseLifespan + Math.random() * 2,
					scale: 1 + Math.random() * 0.5,
					modelEntity: null
				};
			
				particle.modelEntity = viewer.entities.add({
					position: new Cesium.CallbackProperty(() => particle.position, false),
					orientation: new Cesium.CallbackProperty(() => {
					return Cesium.Transforms.headingPitchRollQuaternion(
						particle.position,
						new Cesium.HeadingPitchRoll(0, 0, 0)
					);
					}, false),
					model: {
					uri: particleUri,
					scale: new Cesium.CallbackProperty(() => {
						const growth = 1 + particle.age * 0.2;
						return particle.scale * growth;
					}, false),
					minimumPixelSize: 10,
					color: Cesium.Color.WHITE.withAlpha(0.5),
					colorBlendMode: Cesium.ColorBlendMode.MIX,
					colorBlendAmount: 0.8
					}
				});
			
				particle.update = (deltaTime) => {
					particle.age += deltaTime;
					if (particle.age >= particle.lifespan) {
					viewer.entities.remove(particle.modelEntity);
					return false;
					}
					const deltaMove = Cesium.Cartesian3.multiplyByScalar(
					particle.velocity,
					deltaTime,
					new Cesium.Cartesian3()
					);
					particle.position = Cesium.Cartesian3.add(
					particle.position,
					deltaMove,
					new Cesium.Cartesian3()
					);
					return true;
				};
			
				smokeParticles.push(particle);
				}
			
				activeSmokeSystems.push(smokeParticles);
			}
		}

		// 8. Contoles 
		
		window.addEventListener("keydown", (e) => {
		  keys[e.code] = true;
		  if (e.code === "Space") shootProjectile();
		  if (e.code === "Enter") {
			autoLevel = true;
		  }
		  // Si el piloto vuelve a dar una orden manual, cancelamos el auto-nivelado
		  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","KeyQ","KeyE"].includes(e.code)) {
			autoLevel = false;
		  }
		});
		
		  // Listener para liberaciÃ³n de teclas: limpiar el flag
		  window.addEventListener("keyup", (e) => {
			if (keys[e.code]) {
			  keys[e.code] = false;
			}
		  });
		
		// â”€â”€â”€ Tensor de inercia (valores de ejemplo, en kgÂ·mÂ²) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const I = Cesium.Matrix3.fromArray([
		  1.2e5,   0,      0,
			0,   9.0e4,   0,
			0,     0,   1.5e5
		]);
		const Iinv = Cesium.Matrix3.inverse(I, new Cesium.Matrix3());

		// Superficies de control y brazos de palanca (mÂ² y m)
		const S_aileron   = 4.0,  l_aileron   = 5.0;
		const S_elevator  = 3.5,  l_elevator  = 7.0;
		const S_rudder    = 2.0,  l_rudder    = 6.0;
		
		// â”€â”€â”€ ParÃ¡metros para pitching moment de fuselaje â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const Cm_ALPHA      = 0.05;      // coef. moment pitching por rad
		const l_fuselage    = 8.0;       // brazo de palanca fuselaje (m)

		// Coeficiente de damping rotacional
		const C_d_rot = 0.5;
		
		// â”€â”€â”€ ParÃ¡metros de motor con spool-up/spool-down â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		// Empuje actual del motor (N)
		let thrustCurrent = 0.0;

		// Estado de la velocidad angular en el cuerpo
		let Ï‰ = new Cesium.Cartesian3(0, 0, 0);
		// â”€â”€â”€ LÃ­mites de velocidad angular (rad/s) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const maxRollRate  = Cesium.Math.toRadians(90);   // Â±90Â°/s
		const maxPitchRate = Cesium.Math.toRadians(60);   // Â±60Â°/s
		const maxYawRate   = Cesium.Math.toRadians(45);   // Â±45Â°/s
		
		// â”€â”€â”€ Estado de deflexiÃ³n actual de superficies (rad) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		let Î´a_current = 0.0, Î´e_current = 0.0, Î´r_current = 0.0;
		// MÃ¡xima velocidad de deflexiÃ³n: 30Â° por segundo
		const maxDeflectionRate = Cesium.Math.toRadians(30);
				
		// Flag para auto-nivelado
		let autoLevel = false;
		
		// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		
		// â”€â”€â”€ Variables para giroscopio mÃ³vil â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		let useGyro = false;
		let gyroOffset = { alpha: 0, beta: 0, gamma: 0 };
		let gyroAngles = { roll: 0, pitch: 0, yaw: 0 };
		// Almacenamos el Ãºltimo evento para el reset
		let lastEvent = { alpha: 0, beta: 0, gamma: 0 };

		// Detectar soporte y activar giroscopio
		if (window.DeviceOrientationEvent) {
			window.addEventListener('deviceorientation', (e) => {
				if (e.alpha === null) {
				return;
				}
				// Guardamos el evento para poder resetear offset mÃ¡s tarde
				lastEvent.alpha = e.alpha;
				lastEvent.beta  = e.beta;
				lastEvent.gamma = e.gamma;
		
				useGyro = true;
				document.getElementById('mobileControls').style.display = 'flex';
				document.getElementById('throttleSlider').style.display = 'block';
		
				// Calcular diferencia respecto al offset
				const a = e.alpha - gyroOffset.alpha;
				const b = e.beta  - gyroOffset.beta;
				const g = e.gamma - gyroOffset.gamma;
		
				// Factores de sensibilidad
				const sensitivityYaw   = 0.6;
				const sensitivityPitch = 0.4;
				const sensitivityRoll  = 0.4;
		
				// Mapear a radianes y ajustar signos para Cesium
				gyroAngles.yaw   = Cesium.Math.toRadians(a * sensitivityYaw);   // YAW â† alpha
				gyroAngles.pitch = Cesium.Math.toRadians(g * sensitivityPitch); // PITCH â† -beta
				gyroAngles.roll  = Cesium.Math.toRadians(-b * sensitivityRoll);  // ROLL â† gamma
			});

			// BotÃ³n reset gyro		
			document.getElementById('btnResetGyro').addEventListener('click', () => {
				// Resetear offset de giroscopio
				gyroOffset.alpha = lastEvent.alpha;
				gyroOffset.beta  = lastEvent.beta;
				gyroOffset.gamma = lastEvent.gamma;

				// Reiniciar velocidades angulares
				Ï‰ = new Cesium.Cartesian3(0, 0, 0);

				// Resetear deflexiones de superficies
				Î´a_current = 0;
				Î´e_current = 0;
				Î´r_current = 0;

				// Activar de nuevo
				useGyro = true;
				console.log('ðŸ”„ Giroscopio y orientaciÃ³n reiniciados');
			});
		}

		// BotÃ³n fullscreen
		document.getElementById('btnFullscreen').addEventListener('click', () => {
			const el = document.documentElement;
			if (!document.fullscreenElement) {
				el.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		});

		// Slider de throttle
		const slider = document.getElementById('throttleSlider');
		slider.addEventListener('input', () => {
			throttle = slider.value / 100;
		});
		
		// BotÃ³n de disparo en mÃ³viles
		document.getElementById('btnShoot').addEventListener('click', () => {
			shootProjectile();
		});
		
		//--------------------------------------------------------------------------------------

		//10. Control de escenas
		
		let lastTime = performance.now();
		// Para cÃ¡lculo de cargas G
		let prevPlaneVelocity = new Cesium.Cartesian3(0, 0, 0);

		viewer.scene.postRender.addEventListener(() => {
		  const now = performance.now();
		  const deltaTime = (now - lastTime) / 1000;
		  lastTime = now;
		  if (!position || !orientationQuat) return;

		  // â”€â”€â”€ 10.1 Recalcular forward / up / surfaceNormal / carto / hpr â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const rotMatrix     = Cesium.Matrix3.fromQuaternion(orientationQuat);
		const forward       = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_X, new Cesium.Cartesian3());
		const right         = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Y, new Cesium.Cartesian3());
		const up            = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
		  const carto     = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
		  const hpr       = Cesium.HeadingPitchRoll.fromQuaternion(orientationQuat);
		  const surfaceNormal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(position, new Cesium.Cartesian3());

		  // â”€â”€â”€ 10.2 CÃ¡lculo de planeVelocity (antes de lift) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  const forwardVelocity  = Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed, new Cesium.Cartesian3());
		  const verticalVelocity = Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed, new Cesium.Cartesian3());
		  const planeVelocity    = Cesium.Cartesian3.add(forwardVelocity, verticalVelocity, new Cesium.Cartesian3());

		  // â”€â”€â”€ 10.3 SustentaciÃ³n (lift) y drag aerodinÃ¡mico realista â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  const V = Cesium.Cartesian3.magnitude(planeVelocity);
		  let liftForce = 0;
		  let dragForceScalar = 0;
		  // Ãngulo de ataque (radianes)
		  let aoa = 0;		  
		  
		  let liftDir = new Cesium.Cartesian3(0, 0, 0);

		  if (V > 0.1) {
			// a) calculamos AoA
			const flightDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(planeVelocity), new Cesium.Cartesian3());
			let cosAoA = Cesium.Math.clamp(Cesium.Cartesian3.dot(flightDir, forward), -1.0, 1.0);
			aoa = Math.acos(cosAoA);
			
			// â”€â”€â”€ Modelo de stall real â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
			const stallLimit = Cesium.Math.toRadians(15);
			const maxAoA     = Cesium.Math.toRadians(45); // Ã¡ngulo donde CL cae a cero
			
			// b) coeficiente de lift: lineal hasta stall, luego cae lineal hasta cero
			let CL;
			if (aoa <= stallLimit) {
			CL = CL_ALPHA * aoa;
			} else {
			const CLmax  = CL_ALPHA * stallLimit;
			const excess = aoa - stallLimit;
			CL = CLmax * Math.max(0, 1 - excess / (maxAoA - stallLimit));
			}
			
			// c) coeficiente inducido aproximado: CDi = CLÂ² / (Ï€Â·AR)
			const AR = (wingSpan || Math.sqrt(wingArea)) ? wingSpan : wingArea;
			const CDi = (CL * CL) / (Math.PI * (AR || wingArea));

			// d) densidad ISA simplificado
			const rho = rho0 * Math.exp(-carto.height / 8500);
			
			// e) presiÃ³n dinÃ¡mica
			const qd = 0.5 * rho * V * V;
			
			 // f) fuerzas de lift y drag con drag extra en stall
			 liftForce = qd * wingArea * CL;
			 // g) lift adicional generado por el fuselaje (traslacional, no rotacional)
			 //   usamos Cm_ALPHA como coeficiente de lift por radian para el fuselaje
			 const CL_fuselaje = Cm_ALPHA * aoa;
			 liftForce += qd * fuselageArea * CL_fuselaje;
			 
			// drag base: inducido + parÃ¡sito de fuselaje
			const baseCD = CDi + CD0Fuselaje * (fuselageArea / wingArea);
			// drag adicional post-stall
			let stallDrag = 0;
			if (aoa > stallLimit) {
				const excess = aoa - stallLimit;
				stallDrag = 2.0 * (excess / (maxAoA - stallLimit)); // ajusta magnitud a gusto
			}
			dragForceScalar = qd * wingArea * (baseCD + stallDrag);

			// g) direcciÃ³n de lift
			const tmp = new Cesium.Cartesian3();
			Cesium.Cartesian3.cross(planeVelocity, right, tmp);
			Cesium.Cartesian3.cross(tmp, planeVelocity, tmp);
			if (Cesium.Cartesian3.magnitude(tmp) > 1e-3) {
			  Cesium.Cartesian3.normalize(tmp, tmp);
			}
			liftDir = tmp;

			// DinÃ¡mica rotacional fÃ­sica (Â¡aquÃ­ aplicamos los torques!) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
			updateRotation(deltaTime, qd);
		  }

		  // â”€â”€â”€ 10.4 Actualizar verticalSpeed con lift, gravedad y damping â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  verticalSpeed -= gravity * deltaTime;
		  if (liftForce !== 0) {
			verticalSpeed += (liftForce / mass) * deltaTime;
		  }
		  verticalSpeed *= (1 - dragFactor * deltaTime);
		  verticalSpeed = Math.max(-300, Math.min(verticalSpeed, 300));

		  // â”€â”€â”€ 10.5 Drag aerodinÃ¡mico horizontal â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  let dragDir = new Cesium.Cartesian3(0, 0, 0);
		  if (V > 0.1) {
			dragDir = Cesium.Cartesian3.clone(planeVelocity);
			Cesium.Cartesian3.normalize(dragDir, dragDir);
			Cesium.Cartesian3.negate(dragDir, dragDir);
		  }
		  const dragAcc = dragForceScalar / mass;
		  const dragStep = Cesium.Cartesian3.multiplyByScalar(dragDir, dragAcc * deltaTime, new Cesium.Cartesian3());

		  const newVel = Cesium.Cartesian3.add(planeVelocity, dragStep, new Cesium.Cartesian3());
		  forwardSpeed = Math.max(0, Cesium.Cartesian3.dot(newVel, forward));

		  // â”€â”€â”€ 10.6 DinÃ¡mica de avance con throttle y dragCoefficient simple â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  const thrust = throttle * maxThrust;
		  const simpleDrag = dragCoefficient * forwardSpeed * forwardSpeed;
		  forwardSpeed += (thrust - simpleDrag) * deltaTime;
		  forwardSpeed = Math.max(0, forwardSpeed);

		  // â”€â”€â”€ 10.7 Desplazar posiciÃ³n del aviÃ³n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  const stepForward  = Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed * deltaTime, new Cesium.Cartesian3());
		  const gravityStep  = Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed * deltaTime, new Cesium.Cartesian3());
		  position = Cesium.Cartesian3.add(position, Cesium.Cartesian3.add(stepForward, gravityStep, new Cesium.Cartesian3()), new Cesium.Cartesian3());

		  // â”€â”€â”€ 10.8 Ã“rbita de la cÃ¡mara alrededor del aviÃ³n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  const center = Cesium.Cartesian3.clone(position);
		  const localOffset = new Cesium.Cartesian3(
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.sin(orbitAngles.yaw),
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.cos(orbitAngles.yaw),
			orbitRadius * Math.sin(orbitAngles.pitch)
		  );
		  const offset = Cesium.Matrix3.multiplyByVector(rotMatrix, localOffset, new Cesium.Cartesian3());
		  const cameraPos = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());
		  const dir       = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()), new Cesium.Cartesian3());
		  const upVec     = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
		  viewer.scene.camera.setView({
			destination: cameraPos,
			orientation: { direction: dir, up: upVec }
		  });

		  // â”€â”€â”€ 10.9 LÃ­mite de altitud â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  if (carto.height > 15000 && verticalSpeed > 0) {
			verticalSpeed = 0;
		  }

		  // â”€â”€â”€ 10.10 Ajuste de throttle con +/- â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  const throttleStep = 0.5 * deltaTime;
		  if (keys['Equal'] || keys['NumpadAdd'])    throttle = Math.min(throttle + throttleStep, 1.0);
		  if (keys['Minus'] || keys['NumpadSubtract']) throttle = Math.max(throttle - throttleStep, 0.0);

		  // â”€â”€â”€ 10.11 Actualizar proyectiles â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  for (let i = projectiles.length - 1; i >= 0; i--) {
		    const proj = projectiles[i];
		    const alive = proj.update(deltaTime);
		    if (!alive) {
		      projectiles.splice(i, 1);
		    }
		  }
		  
		  // â”€â”€â”€ 10.12 Efectos de humo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  for (let s = activeSmokeSystems.length - 1; s >= 0; s--) {
		    const system = activeSmokeSystems[s];
		    for (let i = system.length - 1; i >= 0; i--) {
		      if (!system[i].update(deltaTime)) {
		        system.splice(i, 1);
		      }
		    }
		    if (system.length === 0) activeSmokeSystems.splice(s, 1);
		  }
		  
		// â”€â”€â”€ DetecciÃ³n de terreno y colisiÃ³n â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		const terrainHeight = viewer.scene.globe.getHeight(carto);
		const margin = 1.0;
		
		if (terrainHeight !== undefined && carto.height <= terrainHeight + margin) {
			if (verticalSpeed < -10) {
			// ColisiÃ³n brusca
			forwardSpeed = 0;
			verticalSpeed = 0;
		
			position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight + margin);
			alert("Â¡ColisiÃ³n grave! SimulaciÃ³n detenida.");
		
			viewer.scene.postRender.removeEventListener(arguments.callee);
			} else {
			// Aterrizaje suave o rebote leve
			forwardSpeed *= 0.5;
			verticalSpeed *= -0.3;
		
			position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight + margin);
			}
		}

		  // â”€â”€â”€ 10.13 HUD â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  // Recalculamos planeVelocity con la nueva forwardSpeed y verticalSpeed
		  const newForwardVel = Cesium.Cartesian3.multiplyByScalar(
		    forward,
		    forwardSpeed,
		    new Cesium.Cartesian3()
		  );
		  const newVerticalVel = Cesium.Cartesian3.multiplyByScalar(
		    surfaceNormal,
		    verticalSpeed,
		    new Cesium.Cartesian3()
		  );
		  const newPlaneVel = Cesium.Cartesian3.add(newForwardVel, newVerticalVel, new Cesium.Cartesian3());
		  const totalSpeed = Cesium.Cartesian3.magnitude(newPlaneVel);

		  const lat = Cesium.Math.toDegrees(carto.latitude).toFixed(5);
		  const lon = Cesium.Math.toDegrees(carto.longitude).toFixed(5);
		  const altVal = carto.height.toFixed(1);
		  const pitchDeg = Cesium.Math.toDegrees(hpr.pitch).toFixed(1);
		  const yawDeg   = Cesium.Math.toDegrees(hpr.heading).toFixed(1);
		  const rollDeg  = Cesium.Math.toDegrees(hpr.roll).toFixed(1);

		  // â”€â”€â”€ Nuevos indicadores: velocidades angulares y AoA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  // Ï‰ estÃ¡ en rad/s; convertir a deg/s
		  const rollRateDeg  = Cesium.Math.toDegrees(Ï‰.x).toFixed(1);
		  const pitchRateDeg = Cesium.Math.toDegrees(Ï‰.y).toFixed(1);
		  const yawRateDeg   = Cesium.Math.toDegrees(Ï‰.z).toFixed(1);
		  document.getElementById("rollRate").textContent  = rollRateDeg;
		  document.getElementById("pitchRate").textContent = pitchRateDeg;
		  document.getElementById("yawRate").textContent   = yawRateDeg;

		  // AoA en grados
		  document.getElementById("aoa").textContent = Cesium.Math.toDegrees(aoa).toFixed(1);

		  document.getElementById("coords").textContent   = `${lat}, ${lon}`;
		  document.getElementById("alt").textContent      = altVal;
		  document.getElementById("spd").textContent      = (totalSpeed * 3.6).toFixed(0);
		  document.getElementById("throttle").textContent = (throttle * 100).toFixed(0);
		  document.getElementById("pitch").textContent    = pitchDeg;
		  document.getElementById("yaw").textContent      = yawDeg;
		  document.getElementById("roll").textContent     = rollDeg;
		  
		  // â”€â”€â”€ Cargas G â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
		  // aceleraciÃ³n = (v - v_prev)/dt
		  const accel = Cesium.Cartesian3.subtract(planeVelocity, prevPlaneVelocity, new Cesium.Cartesian3());
		  Cesium.Cartesian3.divideByScalar(accel, deltaTime, accel);
		  // vector gravedad en NED (0,0,-g)
		  const gravVec = new Cesium.Cartesian3(0, 0, -gravity);
		  // aceleraciÃ³n total
		  const totalAccel = Cesium.Cartesian3.add(accel, gravVec, new Cesium.Cartesian3());
		  const gLoad = (Cesium.Cartesian3.magnitude(totalAccel) / gravity).toFixed(2);
		  document.getElementById("gLoad").textContent = gLoad + " g";
		  // actualizar prevPlaneVelocity
		  prevPlaneVelocity = Cesium.Cartesian3.clone(planeVelocity);

		});
		
		/**
		 * Recalcula todos los vectores bÃ¡sicos y retorna el estado del frame.
		 */
		function computeFrameState() {
		  const rotMatrix     = Cesium.Matrix3.fromQuaternion(orientationQuat);
		  const forward       = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_X, new Cesium.Cartesian3());
		  const right         = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Y, new Cesium.Cartesian3());
		  const up            = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
		  const surfaceNormal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(position, new Cesium.Cartesian3());
		  const carto         = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
		  const hpr           = Cesium.HeadingPitchRoll.fromQuaternion(orientationQuat);
		  const planeVelocity = Cesium.Cartesian3.add(
			Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed, new Cesium.Cartesian3()),
			Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed, new Cesium.Cartesian3()),
			new Cesium.Cartesian3()
		  );
		  const speed      = Cesium.Cartesian3.magnitude(planeVelocity);
		  const angularVel = Cesium.Cartesian3.clone(Ï‰);
		  // IMPORTANTE: incluimos position y angularVel para updateCamera/updateHUD
		  return { rotMatrix, forward, right, up, surfaceNormal, carto, hpr, planeVelocity, speed, angularVel, position };
		}

		/**
		 * Calcula lift y drag segÃºn AoA y stall.
		 */
		function computeAerodynamics({ planeVelocity, forward, carto }) {
		  const V = Cesium.Cartesian3.magnitude(planeVelocity);
		  let aoa = 0, qd = 0, liftForce = 0, dragForce = 0;
		  const stallLimit = Cesium.Math.toRadians(15);
		  const maxAoA     = Cesium.Math.toRadians(45);
		  if (V > 0.1) {
			const flightDir = Cesium.Cartesian3.normalize(Cesium.Cartesian3.clone(planeVelocity), new Cesium.Cartesian3());
			aoa = Math.min(Math.acos(Cesium.Math.clamp(Cesium.Cartesian3.dot(flightDir, forward), -1, 1)), maxAoA);
			const rho = rho0 * Math.exp(-carto.height / 8500);
			qd = 0.5 * rho * V * V;
			let CL = aoa <= stallLimit
			  ? CL_ALPHA * aoa
			  : (CL_ALPHA * stallLimit) * Math.max(0, 1 - (aoa - stallLimit) / (maxAoA - stallLimit));
			const AR      = wingSpan || Math.sqrt(wingArea);
			const CDi     = (CL * CL) / (Math.PI * AR);
			const baseCD  = CDi + CD0Fuselaje * (fuselageArea / wingArea);
			const stallD  = aoa > stallLimit ? 2 * ((aoa - stallLimit) / (maxAoA - stallLimit)) : 0;
			liftForce = qd * wingArea * CL + qd * fuselageArea * Cm_ALPHA * aoa;
			dragForce = qd * wingArea * (baseCD + stallD);
		  }
		  return { aoa, qd, liftForce, dragForce };
		}

		/**
		 * @param {number} dt
		 * @param {Object} state
		 * @param {number} state.forward
		 * @param {number} state.surfaceNormal
		 * @param {Object} aero â€” { liftForce, dragForce, qd, aoa }
		 */
		function updatePhysics(dt, state, { liftForce, dragForce, qd, aoa }) {
		  const { forward, surfaceNormal } = state;
		  // 1) rotaciÃ³n
		  updateRotation(dt, qd, aoa);

		  // 2) vertical
		  verticalSpeed = Cesium.Math.clamp(
			verticalSpeed - gravity * dt + (liftForce / mass) * dt,
			-300, 300
		  );

		  // 3) longitudinal
		  const thrustForce   = throttle * maxThrust;
		  const parasiticDrag = dragCoefficient * forwardSpeed * forwardSpeed;
		  const totalDrag     = dragForce + parasiticDrag;
		  // convertir fuerza neta en aceleraciÃ³n
		  const accelForward  = (thrustForce - totalDrag) / mass;
		  forwardSpeed = Math.max(0, forwardSpeed + accelForward * dt);

		  // 4) posiciÃ³n
		  position = Cesium.Cartesian3.add(
			position,
			Cesium.Cartesian3.add(
			  Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed * dt,  new Cesium.Cartesian3()),
			  Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed * dt, new Cesium.Cartesian3()),
			  new Cesium.Cartesian3()
			),
			new Cesium.Cartesian3()
		  );
		}
		
		/**
		 * Actualiza la cÃ¡mara para orbitar alrededor del aviÃ³n.
		 * @param {{ rotMatrix: Cesium.Matrix3, position: Cesium.Cartesian3 }} state
		 */
		function updateCamera(state) {
		  const { rotMatrix, position } = state;

		  // Punto alrededor del que orbita la cÃ¡mara
		  const center = Cesium.Cartesian3.clone(position);

		  // Offset local en coordenadas del aviÃ³n
		  const localOffset = new Cesium.Cartesian3(
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.sin(orbitAngles.yaw),
			orbitRadius * Math.cos(orbitAngles.pitch) * Math.cos(orbitAngles.yaw),
			orbitRadius * Math.sin(orbitAngles.pitch)
		  );

		  // Transformar offset al espacio mundial
		  const offset = Cesium.Matrix3.multiplyByVector(
			rotMatrix,
			localOffset,
			new Cesium.Cartesian3()
		  );

		  // PosiciÃ³n final de la cÃ¡mara
		  const cameraPos = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());

		  // DirecciÃ³n de la cÃ¡mara (apunta al aviÃ³n)
		  const direction = Cesium.Cartesian3.normalize(
			Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
			new Cesium.Cartesian3()
		  );

		  // Vector "up" de la cÃ¡mara, alineado con el eje Z del aviÃ³n
		  const up = Cesium.Matrix3.multiplyByVector(
			rotMatrix,
			Cesium.Cartesian3.UNIT_Z,
			new Cesium.Cartesian3()
		  );

		  // Aplicar la vista
		  viewer.scene.camera.setView({
			destination: cameraPos,
			orientation: { direction, up }
		  });
		}

		/**
		 * Actualiza el HUD con los datos de vuelo.
		 *
		 * @param {Object} state
		 * @param {Cesium.Cartographic} state.carto         â€” PosiciÃ³n geogrÃ¡fica (lat, lon, alt).
		 * @param {Cesium.HeadingPitchRoll} state.hpr       â€” OrientaciÃ³n (heading, pitch, roll).
		 * @param {number} state.speed                      â€” Velocidad total (m/s).
		 * @param {Cesium.Cartesian3} state.angularVel      â€” Velocidad angular en rad/s (x=roll, y=pitch, z=yaw).
		 * @param {Object} aero
		 * @param {number} aero.aoa                         â€” Ãngulo de ataque (rad).
		 * @param {number} gLoad                             â€” Carga G instantÃ¡nea.
		 */
		function updateHUD(state, aero, gLoad) {
		  const { carto, hpr, speed, angularVel } = state;

		  // Coordenadas
		  document.getElementById("coords").textContent =
			`${Cesium.Math.toDegrees(carto.latitude).toFixed(5)}, ` +
			`${Cesium.Math.toDegrees(carto.longitude).toFixed(5)}`;

		  // Altitud
		  document.getElementById("alt").textContent = carto.height.toFixed(1);

		  // Velocidad en km/h
		  document.getElementById("spd").textContent = (speed * 3.6).toFixed(0);

		  // Throttle (%)
		  document.getElementById("throttle").textContent = Math.round(throttle * 100);

		  // Ãngulos de orientaciÃ³n
		  document.getElementById("pitch").textContent = Cesium.Math.toDegrees(hpr.pitch).toFixed(1);
		  document.getElementById("yaw").textContent   = Cesium.Math.toDegrees(hpr.heading).toFixed(1);
		  document.getElementById("roll").textContent  = Cesium.Math.toDegrees(hpr.roll).toFixed(1);

		  // Ãngulo de ataque (AoA)
		  document.getElementById("aoa").textContent = Cesium.Math.toDegrees(aero.aoa).toFixed(1);

		  // Velocidades angulares en Â°/s
		  document.getElementById("rollRate").textContent  =
			Cesium.Math.toDegrees(angularVel.x).toFixed(1);
		  document.getElementById("pitchRate").textContent =
			Cesium.Math.toDegrees(angularVel.y).toFixed(1);
		  document.getElementById("yawRate").textContent   =
			Cesium.Math.toDegrees(angularVel.z).toFixed(1);

		  // Carga G
		  document.getElementById("gLoad").textContent = gLoad.toFixed(2) + " g";
		}

		/**
		 * Actualiza todos los proyectiles disparados.
		 * @param {number} dt â€” Tiempo transcurrido en segundos desde el Ãºltimo frame.
		 */
		function updateProjectiles(dt) {
		  // Recorremos de atrÃ¡s hacia adelante para poder eliminar sin afectar Ã­ndices
		  for (let i = projectiles.length - 1; i >= 0; i--) {
			const proj = projectiles[i];
			const alive = proj.update(dt);
			if (!alive) {
			  // Si retornÃ³ false, ya no debe existir: lo quitamos del array
			  projectiles.splice(i, 1);
			}
		  }
		}

		/**
		 * Actualiza todos los sistemas de humo activos.
		 * @param {number} dt â€” Tiempo transcurrido en segundos desde el Ãºltimo frame.
		 */
		function updateSmoke(dt) {
		  // Recorremos cada sistema de partÃ­culas
		  for (let s = activeSmokeSystems.length - 1; s >= 0; s--) {
			const system = activeSmokeSystems[s];
			// Actualizamos cada partÃ­cula en el sistema
			for (let i = system.length - 1; i >= 0; i--) {
			  const particle = system[i];
			  const alive = particle.update(dt);
			  if (!alive) {
				// Si la partÃ­cula ha expirado, la eliminamos
				system.splice(i, 1);
			  }
			}
			// Si el sistema quedÃ³ vacÃ­o, lo eliminamos por completo
			if (system.length === 0) {
			  activeSmokeSystems.splice(s, 1);
			}
		  }
		}
		
		/**
	    * Integra la dinÃ¡mica rotacional de cuerpo rÃ­gido vÃ­a Newtonâ€“Euler
	    * @param {number} dt  Intervalo de tiempo en segundos
	    * @param {number} qd  Velocidad dinÃ¡mica del aire para fuerzas de control
	    */
		function updateRotation(dt, qd) {
			// 1) DeflexiÃ³n de superficies: calcular objetivo y limitar velocidad de cambio
			const maxDef = Math.PI / 18; // Â±10Â°

			// Objetivos de deflexiÃ³n manual o vÃ­a giroscopio
			let Î´a_target_manual, Î´e_target_manual, Î´r_target_manual;
			if (useGyro) {
			Î´a_target_manual = Cesium.Math.clamp(gyroAngles.roll,  -maxDef, maxDef);
			Î´e_target_manual = Cesium.Math.clamp(gyroAngles.pitch, -maxDef, maxDef);
			Î´r_target_manual = Cesium.Math.clamp(gyroAngles.yaw,   -maxDef, maxDef);
			} else {
			Î´a_target_manual = keys['ArrowLeft']  ? -maxDef : keys['ArrowRight'] ? +maxDef : 0;
			Î´e_target_manual = keys['ArrowUp']    ? +maxDef : keys['ArrowDown']  ? -maxDef : 0;
			Î´r_target_manual = keys['KeyQ']       ? +maxDef : keys['KeyE']      ? -maxDef : 0;
			}

			// Objetivos dependiendo de auto-nivelado
			let Î´a_target = Î´a_target_manual;
			let Î´e_target = Î´e_target_manual;
			let Î´r_target = Î´r_target_manual;
			if (autoLevel) {
			  const k_trim = 2.0;
			  Î´a_target = Cesium.Math.clamp(-k_trim * Ï‰.x, -maxDef, maxDef);
			  Î´e_target = Cesium.Math.clamp(-k_trim * Ï‰.y, -maxDef, maxDef);
			  Î´r_target = Cesium.Math.clamp(-k_trim * Ï‰.z, -maxDef, maxDef);
			  if (Cesium.Cartesian3.magnitude(Ï‰) < 0.1) {
				autoLevel = false;
			  }
			}

			// Suavizar hacia el objetivo con velocidad limitada
			const step = maxDeflectionRate * dt;
			Î´a_current += Cesium.Math.clamp(Î´a_target - Î´a_current, -step, step);
			Î´e_current += Cesium.Math.clamp(Î´e_target - Î´e_current, -step, step);
			Î´r_current += Cesium.Math.clamp(Î´r_target - Î´r_current, -step, step);

			// Usar las deflexiones suavizadas
			const Î´a = Î´a_current;
			const Î´e = Î´e_current;
			const Î´r = Î´r_current;

			// 2) Torques aerodinÃ¡micos de superficies: Ï„ = qd Â· S Â· Î´ Â· l
			const Ï„x =  qd * S_aileron  * Î´a * l_aileron;   // roll
			const Ï„y =  qd * S_elevator * Î´e * l_elevator;  // pitch (solo de elevador)
			const Ï„z =  qd * S_rudder   * Î´r * l_rudder;    // yaw
		 
			// 2.5) **Eliminado** momento de fuselaje: ya lo tratamos como lift en la parte de fuerzas
			const totalÏ„y = Ï„y;

			// 3) Damping rotacional lineal: Ï„_d = -C_d_rot Â· Ï‰
			const Ï„d = Cesium.Cartesian3.multiplyByScalar(Ï‰, -C_d_rot, new Cesium.Cartesian3());

			// 4) Torque neto en cuerpo (superficies + fuselaje + damping)
			const Ï„ = Cesium.Cartesian3.add(
			  new Cesium.Cartesian3(Ï„x, totalÏ„y, Ï„z),
			  Ï„d,
			  new Cesium.Cartesian3()
			);
	
			  // 5) Compute Ï‰Ã—(IÂ·Ï‰)
			  const IÏ‰ = Cesium.Matrix3.multiplyByVector(I, Ï‰, new Cesium.Cartesian3());
			  const Ï‰IÏ‰ = Cesium.Cartesian3.cross(Ï‰, IÏ‰, new Cesium.Cartesian3());

			  // 6) Î± = Iâ»Â¹Â·(Ï„ - Ï‰Ã—(IÂ·Ï‰))
			  const net = Cesium.Cartesian3.subtract(Ï„, Ï‰IÏ‰, new Cesium.Cartesian3());
			  const Î± = Cesium.Matrix3.multiplyByVector(Iinv, net, new Cesium.Cartesian3());

			   // 7) Integrar velocidad angular
			Ï‰ = Cesium.Cartesian3.add(Ï‰, Cesium.Cartesian3.multiplyByScalar(Î±, dt, new Cesium.Cartesian3()), new Cesium.Cartesian3());

			// 7.1) Limitar velocidades angulares a rangos realistas
			Ï‰.x = Cesium.Math.clamp(Ï‰.x, -maxRollRate,  maxRollRate);
			Ï‰.y = Cesium.Math.clamp(Ï‰.y, -maxPitchRate, maxPitchRate);
			Ï‰.z = Cesium.Math.clamp(Ï‰.z, -maxYawRate,   maxYawRate);

			 // 8) IntegraciÃ³n incremental de quaternion usando ejes del cuerpo
			const bodyToWorld = Cesium.Matrix3.fromQuaternion(orientationQuat);
			const axisRoll  = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(1, 0, 0), new Cesium.Cartesian3());
			const axisPitch = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(0, 1, 0), new Cesium.Cartesian3());
			const axisYaw   = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(0, 0, 1), new Cesium.Cartesian3());

			// Quaterniones incrementales alrededor de ejes locales
			const qIncRoll  = Cesium.Quaternion.fromAxisAngle(axisRoll,  Ï‰.x * dt);
			const qIncPitch = Cesium.Quaternion.fromAxisAngle(axisPitch, Ï‰.y * dt);
			const qIncYaw   = Cesium.Quaternion.fromAxisAngle(axisYaw,   Ï‰.z * dt);

			// Aplicar en orden: roll â†’ pitch â†’ yaw
			orientationQuat = Cesium.Quaternion.normalize(
			  Cesium.Quaternion.multiply(
				qIncYaw,
				Cesium.Quaternion.multiply(
				  qIncPitch,
				  Cesium.Quaternion.multiply(qIncRoll, orientationQuat, new Cesium.Quaternion()),
				  new Cesium.Quaternion()
				),
				new Cesium.Quaternion()
			  ),
			  new Cesium.Quaternion()
			);
		}

		/*
		Recursos: 	https://convert3d.org/app
					https://www.figuro.io/Designer
					https://app.sketchup.com/app?_gl=1*8i50n1*_gcl_au*NzcxNzI0MDc4LjE3NDk1NDE5NjA.
					https://www.turbosquid.com/3d-models/f16-fighter-plane-815125
					https://poly.pizza/
					https://gltf-viewer.donmccurdy.com/
		*/
	})();
</script>
</body>
</html>
