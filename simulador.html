<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Simulador de Vuelo con CesiumJS</title>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.118/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
  <style>
    html, body, #cesiumContainer {
      width: 100%;
      height: 100%;
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
  </style>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body>
<div id="cesiumContainer"></div>
<div id="hud" style="
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0, 0, 0, 0.6);
  color: white;
  font-family: monospace;
  padding: 10px;
  font-size: 14px;
  z-index: 999;
  border-radius: 5px;
">
  <div><strong>Coordenadas:</strong> <span id="coords">---</span></div>
  <div><strong>Altitud:</strong> <span id="alt">---</span> m</div>
  <div><strong>Velocidad:</strong> <span id="spd">---</span> km/h</div>
  <div><strong>Potencia:</strong>  <span id="throttle">---</span>%</div>
  <div><strong>Pitch:</strong> <span id="pitch">---</span>°</div>
  <div><strong>Yaw:</strong> <span id="yaw">---</span>°</div>
  <div><strong>Roll:</strong> <span id="roll">---</span>°</div>
  <div>AoA: <span id="aoa">0.0</span>°</div>
  <div>Roll rate: <span id="rollRate">0.0</span>°/s</div>
  <div>Pitch rate: <span id="pitchRate">0.0</span>°/s</div>
  <div>Yaw rate: <span id="yawRate">0.0</span>°/s</div>
  <div>G-load: <span id="gLoad">0.00 g</span></div>
</div>

  <!-- ─── Controles móviles ───────────────────────────────────────────────────── -->
  <div id="mobileControls" style="position:fixed; bottom:10px; right:10px; display:none; flex-direction:column; align-items:center; gap:10px; z-index:1000;">
    <button id="btnResetGyro" title="Reset Gyro">
		<i class="material-icons">refresh</i>
    </button>
	<button id="btnShoot" title="Disparar">
		<i class="material-icons">bolt</i
	</button>
    <button id="btnFullscreen" title="Toggle Fullscreen">
		<i class="material-icons">fullscreen</i>
    </button>
	<input type="range" id="throttleSlider" min="0" max="100" value="0" style="
    position: fixed;
    top: 100px;
    width: 50vh;
    transform: rotate(270deg);
    display: block;
    z-index: 1000;
	"/>
  </div>  

<script>
	(async function main() {
		// 0. Variables globales de física y cámara:
		let verticalSpeed = 0;
		const gravity = 9.8;
		const liftFactor = 20;
		const dragFactor = 0.1;
		const activeSmokeSystems = [];

		// Ángulos y radio de órbita:
		let orbitAngles = { yaw: -Math.PI / 2, pitch: 0.2 }; // vista inicial detrás del avión
		let orbitRadius = 25;
		let isDragging = false;
		let dragStart = { x: 0, y: 0 };
		
		// Autopilot
		let autopilot = false;
		let autopilotHeading = 0;
		let autopilotAltitude = 0;
		let autopilotThrottle = 0;
		let waypoints = [];           // array de Cesium.Cartesian3
		let currentWP = 0;            // índice del waypoint activo
		const wpTolerance = 100;      // metros para “alcanzar” un waypoint
		const targetSpeed = 200;      // km/h deseados en piloto automático

		// 1. Crear Cesium Viewer:
		Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiJiYTQ0YWUyYi0wYjcwLTQ3NDEtYmEzMS1kZDJlYzhkNTkyMzgiLCJpZCI6MzA5MDg4LCJpYXQiOjE3NDkwMjU5NDh9.vtAd5T0-iIYfa8YbSDhK1HEUeOgqR3Whk4OAehbKZ3w'; // Reemplaza con tu token real
		const viewer = new Cesium.Viewer('cesiumContainer', {
			terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(1),
			animation: false,
			timeline: false,
			baseLayerPicker: false,
			geocoder: false,
			homeButton: false,
			infoBox: false,
			sceneModePicker: false,
			selectionIndicator: false,
			navigationHelpButton: false,
			navigationInstructionsInitiallyVisible: false,
			fullscreenButton: false,
			shadows: true,
			shouldAnimate: true,
		});

		// Añadir edificios OSM:
		const osmBuildings = await Cesium.createOsmBuildingsAsync();
		viewer.scene.primitives.add(osmBuildings);

		// 2. Desactivar controles por defecto de Cesium:
		viewer.scene.screenSpaceCameraController.enableRotate = false;
		viewer.scene.screenSpaceCameraController.enableTranslate = false;
		viewer.scene.screenSpaceCameraController.enableZoom = false;
		viewer.scene.screenSpaceCameraController.enableTilt = false;
		viewer.scene.screenSpaceCameraController.enableLook = false;
		
		// ─── Detectar si es móvil o tablet ─────────────────────────────────────────
		const isMobileDevice = /Mobi|Android|iPhone|iPad|Tablet/.test(navigator.userAgent);
		// ─── Mostrar controles en móviles/tablets ────────────────────────────────
		if (isMobileDevice) {
			document.getElementById('mobileControls').style.display = 'flex';
			document.getElementById('throttleSlider').style.display = 'block';
		}
		
		// 3. Usar ScreenSpaceEventHandler para capturar arrastre de ratón:
		const minOrbitRadius = 5;
		const maxOrbitRadius = 100;
		const zoomSpeed      = 0.1;
		viewer.scene.canvas.addEventListener('wheel', (e) => {
			// deltaY > 0: alejar, deltaY < 0: acercar
			orbitRadius += e.deltaY * zoomSpeed;
			orbitRadius = Cesium.Math.clamp(orbitRadius, minOrbitRadius, maxOrbitRadius);
			e.preventDefault();
		}, { passive: false });
		
		// Toggle Autopilot con P
		window.addEventListener("keydown", (e) => {
			if (e.code === "KeyA") {
				autopilot = !autopilot;
				if (autopilot) {
				// Tomar referencia de rumbo, altitud y potencia actuales
				const state = computeFrameState();
				autopilotHeading  = state.hpr.heading;
				autopilotAltitude = state.carto.height;
				autopilotThrottle = throttle;
				console.log(
					"Autopilot: ON — Heading:",
					Cesium.Math.toDegrees(autopilotHeading).toFixed(1),
					"Alt:", autopilotAltitude.toFixed(1),
					"Throttle:", Math.round(autopilotThrottle * 100) + "%"
				);
				} else {
				console.log("Autopilot: OFF");
				}
			}
		});

		// Añadir waypoint con doble-clic
		viewer.scene.canvas.addEventListener("dblclick", (e) => {
		  const cartesian = viewer.camera.pickEllipsoid(e.position, viewer.scene.globe.ellipsoid);
		  if (!cartesian) return;
		  waypoints.push(cartesian);
		  // marcar visualmente
		  viewer.entities.add({
			position: cartesian,
			point: { pixelSize: 8, color: Cesium.Color.YELLOW }
		  });
		  console.log("Waypoint añadido:", cartesian);
		});
		
		  const handler = new Cesium.ScreenSpaceEventHandler(viewer.canvas);

		  handler.setInputAction((evt) => {
			isDragging = true;
			dragStart.x = evt.position.x;
			dragStart.y = evt.position.y;
		  }, Cesium.ScreenSpaceEventType.LEFT_DOWN);

		  handler.setInputAction(() => {
			isDragging = false;
		  }, Cesium.ScreenSpaceEventType.LEFT_UP);

		  handler.setInputAction((evt) => {
			if (!isDragging) return;
			const dx = evt.startPosition.x - evt.endPosition.x;
			const dy = evt.startPosition.y - evt.endPosition.y;
			orbitAngles.yaw -= dx * 0.005;
			orbitAngles.pitch += dy * 0.005;
			orbitAngles.pitch = Cesium.Math.clamp(orbitAngles.pitch, -Math.PI / 2 + 0.1, Math.PI / 2 - 0.1);
			// Actualizar dragStart para la siguiente llamada:
			dragStart.x = evt.endPosition.x;
			dragStart.y = evt.endPosition.y;
		  }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);

		// 4. Variables de estado del avión y controles:
		let aircraft, position, orientationQuat;
		let forwardSpeed = 0;      // velocidad actual de avance (m/s)
		let throttle = 0;          // potencia del motor [0 .. 1]
		const maxThrust = 7500;    // Empuje máximo (puedes ajustar sobre la marcha)
		const dragCoefficient = 0.02; // Coeficiente de resistencia aerodinámica
		// ─── Parámetros aerodinámicos ────────────────────────────
		const rho0 = 1.225;       // kg/m³ al nivel del mar
		const wingArea = 50;      // m²
		const wingSpan = 15;      // m (ancho de ala, ajústalo a tu modelo)
		const CL0 = 0.2;          // coef. de lift a AoA = 0
		const CL_ALPHA = 5.7;     // pendiente de coef. lift (por radian)
		const mass = 18300;        // kg
		const fuselageArea   = 10;    // m² (área frontal del fuselaje, ajústalo a tu modelo)
		const CD0Fuselaje    = 0.025; // coeficiente de drag parásito del fuselaje

	 	const keys = {};
	 
		//window.addEventListener('keydown', (e) => (keys[e.code] = true));
		//window.addEventListener('keyup', (e) => (keys[e.code] = false));


		// 5. Función para crear el modelo principal (F-22):
		async function createModel() {
		  viewer.entities.removeAll();
		  // 1. Definir posición inicial (tal cual ya lo tienes)
			position = Cesium.Cartesian3.fromDegrees(-3.7038, 40.4168, 5000);

			// 2. Crear un HeadingPitchRoll con pitch = 0, roll = 0, y el heading que tú elijas.
			//    Aquí usamos heading = 0 (hacia Norte). Si quisieras que mire Este, usa 90°.
			const initialHeading = 0; // en grados
			const hpr = new Cesium.HeadingPitchRoll(
			  Cesium.Math.toRadians(initialHeading),
			  0,    // pitch = 0 → plano al terreno
			  0     // roll = 0 → sin rotación lateral
			);

			// 3. Calcular el cuaternión “horizontal” sobre la superficie local
			orientationQuat = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);

			// 4. ¡Crear el modelo!
			aircraft = viewer.entities.add({
			  name: 'F-22 Raptor',
			  position: new Cesium.CallbackProperty(() => position, false),
			  orientation: new Cesium.CallbackProperty(() => orientationQuat, false),
			  model: {
				uri: 'models/simulador/f22_model.glb',
				minimumPixelSize: 64,
				maximumScale: 10000,
				scale: 1,
			  },
			});
		}
		await createModel();
		
		//-------- Logica de disparo -------------
		// 6. Función para los proyectiles:
		
		/**
		* Comprueba si una posición está sobre un edificio OSM.
		* Hace un raycast descendente desde 1 m sobre la posición.
		*/
		function detectOSMAt(position) {
			// Convertir a coordenadas de pantalla
			const screenPos = viewer.scene.cartesianToCanvasCoordinates(position);
			if (!Cesium.defined(screenPos)) {
				return false;
			}
			// Drill pick para obtener features bajo ese píxel
			const picks = viewer.scene.drillPick(screenPos);
			for (const pick of picks) {
				// Si es un feature de 3D Tiles (OSM Buildings), devolvemos true
				if (pick instanceof Cesium.Cesium3DTileFeature) {
				return true;
				}
			}
			return false;
		}
		
		/**
		* Maneja el impacto de un proyectil en 'position'.
		* Decide terreno vs edificio, genera humo/incendio y elimina la entidad.
		*/
		function handleImpact(entity, position) {
			// Detectamos si cayó sobre un edificio OSM
			const isOSM = detectOSMAt(position);
			if (isOSM) {
				console.log("¡Impacto en edificio OSM detectado!");
			}
			// Creamos humo o incendio en la posición exacta
			createSmokeAt(position, isOSM);
			// Eliminamos la bala tras breve retardo para ver su última posición
			setTimeout(() => viewer.entities.remove(entity), 50);
		}
		
			
		const projectiles = [];

		function shootProjectile() {
			if (!position || !orientationQuat) return;

			  // 6.1. Obtenemos el eje “forward” del avión (eje X local)
			  const rotMat = Cesium.Matrix3.fromQuaternion(orientationQuat);
				const forward = Cesium.Matrix3.multiplyByVector(
				  rotMat,
				  Cesium.Cartesian3.UNIT_X,
				  new Cesium.Cartesian3()
				);

			 // 6.2. Offset para que el proyectil salga justo del morro (5 m delante del centro)
			const muzzleOffset = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  2.5, // distancia reducida para acercarlo al morro
			  new Cesium.Cartesian3()
			);
			// Posición base tras el offset frontal
			const muzzlePosition = Cesium.Cartesian3.add(
			  position,
			  muzzleOffset,
			  new Cesium.Cartesian3()
			);
			// Desplazamiento vertical: bajar 2 m en eje local 'up'
			const up = Cesium.Matrix3.multiplyByVector(
			  rotMat,
			  Cesium.Cartesian3.UNIT_Z,
			  new Cesium.Cartesian3()
			);
			const downOffset = Cesium.Cartesian3.multiplyByScalar(
			  up,
			  -1, // metros a bajar
			  new Cesium.Cartesian3()
			);
			// Posición inicial final del proyectil
			const initialPosition = Cesium.Cartesian3.add(
			  muzzlePosition,
			  downOffset,
			  new Cesium.Cartesian3()
			);

			// 6.3. Velocidad inicial de la bala: hereda forwardSpeed del avión
			// 1) Velocidad heredada del avión
			const planeVelocity = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  forwardSpeed,
			  new Cesium.Cartesian3()
			);

			// 2) Velocidad de boca de la M61 Vulcan (~1030 m/s) = (~3708 km/h)
			const muzzleVelocity = 3708/2; // km/h real
			const pushExtra = Cesium.Cartesian3.multiplyByScalar(
			  forward,
			  muzzleVelocity,
			  new Cesium.Cartesian3()
			);

			// 3) Velocidad inicial = avión + salida del cañón
			const initialVelocity = Cesium.Cartesian3.add(
			  planeVelocity,
			  pushExtra,
			  new Cesium.Cartesian3()
			);

			  // 6.4. Creamos la entidad del proyectil
			  let currentPosition = Cesium.Cartesian3.clone(initialPosition);
			  const entity = viewer.entities.add({
					position: new Cesium.CallbackProperty(() => currentPosition, false),
					orientation: new Cesium.CallbackProperty(() => {
					  // Orientar el modelo de la bala para que "mire" hacia adelante
					  return Cesium.Transforms.headingPitchRollQuaternion(
						currentPosition,
						new Cesium.HeadingPitchRoll(0, 0, 0)
					  );
					}, false),
					model: {
					  uri: 'models/simulador/silver_projectile.glb',
					  scale: 1, //0.25
					  minimumPixelSize: 1
					}
			  });

			// 6.5. Añadimos al array para actualizar cada frame
			projectiles.push({
				entity,
				velocity: Cesium.Cartesian3.clone(initialVelocity),
				// Variables para gestionar el impacto
				impacted: false,
				impactTimer: 0,
				update: function(deltaTime) {
					// 1) Actualizamos velocidad y calculamos nueva posición
					this.velocity.z -= gravity * deltaTime;
					const prevPos = Cesium.Cartesian3.clone(currentPosition);
					const step    = Cesium.Cartesian3.multiplyByScalar(
						this.velocity,
						deltaTime,
						new Cesium.Cartesian3()
					);
					currentPosition = Cesium.Cartesian3.add(prevPos, step, new Cesium.Cartesian3());
					
					// distancia recorrida desde el disparo
					const traveled = Cesium.Cartesian3.distance(currentPosition, initialPosition);

					  const carto = Cesium.Cartographic.fromCartesian(currentPosition);
					  const terrainHeight = viewer.scene.globe.getHeight(carto);

					// Detección de choque contra terreno
					const hitTerrain = terrainHeight !== undefined && carto.height <= terrainHeight + 1;
					// Si cayó contra el suelo (edificio o terreno), manejamos impacto
					if (hitTerrain && !this.impacted) {
					  this.impacted = true;
					  handleImpact(entity, currentPosition);
					  return false;
					}

					// Si ya impactó, contabiliza el tiempo y elimina al siguiente update
					if (this.impacted) {
					this.impactTimer += deltaTime;
						if (this.impactTimer > 0) {
							viewer.entities.remove(entity);
							return false;
						}
					// Deja que se dibuje este frame (para mostrar la posición final)
					}

					// 5) fuera de rango máximo
					  if (Cesium.Cartesian3.distance(currentPosition, initialPosition) > 20000) {
						viewer.entities.remove(entity);
						return false;
					  }

					return true;
				}
			});
		}

		// 7. Función para crear los efectos de los proyectiles	
		/**
		 * @param {Cesium.Cartesian3} position — punto de impacto
		 * @param {boolean} isBurn — true si es incendio (OSM), false si es humo normal (terreno)
		 */
		function createSmokeAt(position, isBurn = false) {
			const carto = Cesium.Cartographic.fromCartesian(position);
			const terrainHeight = viewer.scene.globe.getHeight(carto);
			const adjustedPosition = Cesium.Cartesian3.fromRadians(
				carto.longitude,
				carto.latitude,
				terrainHeight + 1.0 // justo sobre el suelo
			);
			
			const smokeParticles = [];
			
			if (isBurn) {
				// Incendio estático con fade-in y fade-out
				const entityLifetime = 300;
				const fadeInTime = 5;
				const fadeOutTime = 60;
			
				// Creamos entidad única
				const burnEntity = {
				position: adjustedPosition,
				age: 0,
				lifespan: entityLifetime,
				modelEntity: null
				};
			
				burnEntity.modelEntity = viewer.entities.add({
				position: adjustedPosition,
				// Girar 90° alrededor del eje Z (roll) para que el modelo quede vertical
				orientation: Cesium.Transforms.headingPitchRollQuaternion(
					adjustedPosition,
					new Cesium.HeadingPitchRoll(
						0,                           // heading
						Cesium.Math.toRadians(90),                           // pitch
						0    // roll = 90°
					)
				),
				model: {
					uri: 'models/simulador/incendio.glb',
					scale: new Cesium.CallbackProperty(() => {
						const age = burnEntity.age;
						const t = Math.min(Math.max(age / entityLifetime, 0), 1);
						return Cesium.Math.lerp(0.5, 10.0, t);
					}, false),
					minimumPixelSize: 10,
					// Color dinámico para fade
					color: new Cesium.CallbackProperty(() => {
						const age = burnEntity.age;
						let alpha = 1.0;
						if (age < fadeInTime) {
							alpha = age / fadeInTime;
						} else if (age > entityLifetime - fadeOutTime) {
							alpha = (entityLifetime - age) / fadeOutTime;
						}
						return Cesium.Color.BLACK.withAlpha(alpha);
					}, false),
					colorBlendMode: Cesium.ColorBlendMode.MIX,
					colorBlendAmount: 1.0
				}
				});
			
				// Actualización del incendio
				burnEntity.update = (deltaTime) => {
				burnEntity.age += deltaTime;
				if (burnEntity.age >= burnEntity.lifespan) {
					viewer.entities.remove(burnEntity.modelEntity);
					return false;
				}
				return true;
				};
			
				activeSmokeSystems.push([burnEntity]);
			
			} else {
				// Humo normal como antes
				const maxParticles = 15;
				const particleUri = 'models/simulador/smoke_particle.glb';
				const baseLifespan = 3;
			
				for (let i = 0; i < maxParticles; i++) {
				const offset = Cesium.Cartesian3.fromElements(
					(Math.random() - 0.5) * 10,
					(Math.random() - 0.5) * 10,
					Math.random() * 10
				);
			
				const particlePosition = Cesium.Cartesian3.add(
					adjustedPosition,
					offset,
					new Cesium.Cartesian3()
				);
			
				const particle = {
					position: particlePosition,
					velocity: new Cesium.Cartesian3(
					(Math.random() - 0.5) * 1.5,
					(Math.random() - 0.5) * 1.5,
					1 + Math.random() * 3
					),
					age: 0,
					lifespan: baseLifespan + Math.random() * 2,
					scale: 1 + Math.random() * 0.5,
					modelEntity: null
				};
			
				particle.modelEntity = viewer.entities.add({
					position: new Cesium.CallbackProperty(() => particle.position, false),
					orientation: new Cesium.CallbackProperty(() => {
					return Cesium.Transforms.headingPitchRollQuaternion(
						particle.position,
						new Cesium.HeadingPitchRoll(0, 0, 0)
					);
					}, false),
					model: {
					uri: particleUri,
					scale: new Cesium.CallbackProperty(() => {
						const growth = 1 + particle.age * 0.2;
						return particle.scale * growth;
					}, false),
					minimumPixelSize: 10,
					color: Cesium.Color.WHITE.withAlpha(0.5),
					colorBlendMode: Cesium.ColorBlendMode.MIX,
					colorBlendAmount: 0.8
					}
				});
			
				particle.update = (deltaTime) => {
					particle.age += deltaTime;
					if (particle.age >= particle.lifespan) {
					viewer.entities.remove(particle.modelEntity);
					return false;
					}
					const deltaMove = Cesium.Cartesian3.multiplyByScalar(
					particle.velocity,
					deltaTime,
					new Cesium.Cartesian3()
					);
					particle.position = Cesium.Cartesian3.add(
					particle.position,
					deltaMove,
					new Cesium.Cartesian3()
					);
					return true;
				};
			
				smokeParticles.push(particle);
				}
			
				activeSmokeSystems.push(smokeParticles);
			}
		}

		// 8. Contoles 
		
		window.addEventListener("keydown", (e) => {
		  keys[e.code] = true;
		  if (e.code === "Space") shootProjectile();
		  if (e.code === "Enter") {
			autoLevel = true;
		  }
		  // Si el piloto vuelve a dar una orden manual, cancelamos el auto-nivelado
		  if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","KeyQ","KeyE"].includes(e.code)) {
			autoLevel = false;
		  }
		});
		
		  // Listener para liberación de teclas: limpiar el flag
		  window.addEventListener("keyup", (e) => {
			if (keys[e.code]) {
			  keys[e.code] = false;
			}
		  });
		
		// ─── Tensor de inercia (valores de ejemplo, en kg·m²) ─────────────────────────
		const I = Cesium.Matrix3.fromArray([
		  1.2e5,   0,      0,
			0,   9.0e4,   0,
			0,     0,   1.5e5
		]);
		const Iinv = Cesium.Matrix3.inverse(I, new Cesium.Matrix3());

		// Superficies de control y brazos de palanca (m² y m)
		const S_aileron   = 4.0,  l_aileron   = 5.0;
		const S_elevator  = 3.5,  l_elevator  = 7.0;
		const S_rudder    = 2.0,  l_rudder    = 6.0;
		
		// ─── Parámetros para pitching moment de fuselaje ──────────────────────────────
		const Cm_ALPHA      = 0.05;      // coef. moment pitching por rad
		const l_fuselage    = 8.0;       // brazo de palanca fuselaje (m)

		// Coeficiente de damping rotacional
		const C_d_rot = 0.5;
		
		// ─── Parámetros de motor con spool-up/spool-down ──────────────────────────────
		// Empuje actual del motor (N)
		let thrustCurrent = 0.0;

		// Estado de la velocidad angular en el cuerpo
		let ω = new Cesium.Cartesian3(0, 0, 0);
		// ─── Límites de velocidad angular (rad/s) ───────────────────────────────────
		const maxRollRate  = Cesium.Math.toRadians(90);   // ±90°/s
		const maxPitchRate = Cesium.Math.toRadians(60);   // ±60°/s
		const maxYawRate   = Cesium.Math.toRadians(45);   // ±45°/s
		
		// ─── Estado de deflexión actual de superficies (rad) ─────────────────────────
		let δa_current = 0.0, δe_current = 0.0, δr_current = 0.0;
		// Máxima velocidad de deflexión: 30° por segundo
		const maxDeflectionRate = Cesium.Math.toRadians(30);
				
		// Flag para auto-nivelado
		let autoLevel = false;
		
		// ──────────────────────────────────────────────────────────────────────────────
		
		// ─── Variables para giroscopio móvil ──────────────────────────────────────────
		let useGyro = false;
		let gyroOffset = { alpha: 0, beta: 0, gamma: 0 };
		let gyroAngles = { roll: 0, pitch: 0, yaw: 0 };
		// Almacenamos el último evento para el reset
		let lastEvent = { alpha: 0, beta: 0, gamma: 0 };

		// Detectar soporte y activar giroscopio
		if (window.DeviceOrientationEvent) {
			window.addEventListener('deviceorientation', (e) => {
				if (e.alpha === null) {
				return;
				}
				// Guardamos el evento para poder resetear offset más tarde
				lastEvent.alpha = e.alpha;
				lastEvent.beta  = e.beta;
				lastEvent.gamma = e.gamma;
		
				useGyro = true;
				document.getElementById('mobileControls').style.display = 'flex';
				document.getElementById('throttleSlider').style.display = 'block';
		
				// Calcular diferencia respecto al offset
				const a = e.alpha - gyroOffset.alpha;
				const b = e.beta  - gyroOffset.beta;
				const g = e.gamma - gyroOffset.gamma;
				
				// Factores de sensibilidad
				const sensitivityYaw   = 0.4;
				const sensitivityPitch = 0.6;
				const sensitivityRoll  = 0.6;
		
				// Mapear a radianes y ajustar signos para Cesium
				gyroAngles.yaw   = Cesium.Math.toRadians(a * sensitivityYaw);   // YAW ← alpha
				gyroAngles.pitch = Cesium.Math.toRadians(g * sensitivityPitch); // PITCH ← -beta
				gyroAngles.roll  = Cesium.Math.toRadians(b * sensitivityRoll);  // ROLL ← gamma
			});

			// Botón reset gyro		
			document.getElementById('btnResetGyro').addEventListener('click', () => {
				// Resetear offset de giroscopio
				gyroOffset.alpha = lastEvent.alpha;
				gyroOffset.beta  = lastEvent.beta;
				gyroOffset.gamma = lastEvent.gamma;

				// Reiniciar velocidades angulares
				ω = new Cesium.Cartesian3(0, 0, 0);

				// Resetear deflexiones de superficies
				δa_current = 0;
				δe_current = 0;
				δr_current = 0;

				// Activar de nuevo
				useGyro = true;
				console.log('🔄 Giroscopio y orientación reiniciados');
			});
		}

		// Botón fullscreen
		document.getElementById('btnFullscreen').addEventListener('click', () => {
			const el = document.documentElement;
			if (!document.fullscreenElement) {
				el.requestFullscreen();
			} else {
				document.exitFullscreen();
			}
		});

		// Slider de throttle
		const slider = document.getElementById('throttleSlider');
		slider.addEventListener('input', () => {
			throttle = slider.value / 100;
		});
		
		// Botón de disparo en móviles
		document.getElementById('btnShoot').addEventListener('click', () => {
			shootProjectile();
		});
		
		/**
		* Devuelve los comandos roll/pitch/yaw para mantener rumbo, altitud y potencia fijos.
		* @param {Object} state — Resultado de computeFrameState().
		* @param {number} dt    — DeltaTime en segundos.
		* @returns {{roll:number,pitch:number,yaw:number}}
		*/
		function computeAutopilotCommands(state, dt) {
			if (!autopilot) {
				return { roll: 0, pitch: 0, yaw: 0 };
			}
			// 1) Avanzar waypoint si estamos cerca
			const target = waypoints[currentWP];
			if (Cesium.Cartesian3.distance(state.position, target) < wpTolerance) {
				currentWP = (currentWP + 1) % waypoints.length;
			}
			// 2) Rumbo deseado
			const wpCarto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(target);
			const desiredH = new Cesium.EllipsoidGeodesic(state.carto, wpCarto).startHeading;
			const errH = Cesium.Math.negativePiToPi(desiredH - state.hpr.heading);
			const rollCmd = Cesium.Math.clamp(0.5 * errH, -Math.PI/18, Math.PI/18);
			// 3) Mantener altitud inicial
			const errA = autopilotAltitude - state.carto.height;
			const pitchCmd = Cesium.Math.clamp(0.0005 * errA, -Math.PI/18, Math.PI/18);
			// 4) No usamos yaw manualmente (lo controla el roll)
			const yawCmd = 0;
			return { roll: rollCmd, pitch: pitchCmd, yaw: yawCmd };
		}

		
		/**
		* Devuelve comandos de control manual / giroscopio.
		* @param {number} dt
		* @returns {{roll:number,pitch:number}}
		*/
		function computeManualOrGyroCommands(dt) {
		// aquí tu lógica actual de gyro/manual
		let roll = 0, pitch = 0;
		if (useGyro) {
			roll  = Cesium.Math.clamp(gyroAngles.roll,  -Math.PI/18, Math.PI/18);
			pitch = Cesium.Math.clamp(gyroAngles.pitch, -Math.PI/18, Math.PI/18);
		} else {
			roll  = keys['ArrowLeft']  ? -Math.PI/18 : keys['ArrowRight'] ? +Math.PI/18 : 0;
			pitch = keys['ArrowUp']    ? +Math.PI/18 : keys['ArrowDown']  ? -Math.PI/18 : 0;
		}
		return { roll, pitch };
		}
		
		//--------------------------------------------------------------------------------------
		
		// Pre-reservar vectores para evitar allocs cada frame
		const tmpForwardVel   = new Cesium.Cartesian3();
		const tmpVerticalVel  = new Cesium.Cartesian3();
		const planeVelocity   = new Cesium.Cartesian3();
		const tmpCross1       = new Cesium.Cartesian3();
		const tmpCross2       = new Cesium.Cartesian3();
		
		let lastTime = performance.now();
		let prevPlaneVelocity = new Cesium.Cartesian3(0, 0, 0);
		
		viewer.scene.postRender.addEventListener(() => {
			const now       = performance.now();
			const deltaTime = (now - lastTime) / 1000;
			lastTime        = now;
			if (!position || !orientationQuat) return;
			
			// 0) Lectura de inputs (throttle +/-)  
			const throttleStep = 0.5 * deltaTime;
			if (keys['Equal'] || keys['NumpadAdd'])    throttle = Math.min(throttle + throttleStep, 1.0);
			if (keys['Minus'] || keys['NumpadSubtract']) throttle = Math.max(throttle - throttleStep, 0.0);
			
			// 1) Recalcular rotMatrix, ejes y carto  
			const state = computeFrameState();
			const { rotMatrix, forward, right, surfaceNormal, hpr, carto } = state;
			
			const aero  = calculateAerodynamics(state.planeVelocity, state.forward, state.right, state.carto);
			
			// 1) Obtener comandos de piloto automático o manual
			let rollCmd = 0, pitchCmd = 0, yawCmd = 0;
			if (autopilot) {
			// Fija throttle y altitud a la referenciada al activar
			throttle = autopilotThrottle;
			({ roll: rollCmd, pitch: pitchCmd, yaw: yawCmd } =
				computeAutopilotCommands(state, deltaTime));
			}

 			// 2) Aplicar la rotación a las superficies
			updateRotation(deltaTime, aero.qd, rollCmd, pitchCmd, yawCmd);
			
			// Lift, gravedad y damping
			applyLiftAndGravity(deltaTime, aero.liftForce);

			applyInducedDrag(deltaTime, state.planeVelocity, state.forward, aero.dragForce);
			applyThrottleAndDrag(deltaTime);
			
			updatePosition(deltaTime, state.forward, state.surfaceNormal);
			updateCamera(computeFrameState());
			updateHUD(state, aero, deltaTime, gravity);
			
			updateProjectiles(deltaTime);
			updateSmoke(deltaTime);
			detectTerrainCollision(state.carto, verticalSpeed);
		});
		
		// Desacopla el stall
		function computeLiftCoefficient(aoa) {
			const stallLimit = Cesium.Math.toRadians(15);
			const maxAoA     = Cesium.Math.toRadians(45);
			if (aoa <= stallLimit) {
				return CL_ALPHA * aoa;
			}
			const CLmax = CL_ALPHA * stallLimit;
			return CLmax * Math.max(0, 1 - (aoa - stallLimit) / (maxAoA - stallLimit));
		}
		
		function calculateAerodynamics(planeVelocity, forward, right, carto) {
		const V = Cesium.Cartesian3.magnitude(planeVelocity);
		let liftForce = 0, dragForce = 0, aoa = 0, qd = 0;
		if (V > 0.1) {
			const flightDir = Cesium.Cartesian3.normalize(planeVelocity, new Cesium.Cartesian3());
			const cosAoA = Cesium.Math.clamp(Cesium.Cartesian3.dot(flightDir, forward), -1, 1);
			aoa = Math.acos(cosAoA);
			const CL = (aoa <= Cesium.Math.toRadians(15))
			? CL_ALPHA * aoa
			: (CL_ALPHA * Cesium.Math.toRadians(15)) * Math.max(0, 1 - (aoa - Cesium.Math.toRadians(15)) / (Cesium.Math.toRadians(45) - Cesium.Math.toRadians(15)));
			const AR = wingSpan || Math.sqrt(wingArea);
			const CDi = (CL * CL) / (Math.PI * AR);
			const rho = rho0 * Math.exp(-carto.height / 8500);
			qd = 0.5 * rho * V * V;
			liftForce = qd * wingArea * CL + qd * fuselageArea * (Cm_ALPHA * aoa);
			const baseCD = CDi + CD0Fuselaje * (fuselageArea / wingArea);
			const stallDrag = aoa > Cesium.Math.toRadians(15)
			? 2 * ((aoa - Cesium.Math.toRadians(15)) / (Cesium.Math.toRadians(45) - Cesium.Math.toRadians(15)))
			: 0;
			dragForce = qd * wingArea * (baseCD + stallDrag);
		}
		return { liftForce, dragForce, aoa, qd };
		}
		
		function applyLiftAndGravity(dt, liftForce) {
			verticalSpeed -= gravity * dt;
			if (liftForce) verticalSpeed += (liftForce / mass) * dt;
			verticalSpeed *= (1 - dragFactor * dt);
			verticalSpeed = Cesium.Math.clamp(verticalSpeed, -300, 300);
		}
		
		function applyInducedDrag(dt, planeVelocity, forward, dragForce) {
			const dragDir = new Cesium.Cartesian3();
			if (Cesium.Cartesian3.magnitude(planeVelocity) > 0.1) {
				Cesium.Cartesian3.normalize(planeVelocity, dragDir);
				Cesium.Cartesian3.negate(dragDir, dragDir);
			}
			const dragAcc = dragForce / mass;
			const dragStep = Cesium.Cartesian3.multiplyByScalar(dragDir, dragAcc * dt, new Cesium.Cartesian3());
			const newVel = Cesium.Cartesian3.add(planeVelocity, dragStep, new Cesium.Cartesian3());
			forwardSpeed = Math.max(0, Cesium.Cartesian3.dot(newVel, forward));
		}
				
		/**
		* Aplica la dinámica de avance simple: empuje del motor y arrastre aerodinámico.
		* Modifica forwardSpeed.
		* @param {number} dt — Intervalo de tiempo en segundos.
		*/
		function applyThrottleAndDrag(dt) {
			const thrust     = throttle * maxThrust;
			const simpleDrag = dragCoefficient * forwardSpeed * forwardSpeed;
			forwardSpeed    += (thrust - simpleDrag) * dt;
			forwardSpeed     = Math.max(0, forwardSpeed);
		}
		
		/**
		* Calcula y aplica el desplazamiento del avión en el espacio global.
		* Modifica la variable global `position`.
		* @param {number} dt — Intervalo de tiempo en segundos.
		* @param {Cesium.Cartesian3} forward — Eje X local del avión.
		* @param {Cesium.Cartesian3} surfaceNormal — Normal al terreno.
		*/
		function updatePosition(dt, forward, surfaceNormal) {
			const stepForward = Cesium.Cartesian3.multiplyByScalar(
				forward,
				forwardSpeed * dt,
				new Cesium.Cartesian3()
			);
			const gravityStep = Cesium.Cartesian3.multiplyByScalar(
				surfaceNormal,
				verticalSpeed * dt,
				new Cesium.Cartesian3()
			);
			position = Cesium.Cartesian3.add(
				position,
				Cesium.Cartesian3.add(stepForward, gravityStep, new Cesium.Cartesian3()),
				new Cesium.Cartesian3()
			);
		}
		
		/**
		* Recalcula todos los vectores básicos y retorna el estado del frame.
		*/
		function computeFrameState() {
			  const rotMatrix     = Cesium.Matrix3.fromQuaternion(orientationQuat);
			  const forward       = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_X, new Cesium.Cartesian3());
			  const right         = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Y, new Cesium.Cartesian3());
			  const up            = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
			  const surfaceNormal = Cesium.Ellipsoid.WGS84.geodeticSurfaceNormal(position, new Cesium.Cartesian3());
			  const carto         = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
			  const hpr           = Cesium.HeadingPitchRoll.fromQuaternion(orientationQuat);
			  const planeVelocity = Cesium.Cartesian3.add(
				Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed, new Cesium.Cartesian3()),
				Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed, new Cesium.Cartesian3()),
				new Cesium.Cartesian3()
			  );
			  const speed      = Cesium.Cartesian3.magnitude(planeVelocity);
			  const angularVel = Cesium.Cartesian3.clone(ω);
			  // IMPORTANTE: incluimos position y angularVel para updateCamera/updateHUD
			  return { rotMatrix, forward, right, up, surfaceNormal, carto, hpr, planeVelocity, speed, angularVel, position };
		}
		
		/**
		 * Actualiza la posición de la cámara para que orbite detrás del avión.
		 * @param {{ rotMatrix: Cesium.Matrix3, position: Cesium.Cartesian3 }} state
		 */
		function updateCamera(state) {
			const { rotMatrix, position } = state;
			const center = Cesium.Cartesian3.clone(position);
						
			const localOffset = new Cesium.Cartesian3(
				orbitRadius * Math.cos(orbitAngles.pitch) * Math.sin(orbitAngles.yaw),
				orbitRadius * Math.cos(orbitAngles.pitch) * Math.cos(orbitAngles.yaw),
				orbitRadius * Math.sin(orbitAngles.pitch)
			);
						
			const offset    = Cesium.Matrix3.multiplyByVector(rotMatrix, localOffset, new Cesium.Cartesian3());
			const cameraPos = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());
			const dir       = Cesium.Cartesian3.normalize(
			Cesium.Cartesian3.subtract(center, cameraPos, new Cesium.Cartesian3()),
				new Cesium.Cartesian3()
			);
			const upVec     = Cesium.Matrix3.multiplyByVector(rotMatrix, Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
						
			viewer.scene.camera.setView({
				destination : cameraPos,
				orientation : { direction: dir, up: upVec }
			});
		}
		
		/**
		 * Detecta colisiones con el terreno y gestiona la respuesta.
		 * @param {Cesium.Cartographic} carto - Posición geográfica actual del avión.
		 * @param {number} verticalSpeed - Velocidad vertical actual.
		 * @returns {boolean} - True si hubo colisión grave y se detuvo la simulación.
		 */
		function detectTerrainCollision(carto, verticalSpeed) {
		  const terrainHeight = viewer.scene.globe.getHeight(carto);
		  const margin = 1.0;

		  if (terrainHeight !== undefined && carto.height <= terrainHeight + margin) {
			if (verticalSpeed < -10) {
			  forwardSpeed = 0;
			  verticalSpeed = 0;
			  position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight + margin);
			  alert("¡Colisión grave! Simulación detenida.");
			  viewer.scene.postRender.removeEventListener(arguments.callee);
			  return true;
			} else {
			  forwardSpeed *= 0.5;
			  verticalSpeed *= -0.3;
			  position = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, terrainHeight + margin);
			}
		  }
		  return false;
		}

		/**
		* Actualiza el HUD con los datos de vuelo.
		* @param {Object} state - Estado del frame actual.
		* @param {Cesium.Cartographic} state.carto
		* @param {Cesium.HeadingPitchRoll} state.hpr
		* @param {Cesium.Matrix3} state.rotMatrix
		* @param {Cesium.Cartesian3} state.forward
		* @param {Cesium.Cartesian3} state.surfaceNormal
		* @param {number} state.speed
		* @param {Cesium.Cartesian3} state.angularVel
		* @param {Cesium.Cartesian3} state.planeVelocity
		* @param {Object} aero - Aerodinámica actual.
		* @param {number} aero.aoa - Ángulo de ataque.
		* @param {number} deltaTime - Tiempo entre frames.
		* @param {number} gravity - Constante de gravedad.
		*/
		function updateHUD(state, aero, deltaTime, gravity) {
			const { carto, hpr, rotMatrix, forward, surfaceNormal, planeVelocity, angularVel } = state;
			
			// Velocidades
			const newForwardVel = Cesium.Cartesian3.multiplyByScalar(forward, forwardSpeed, new Cesium.Cartesian3());
			const newVerticalVel = Cesium.Cartesian3.multiplyByScalar(surfaceNormal, verticalSpeed, new Cesium.Cartesian3());
			const newPlaneVel = Cesium.Cartesian3.add(newForwardVel, newVerticalVel, new Cesium.Cartesian3());
			const totalSpeed = Cesium.Cartesian3.magnitude(newPlaneVel);
			
			// Coordenadas y ángulos
			const lat = Cesium.Math.toDegrees(carto.latitude).toFixed(5);
			const lon = Cesium.Math.toDegrees(carto.longitude).toFixed(5);
			const altVal = carto.height.toFixed(1);
			const pitchDeg = Cesium.Math.toDegrees(hpr.pitch).toFixed(1);
			const yawDeg   = Cesium.Math.toDegrees(hpr.heading).toFixed(1);
			const rollDeg  = Cesium.Math.toDegrees(hpr.roll).toFixed(1);
			
			// Velocidades angulares
			const rollRateDeg  = Cesium.Math.toDegrees(angularVel.x).toFixed(1);
			const pitchRateDeg = Cesium.Math.toDegrees(angularVel.y).toFixed(1);
			const yawRateDeg   = Cesium.Math.toDegrees(angularVel.z).toFixed(1);
			
			// AoA y carga G
			const aoaDeg = Cesium.Math.toDegrees(aero.aoa).toFixed(1);
			const accel = Cesium.Cartesian3.subtract(planeVelocity, prevPlaneVelocity, new Cesium.Cartesian3());
			Cesium.Cartesian3.divideByScalar(accel, deltaTime, accel);
			const gravVec = new Cesium.Cartesian3(0, 0, -gravity);
			const totalAccel = Cesium.Cartesian3.add(accel, gravVec, new Cesium.Cartesian3());
			const gLoad = (Cesium.Cartesian3.magnitude(totalAccel) / gravity).toFixed(2);
			prevPlaneVelocity = Cesium.Cartesian3.clone(planeVelocity);
			
			// Actualizar DOM
			document.getElementById("coords").textContent   = `${lat}, ${lon}`;
			document.getElementById("alt").textContent      = altVal;
			document.getElementById("spd").textContent      = (totalSpeed * 3.6).toFixed(0);
			document.getElementById("throttle").textContent = (throttle * 100).toFixed(0);
			document.getElementById("pitch").textContent    = pitchDeg;
			document.getElementById("yaw").textContent      = yawDeg;
			document.getElementById("roll").textContent     = rollDeg;
			document.getElementById("rollRate").textContent  = rollRateDeg;
			document.getElementById("pitchRate").textContent = pitchRateDeg;
			document.getElementById("yawRate").textContent   = yawRateDeg;
			document.getElementById("aoa").textContent       = aoaDeg;
			document.getElementById("gLoad").textContent     = gLoad + " g";
		}

		/**
		 * Actualiza todos los proyectiles disparados.
		 * @param {number} dt — Tiempo transcurrido en segundos desde el último frame.
		 */
		function updateProjectiles(dt) {
		  for (let i = projectiles.length - 1; i >= 0; i--) {
			const proj = projectiles[i];
			const alive = proj.update(dt);
			if (!alive) {
			  projectiles.splice(i, 1);
			}
		  }
		}

		/**
		 * Actualiza todos los sistemas de humo activos.
		 * @param {number} dt — Tiempo transcurrido en segundos desde el último frame.
		 */
		function updateSmoke(dt) {
		  for (let s = activeSmokeSystems.length - 1; s >= 0; s--) {
			const system = activeSmokeSystems[s];
			for (let i = system.length - 1; i >= 0; i--) {
			  if (!system[i].update(dt)) {
				system.splice(i, 1);
			  }
			}
			if (system.length === 0) {
			  activeSmokeSystems.splice(s, 1);
			}
		  }
		}
		
		/**
		* Integra la dinámica rotacional de cuerpo rígido vía Newton–Euler
		* @param {number} dt        — Intervalo de tiempo en segundos
		* @param {number} qd        — Presión dinámica (para fuerzas de control)
		* @param {Cesium.HeadingPitchRoll} hpr — Orientación actual del avión
		* @param {Object} state     — Estado completo del frame (incluye state.carto.height)
		*/
		function updateRotation(dt, qd, rollCmd = 0, pitchCmd = 0, yawCmd = 0) {
			// 1) Deflexión de superficies: calcular objetivo y limitar velocidad de cambio
			const maxDef = Math.PI / 18; // ±10°

			// 1) Objetivos desde comandos externos (autopilot o manual)
			let δa_target = rollCmd, δe_target = pitchCmd, δr_target = yawCmd;

			// 2) Si no recibimos roll/pitch/yaw, caemos al control manual/gyro
			if (rollCmd === 0 && pitchCmd === 0 && yawCmd === 0) {
				if (useGyro) {
					δa_target = Cesium.Math.clamp(gyroAngles.roll,  -maxDef, maxDef);
					δe_target = Cesium.Math.clamp(gyroAngles.pitch, -maxDef, maxDef);
					δr_target = Cesium.Math.clamp(gyroAngles.yaw,   -maxDef, maxDef);
				} else {
					δa_target = keys['ArrowLeft']  ? -maxDef : keys['ArrowRight'] ? +maxDef : 0;
					δe_target = keys['ArrowUp']    ? +maxDef : keys['ArrowDown']  ? -maxDef : 0;
					δr_target = keys['KeyQ']       ? +maxDef : keys['KeyE']      ? -maxDef : 0;
				}
			}

			// 3) Auto-level anula cualquier deflexión hasta nivelar
			if (autoLevel) {
				  const k_trim = 2.0;
				  δa_target = Cesium.Math.clamp(-k_trim * ω.x, -maxDef, maxDef);
				  δe_target = Cesium.Math.clamp(-k_trim * ω.y, -maxDef, maxDef);
				  δr_target = Cesium.Math.clamp(-k_trim * ω.z, -maxDef, maxDef);
				  if (Cesium.Cartesian3.magnitude(ω) < 0.1) {
					autoLevel = false;
				  }
			}

			// Suavizar hacia el objetivo con velocidad limitada
			const step = maxDeflectionRate * dt;
			δa_current += Cesium.Math.clamp(δa_target - δa_current, -step, step);
			δe_current += Cesium.Math.clamp(δe_target - δe_current, -step, step);
			δr_current += Cesium.Math.clamp(δr_target - δr_current, -step, step);

			// Usar las deflexiones suavizadas
			const δa = δa_current;
			const δe = δe_current;
			const δr = δr_current;

			// 2) Torques aerodinámicos de superficies: τ = qd · S · δ · l
			const τx =  qd * S_aileron  * δa * l_aileron;   // roll
			const τy =  qd * S_elevator * δe * l_elevator;  // pitch (solo de elevador)
			const τz =  qd * S_rudder   * δr * l_rudder;    // yaw
		 
			// 2.5) **Eliminado** momento de fuselaje: ya lo tratamos como lift en la parte de fuerzas
			const totalτy = τy;

			// 3) Damping rotacional lineal: τ_d = -C_d_rot · ω
			const τd = Cesium.Cartesian3.multiplyByScalar(ω, -C_d_rot, new Cesium.Cartesian3());

			// 4) Torque neto en cuerpo (superficies + fuselaje + damping)
			const τ = Cesium.Cartesian3.add(
			  new Cesium.Cartesian3(τx, totalτy, τz),
			  τd,
			  new Cesium.Cartesian3()
			);
	
			  // 5) Compute ω×(I·ω)
			  const Iω = Cesium.Matrix3.multiplyByVector(I, ω, new Cesium.Cartesian3());
			  const ωIω = Cesium.Cartesian3.cross(ω, Iω, new Cesium.Cartesian3());

			  // 6) α = I⁻¹·(τ - ω×(I·ω))
			  const net = Cesium.Cartesian3.subtract(τ, ωIω, new Cesium.Cartesian3());
			  const α = Cesium.Matrix3.multiplyByVector(Iinv, net, new Cesium.Cartesian3());

			   // 7) Integrar velocidad angular
			ω = Cesium.Cartesian3.add(ω, Cesium.Cartesian3.multiplyByScalar(α, dt, new Cesium.Cartesian3()), new Cesium.Cartesian3());

			// 7.1) Limitar velocidades angulares a rangos realistas
			ω.x = Cesium.Math.clamp(ω.x, -maxRollRate,  maxRollRate);
			ω.y = Cesium.Math.clamp(ω.y, -maxPitchRate, maxPitchRate);
			ω.z = Cesium.Math.clamp(ω.z, -maxYawRate,   maxYawRate);

			 // 8) Integración incremental de quaternion usando ejes del cuerpo
			const bodyToWorld = Cesium.Matrix3.fromQuaternion(orientationQuat);
			const axisRoll  = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(1, 0, 0), new Cesium.Cartesian3());
			const axisPitch = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(0, 1, 0), new Cesium.Cartesian3());
			const axisYaw   = Cesium.Matrix3.multiplyByVector(bodyToWorld, new Cesium.Cartesian3(0, 0, 1), new Cesium.Cartesian3());

			// Quaterniones incrementales alrededor de ejes locales
			const qIncRoll  = Cesium.Quaternion.fromAxisAngle(axisRoll,  ω.x * dt);
			const qIncPitch = Cesium.Quaternion.fromAxisAngle(axisPitch, ω.y * dt);
			const qIncYaw   = Cesium.Quaternion.fromAxisAngle(axisYaw,   ω.z * dt);

			// Aplicar en orden: roll → pitch → yaw
			orientationQuat = Cesium.Quaternion.normalize(
			  Cesium.Quaternion.multiply(
				qIncYaw,
				Cesium.Quaternion.multiply(
				  qIncPitch,
				  Cesium.Quaternion.multiply(qIncRoll, orientationQuat, new Cesium.Quaternion()),
				  new Cesium.Quaternion()
				),
				new Cesium.Quaternion()
			  ),
			  new Cesium.Quaternion()
			);
		}


		/*
		Recursos: 	https://convert3d.org/app
					https://www.figuro.io/Designer
					https://app.sketchup.com/app?_gl=1*8i50n1*_gcl_au*NzcxNzI0MDc4LjE3NDk1NDE5NjA.
					https://www.turbosquid.com/3d-models/f16-fighter-plane-815125
					https://poly.pizza/
					https://gltf-viewer.donmccurdy.com/
		*/
	})();
</script>
</body>
</html>
