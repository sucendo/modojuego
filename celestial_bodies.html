<!DOCTYPE html>
<html lang="es">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>Simulación del Sistema Solar con Three.js</title>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
		<script src="./js/celestial_bodies/GLTFLoader.js"></script>
		<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">		
		<style>
			body {
				margin: 0;
				overflow: hidden;
			}
			#timePanel{
				position: absolute;
				top: 10px;
				left: 10px;
			}
			#timeControls {
				/*position: absolute;
				top: 5px;
				left: 10px;*/
				color: white;
				/* background: rgba(255, 255, 255, 0.5); */
				border: none;
				padding: 3px;
				cursor: pointer;
			}
			#dateDisplay {
				position:left;
				text-align: left;
				width: 165px;
			}
			#controls {
				position: fixed;
				top: 10px;
				right: 10px;
				z-index: 1000;
				display: flex;
				gap: 10px;
			}
			body > .controlPanel {
				font-family: 'Orbitron', sans-serif; /* Fuente temática espacial */
				font-size: 12px; /* Tamaño de la fuente */
				color: #00ffcc; /* Color futurista */
				text-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc, 0 0 15px #008080, 0 0 20px #008080;
				background: linear-gradient(90deg, hsl(234deg 100% 8% / 50%), hsl(208deg 100% 29% / 50%)); /* Fondo con gradiente espacial */
				padding: 3px 10px; /* Espaciado interno */
				border: 2px solid #00ffcc; /* Borde llamativo */
				border-radius: 10px; /* Esquinas redondeadas */
				box-shadow: 0 0 5px #00ffcc, inset 0 0 3px #004e92; /* Sombra para efecto de brillo */
				text-align: center; /* Centrar texto */
			}
			
			button {
				padding: 10px 15px;
				font-family: 'Orbitron', sans-serif; /* Fuente temática espacial */
				font-size: 12px; /* Tamaño de la fuente */
				color: #00ffcc; /* Color futurista */
				text-shadow: 0 0 5px #00ffcc, 0 0 10px #00ffcc, 0 0 15px #008080, 0 0 20px #008080;
				background: linear-gradient(90deg, #000428, #004e92); /* Fondo con gradiente espacial */
				padding: 3px 10px; /* Espaciado interno */
				border: 2px solid #00ffcc; /* Borde llamativo */
				border-radius: 10px; /* Esquinas redondeadas */
				box-shadow: 0 0 5px #00ffcc, inset 0 0 3px #004e92; /* Sombra para efecto de brillo */
				text-align: center; /* Centrar texto */
				display: inline-block; /* Ajustar tamaño al contenido */
			}

			button:hover {
				background: linear-gradient(90deg, #004e92, #00ffcc); /* Gradiente inverso al hacer hover */
				box-shadow: 0 0 30px #00ffcc, inset 0 0 15px #00ffcc; /* Efecto más intenso al pasar el mouse */
				transform: scale(1.05); /* Aumenta ligeramente el tamaño */
			}

			button:active {
				transform: scale(0.95); /* Efecto al presionar */
				box-shadow: 0 0 15px #00ffcc, inset 0 0 5px #004e92; /* Reduce el brillo al hacer clic */
			}
			
			div#navigationPanel {
				min-width: 180px;
				text-align: left;
			}
		</style>
	</head>
	<body>
		<div id="timePanel" class="controlPanel">
			<div id="dateDisplay"></div>
				<div id="timeControls">			
					<button id="realTimeSpeedBtn">Real</button>
					<button id="decreaseSpeedBtn">-</button>
					<button id="pauseBtn">||</button>
					<button id="increaseSpeedBtn">+</button>	
				</div>
			<div id="timeSpeedDisplay">Tiempo: +1 seg = Real</div>				
		</div>
			
		<div id="controls">
			<button id="toggleOrbits">O</button>
			<button id="fullscreenBtn">P</button>
		</div>

		<script>
			// Configuración inicial
			const scene = new THREE.Scene();
			const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000000);
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true; // Habilitar sombras
			renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Tipo de sombras suaves
			document.body.appendChild(renderer.domElement);

			// Controles de cámara
			const controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.enableDamping = true;
			controls.dampingFactor = 0.05;
			controls.enableZoom = true;

			// Añadir un entorno de luz general (opcional)
			const ambientLight = new THREE.AmbientLight(0x333333, 0.2); // Luz ambiental tenue
			scene.add(ambientLight);

			// Escala para las distancias y tamaños
			const SCALE_DISTANCE = 0.001; // Escala ajustada para las distancias (en km)
			const SCALE_SIZE = 0.001; // Escala ajustada para los tamaños de los cuerpos
			//const SCALE_DISTANCE = 0.00001; // Escala ajustada para las distancias (en km)
			//const SCALE_SIZE = 0.00001; // Escala ajustada para los tamaños de los cuerpos

			// Secuencia simétrica de velocidad/tiempo
			const speedRanges = [
				-30,        // -30 días
				-15,        // -15 días
				-7,         // -7 días
				-2,         // -2 días
				-1,         // -1 día
				-0.5,       // -12 horas
				-0.041666666666666664,// -1 hora
				-0.0006944444444444445,// -1 min
				-0.000011574074074074073,// -1 seg
				0,          // Pausado
				0.000011574074074074073, // 1 seg
				0.0006944444444444445, // 1 min
				0.041666666666666664, // 1 hora
				0.5,        // 12 horas
				1,          // 1 día
				2,          // 2 días
				7,          // 7 días
				15,         // 15 días
				30,         // 30 días
			];

			// Descripciones correspondientes a las velocidades
			const speedDescriptions = [
				"1 seg = -30 días", "1 seg = -15 días", "1 seg = -7 días", "1 seg = -2 días", "1 seg = -1 día",
				"1 seg = -12 horas", "1 seg = -1 hora", "1 seg = -1 min", "1 seg = -1 seg",
				"Pausado",
				"1 seg = 1 seg", "1 seg = 1 min", "1 seg = 1 hora", "1 seg = 12 horas",
				"1 seg = 1 día", "1 seg = 2 días", "1 seg = 7 días", "1 seg = 15 días", "1 seg = 30 días",
			];

			let speedFactor = 0.000011574074074074073; // Inicia en "1 seg" (Avance Real)
			let isPaused = false; // Variable para pausa	
			
			let simulatedDate = new Date(); // Fecha inicial (actual)
			let lastTime = Date.now(); // Tiempo de referencia para animación

			// Mostrar la fecha y hora simulada en formato dd/mm/aaaa HH:mm:ss
			document.getElementById("dateDisplay").innerText = `${simulatedDate.toLocaleDateString("es-ES", {
				day: "2-digit",
				month: "2-digit",
				year: "numeric",
			})} ${simulatedDate.toLocaleTimeString("es-ES", {
				hour: "2-digit",
				minute: "2-digit",
				second: "2-digit",
			})}`;

			// Cuerpos celestes
			const CELESTIAL_BODIES = {
				star: {
					sun: { 
						periapsis: 6000000, apoapsis: 6000000, size: 1392000, color: 0xffff00, orbits: "galaxy", orbitalPeriod: 70000, 
						inclination: 0, argumentOfPeriapsis: 600000, longitudeOfAscendingNode: 0, lastPerihelion:  "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 7.25, rotationPeriod: 27 
					},
					/*
					sun: { //sol de prueba
						periapsis: 600000000, apoapsis: 600000000, size: 135000, color: 0xffffff, orbits: "galaxy", orbitalPeriod: 700000000000, 
						inclination: 7.25, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 0, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 7.25 , rotationPeriod: 27
					},*/
					/*suny: { //estrella artificial
						periapsis: 960000000, apoapsis: 998000000, size: 35000, color: 0xffff00, orbits: "sun", orbitalPeriod: 100, 
						inclination: 10, argumentOfPeriapsis: 181, longitudeOfAscendingNode: 0.33, lastPerihelion: "2024-01-07", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.034 
					},*/
					/*proximaCentauri: { 
						periapsis: 38370000000, apoapsis: 38370000000, size: 4220, color: 0xffffff, orbits: "galaxy", orbitalPeriod: 100000, 
						inclination: 0, argumentOfPeriapsis: 182, longitudeOfAscendingNode: 0, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0 , rotationPeriod: 27
					},
					alphaCentauriA: { 
						periapsis: 15000000000, apoapsis: 15050000000, size: 1103000, color: 0xffd700, orbits: "galaxy", orbitalPeriod: 80000, 
						inclination: 0, argumentOfPeriapsis: 90, longitudeOfAscendingNode: 0, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 30 , rotationPeriod: 27
					},
					alphaCentauriB: { 
						periapsis: 15010000000, apoapsis: 15060000000, size: 908000, color: 0xffc0cb, orbits: "galaxy", orbitalPeriod: 81000, 
						inclination: 1, argumentOfPeriapsis: 70, longitudeOfAscendingNode: 10, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 25 , rotationPeriod: 58.6
					},
					barnardsStar: { 
						periapsis: 1200000000, apoapsis: 1250000000, size: 196000, color: 0xff4500, orbits: "galaxy", orbitalPeriod: 120000, 
						inclination: 3, argumentOfPeriapsis: 50, longitudeOfAscendingNode: 0, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 5 , rotationPeriod: 58.6
					},*/
					/*wolf359: { 
						periapsis: 7400000000, apoapsis: 7600000000, size: 120000, color: 0xff6347, orbits: "galaxy", orbitalPeriod: 140000, 
						inclination: 4, argumentOfPeriapsis: 45, longitudeOfAscendingNode: 25, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 10 , rotationPeriod: 58.6
					},
					luyten726: { 
						periapsis: 9600000000, apoapsis: 9800000000, size: 170000, color: 0xff6347, orbits: "galaxy", orbitalPeriod: 150000, 
						orientation: 120, inclination: 5, argumentOfPeriapsis: 30, longitudeOfAscendingNode: 50, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 15 , rotationPeriod: 58.6
					},
					siriusA: { 
						periapsis: 8500000000, apoapsis: 8700000000, size: 1189640, color: 0xb0c4de, orbits: "galaxy", orbitalPeriod: 82000, 
						orientation: 25, inclination: 2, argumentOfPeriapsis: 40, longitudeOfAscendingNode: 20, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 7 , rotationPeriod: 58.6
					},
					siriusB: { 
						periapsis: 8600000000, apoapsis: 8800000000, size: 58430, color: 0xffffff, orbits: "galaxy", orbitalPeriod: 83000, 
						orientation: 25, inclination: 3, argumentOfPeriapsis: 35, longitudeOfAscendingNode: 30, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 10 , rotationPeriod: 58.6
					},
					epsilonEridani: { 
						periapsis: 10350000000, apoapsis: 10700000000, size: 869000, color: 0xffd700, orbits: "galaxy", orbitalPeriod: 95000, 
						orientation: 5, inclination: 6, argumentOfPeriapsis: 60, longitudeOfAscendingNode: 45, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 18 , rotationPeriod: 58.6
					},
					ross154: { 
						periapsis: 9400000000, apoapsis: 9600000000, size: 220000, color: 0xff4500, orbits: "galaxy", orbitalPeriod: 130000, 
						orientation: 45, inclination: 7, argumentOfPeriapsis: 15, longitudeOfAscendingNode: 35, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 8 , rotationPeriod: 58.6
					},
					aldebaran: { 
						periapsis: 15000000000, apoapsis: 15200000000, size: 44940000, color: 0xffa500, orbits: "galaxy", orbitalPeriod: 70000, 
						orientation: 90, inclination: 9, argumentOfPeriapsis: 80, longitudeOfAscendingNode: 10, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 40 , rotationPeriod: 58.6
					},
					altair: { 
						periapsis: 17000000000, apoapsis: 17500000000, size: 2000000, color: 0xffff00, orbits: "galaxy", orbitalPeriod: 85000, 
						orientation: 45, inclination: 10, argumentOfPeriapsis: 50, longitudeOfAscendingNode: 25, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 35 , rotationPeriod: 58.6
					},
					vega: { 
						periapsis: 17000000000, apoapsis: 17500000000, size: 2100000, color: 0xffe4b5, orbits: "galaxy", orbitalPeriod: 86000, 
						orientation: 55, inclination: 11, argumentOfPeriapsis: 65, longitudeOfAscendingNode: 35, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 30 , rotationPeriod: 58.6
					},
					deneb: { 
						periapsis: 20000000000, apoapsis: 20500000000, size: 20300000, color: 0xffffe0, orbits: "galaxy", orbitalPeriod: 95000, 
						orientation: 70, inclination: 12, argumentOfPeriapsis: 70, longitudeOfAscendingNode: 40, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 45 , rotationPeriod: 58.6
					},
					rigel: { 
						periapsis: 25000000000, apoapsis: 26000000000, size: 78000000, color: 0xadd8e6, orbits: "galaxy", orbitalPeriod: 120000, 
						orientation: 30, inclination: 13, argumentOfPeriapsis: 80, longitudeOfAscendingNode: 50, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 50 , rotationPeriod: 58.6
					},
					betelgeuse: { 
						periapsis: 30000000000, apoapsis: 31000000000, size: 887000000, color: 0xff4500, orbits: "galaxy", orbitalPeriod: 150000, 
						orientation: 15, inclination: 14, argumentOfPeriapsis: 90, longitudeOfAscendingNode: 55, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 60 , rotationPeriod: 58.6
					},
					polaris: { 
						periapsis: 18000000000, apoapsis: 18500000000, size: 3200000, color: 0xfffff0, orbits: "galaxy", orbitalPeriod: 87000, 
						orientation: 45, inclination: 15, argumentOfPeriapsis: 45, longitudeOfAscendingNode: 20, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 20 , rotationPeriod: 58.6
					},
					arcturus: { 
						periapsis: 15500000000, apoapsis: 15800000000, size: 26100000, color: 0xffd700, orbits: "galaxy", orbitalPeriod: 78000, 
						orientation: 25, inclination: 16, argumentOfPeriapsis: 75, longitudeOfAscendingNode: 60, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 15 , rotationPeriod: 58.6
					},
					antares: { 
						periapsis: 31000000000, apoapsis: 32000000000, size: 1183000000, color: 0xff6347, orbits: "galaxy", orbitalPeriod: 160000, 
						orientation: 40, inclination: 17, argumentOfPeriapsis: 85, longitudeOfAscendingNode: 65, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 65 , rotationPeriod: 58.6
					},
					canisMajoris: { 
						periapsis: 50000000000, apoapsis: 51000000000, size: 2450000000, color: 0xff6347, orbits: "galaxy", orbitalPeriod: 300000, 
						orientation: 75, inclination: 18, argumentOfPeriapsis: 100, longitudeOfAscendingNode: 70, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 75 , rotationPeriod: 58.6
					},
					alpheratz: { 
						periapsis: 19000000000, apoapsis: 19500000000, size: 2800000, color: 0xffffe0, orbits: "galaxy", orbitalPeriod: 91000, 
						orientation: 65, inclination: 19, argumentOfPeriapsis: 95, longitudeOfAscendingNode: 25, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 25 , rotationPeriod: 58.6
					},
					aldebaranB: { 
						periapsis: 16000000000, apoapsis: 16200000000, size: 1230000, color: 0xffc0cb, orbits: "galaxy", orbitalPeriod: 85000, 
						orientation: 45, inclination: 20, argumentOfPeriapsis: 35, longitudeOfAscendingNode: 30, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 10 , rotationPeriod: 58.6
					},
					capella: { 
						periapsis: 17500000000, apoapsis: 18000000000, size: 12200000, color: 0xffff00, orbits: "galaxy", orbitalPeriod: 89000, 
						orientation: 15, inclination: 21, argumentOfPeriapsis: 50, longitudeOfAscendingNode: 35, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 22 , rotationPeriod: 58.6
					},
					mizar: { 
						periapsis: 20000000000, apoapsis: 20500000000, size: 8000000, color: 0xb0e0e6, orbits: "galaxy", orbitalPeriod: 95000, 
						orientation: 35, inclination: 22, argumentOfPeriapsis: 75, longitudeOfAscendingNode: 40, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 30 , rotationPeriod: 58.6
					},
					alnilam: { 
						periapsis: 40000000000, apoapsis: 41000000000, size: 400000000, color: 0xadd8e6, orbits: "galaxy", orbitalPeriod: 200000, 
						orientation: 25, inclination: 23, argumentOfPeriapsis: 85, longitudeOfAscendingNode: 45, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 70 , rotationPeriod: 58.6
					},
					alnitak: { 
						periapsis: 39000000000, apoapsis: 39500000000, size: 370000000, color: 0x4682b4, orbits: "galaxy", orbitalPeriod: 190000, 
						orientation: 65, inclination: 24, argumentOfPeriapsis: 40, longitudeOfAscendingNode: 50, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 55 , rotationPeriod: 58.6
					},
					maia: { 
						periapsis: 21500000000, apoapsis: 22000000000, size: 11000000, color: 0xffd700, orbits: "galaxy", orbitalPeriod: 96000, 
						orientation: 75, inclination: 25, argumentOfPeriapsis: 60, longitudeOfAscendingNode: 55, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 35 , rotationPeriod: 58.6
					},
					pleione: { 
						periapsis: 21000000000, apoapsis: 21200000000, size: 9700000, color: 0xffe4b5, orbits: "galaxy", orbitalPeriod: 94000, 
						orientation: 45, inclination: 26, argumentOfPeriapsis: 55, longitudeOfAscendingNode: 60, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 28 , rotationPeriod: 58.6
					},
					electra: { 
						periapsis: 22000000000, apoapsis: 22500000000, size: 14000000, color: 0xffd700, orbits: "galaxy", orbitalPeriod: 98000, 
						orientation: 55, inclination: 27, argumentOfPeriapsis: 70, longitudeOfAscendingNode: 65, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 40 , rotationPeriod: 58.6
					},
					atlas: { 
						periapsis: 18500000000, apoapsis: 19000000000, size: 18000000, color: 0xffffe0, orbits: "galaxy", orbitalPeriod: 89000, 
						orientation: 65, inclination: 28, argumentOfPeriapsis: 75, longitudeOfAscendingNode: 20, lastPerihelion: "2024-01-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 18 , rotationPeriod: 58.6
					},*/
				},
				planets: {
					mercury: { 
						periapsis: 46000000, apoapsis: 69800000, size: 4879, color: 0xaaaaaa, orbits: "sun", orbitalPeriod: 88, 
						inclination: 7, argumentOfPeriapsis: 180.45, longitudeOfAscendingNode: 0.33, lastPerihelion: "2024-01-05", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.034, rotationPeriod: 58.6
					},
					venus: { 
						periapsis: 107480000, apoapsis: 108940000, size: 12104, color: 0xff9900, orbits: "sun", orbitalPeriod: 224.7, 
						inclination: 3.4, argumentOfPeriapsis: 180.53, longitudeOfAscendingNode: 0.68, lastPerihelion: "2023-08-13", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 177.36, rotationPeriod: -243 // Rotación retrógrada
					},
					earth: { 
						periapsis: 147090000, apoapsis: 152100000, size: 12742, color: 0x0000ff, orbits: "sun", orbitalPeriod: 365.25, 
						inclination: 0, argumentOfPeriapsis: 180.93, longitudeOfAscendingNode: 0, lastPerihelion: "2024-01-03", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 23.44, rotationPeriod: 1 
					},
					mars: { 
						periapsis: 206620000, apoapsis: 249230000, size: 6779, color: 0xff3300, orbits: "sun", orbitalPeriod: 687, 
						inclination: 1.85, argumentOfPeriapsis: 180.04, longitudeOfAscendingNode: 0.58, lastPerihelion: "2022-12-08", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 25.19, rotationPeriod: 1.03
					},
					jupiter: { 
						periapsis: 740520000, apoapsis: 816620000, size: 139820, color: 0xb5651d, orbits: "sun", orbitalPeriod: 4332.59, 
						inclination: 1.3, argumentOfPeriapsis: 180.75, longitudeOfAscendingNode: 0.49, lastPerihelion: "2023-11-03", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 3.13, rotationPeriod: 0.41
					},
					saturn: { 
						periapsis: 1352550000, apoapsis: 1514500000, size: 116460, color: 0xf4a460, orbits: "sun", orbitalPeriod: 10759.22, 
						inclination: 2.5, argumentOfPeriapsis: 180.43, longitudeOfAscendingNode: 0.66, lastPerihelion: "2023-08-27", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 26.73, rotationPeriod: 0.45
					},
					uranus: { 
						periapsis: 2741300000, apoapsis: 3006300000, size: 50724, color: 0x00ffff, orbits: "sun", orbitalPeriod: 30685, 
						inclination: 0.77, argumentOfPeriapsis: 170.96, longitudeOfAscendingNode: 0.01, lastPerihelion: "2030-09-23", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 97.77, rotationPeriod: -0.72 // Rotación retrógrada
					},
					neptune: { 
						periapsis: 4444400000, apoapsis: 4545700000, size: 49244, color: 0x0000ff, orbits: "sun", orbitalPeriod: 60190, 
						inclination: 1.77, argumentOfPeriapsis: 184.97, longitudeOfAscendingNode: 0.79, lastPerihelion: "2040-12-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 28.32, rotationPeriod: 0.67
					},
					/*mercury: { 
						periapsis: 46000000, apoapsis: 69800000, size: 4879, color: 0xaaaaaa, orbits: "sun", orbitalPeriod: 88, 
						inclination: 7.005, argumentOfPeriapsis: 29.124, longitudeOfAscendingNode: 48.331, lastPerihelion: "2024-01-05", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.034, rotationPeriod: 58.6
					},
					venus: { 
						periapsis: 107480000, apoapsis: 108940000, size: 12104, color: 0xff9900, orbits: "sun", orbitalPeriod: 224.7, 
						inclination: 3.394, argumentOfPeriapsis: 54.884, longitudeOfAscendingNode: 76.680, lastPerihelion: "2023-08-13", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 177.36, rotationPeriod: -243 // Rotación retrógrada
					},
					earth: { 
						periapsis: 147090000, apoapsis: 152100000, size: 12742, color: 0x0000ff, orbits: "sun", orbitalPeriod: 365.25, 
						inclination: 0.00005, argumentOfPeriapsis: 114.20783, longitudeOfAscendingNode: -11.26064, lastPerihelion: "2024-01-03", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 23.44, rotationPeriod: 1 
					},
					mars: { 
						periapsis: 206620000, apoapsis: 249230000, size: 6779, color: 0xff3300, orbits: "sun", orbitalPeriod: 687, 
						inclination: 1.850, argumentOfPeriapsis: 286.502, longitudeOfAscendingNode: 49.558, lastPerihelion: "2022-12-08", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 25.19, rotationPeriod: 1.03
					},
					jupiter: { 
						periapsis: 740520000, apoapsis: 816620000, size: 139820, color: 0xb5651d, orbits: "sun", orbitalPeriod: 4332.59, 
						inclination: 1.303, argumentOfPeriapsis: 273.867, longitudeOfAscendingNode: 100.464, lastPerihelion: "2023-11-03", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 3.13, rotationPeriod: 0.41
					},
					saturn: { 
						periapsis: 1352550000, apoapsis: 1514500000, size: 116460, color: 0xf4a460, orbits: "sun", orbitalPeriod: 10759.22, 
						inclination: 2.485, argumentOfPeriapsis: 339.392, longitudeOfAscendingNode: 113.665, lastPerihelion: "2023-08-27", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 26.73, rotationPeriod: 0.45
					},
					uranus: { 
						periapsis: 2741300000, apoapsis: 3006300000, size: 50724, color: 0x00ffff, orbits: "sun", orbitalPeriod: 30685, 
						inclination: 0.772, argumentOfPeriapsis: 96.998857, longitudeOfAscendingNode: 74.006, lastPerihelion: "2030-09-23", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 97.77, rotationPeriod: -0.72 // Rotación retrógrada
					},
					neptune: { 
						periapsis: 4444400000, apoapsis: 4545700000, size: 49244, color: 0x0000ff, orbits: "sun", orbitalPeriod: 60190, 
						inclination: 1.767, argumentOfPeriapsis: 276.336, longitudeOfAscendingNode: 131.784, lastPerihelion: "2040-12-01", 
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 28.32, rotationPeriod: 0.67
					},*/
				},
				satellites: {
					moon: { 
						periapsis: 363300 * 1, apoapsis: 405500 * 1, size: 3474, color: 0xcccccc, orbits: "earth", orbitalPeriod: 27.321,
						orientation: 180, inclination: 5.14, argumentOfPeriapsis: 41.5, longitudeOfAscendingNode: 125.08, lastPerihelion: "2024-01-03",
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 1.54 ,  rotationPeriod: 27.321
					},
					io: { 
						periapsis: 421700 * 1, apoapsis: 422000 * 1, size: 3643, color: 0xffa500, orbits: "jupiter", orbitalPeriod: 1.769, 
						orientation: 0, inclination: 0.05, argumentOfPeriapsis: 84.03, longitudeOfAscendingNode: 43.97, lastPerihelion: "2024-01-01",
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.04, rotationPeriod: 1.769
					},
					europa: { 
						periapsis: 670900 * 1, apoapsis: 676900 * 1, size: 3122, color: 0xffffff, orbits: "jupiter", orbitalPeriod: 3.551, 
						orientation: 0, inclination: 0.47, argumentOfPeriapsis: 88.97, longitudeOfAscendingNode: 219.11, lastPerihelion: "2024-01-01",
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.1, rotationPeriod: 3.551
					},
					ganymede: { 
						periapsis: 1070400 * 1, apoapsis: 1071600 * 1, size: 5268, color: 0xffff00, orbits: "jupiter", orbitalPeriod: 7.155, 
						orientation: 0, inclination: 0.2, argumentOfPeriapsis: 192.42, longitudeOfAscendingNode: 63.55, lastPerihelion: "2024-01-01",
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.03, rotationPeriod: 7.155
					},
					callisto: { 
						periapsis: 1882700 * 1, apoapsis: 1883300 * 1, size: 4821, color: 0x808080, orbits: "jupiter", orbitalPeriod: 16.689, 
						orientation: 0, inclination: 0.19, argumentOfPeriapsis: 52.64, longitudeOfAscendingNode: 298.84, lastPerihelion: "2024-01-01",
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.4, rotationPeriod: 16.689
					},
					titan: { 
						periapsis: 1186600 * 1, apoapsis: 1221860 * 1, size: 5150, color: 0xffcc99, orbits: "saturn", orbitalPeriod: 15.945, 
						orientation: 0, inclination: 0.3, argumentOfPeriapsis: 174.17, longitudeOfAscendingNode: 109.49, lastPerihelion: "2024-01-01",
						rotationAxis: { x: 0, y: 1, z: 0 }, axialTilt: 0.3, rotationPeriod: 15.945
					},
				},
				artificialSatellites: {
					iss: {
						periapsis: 6779*2, apoapsis: 6789*2, size: 108.5, color: "green", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 45, inclination: 51.64, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 258.76, lastPerihelion: "2023-12-01"
					},
					jwst: {
						periapsis: 1501371*2, apoapsis: 1501371*2, size: 15, color: "cyan", orbits: "earth", orbitalPeriod: 365.25,
						orientation: 120, inclination: 0.5, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 0, lastPerihelion: "2023-12-01"
					},
					hubble: {
						periapsis: 6911*2, apoapsis: 6921*2, size: 13.2, color: "silver", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 90, inclination: 28.47, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 96.49, lastPerihelion: "2023-11-28"
					},
					tiangong: {
						periapsis: 6761*2, apoapsis: 6771*2, size: 55, color: "red", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 45, inclination: 42.5, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 283.34, lastPerihelion: "2023-12-03"
					},
					landsat9: {
						periapsis: 7076*2, apoapsis: 7076*2, size: 4, color: "green", orbits: "earth", orbitalPeriod: 1.67,
						orientation: 90, inclination: 98.2, argumentOfPeriapsis: 120, longitudeOfAscendingNode: 14.8, lastPerihelion: "2023-12-02"
					},
					sentinel2a: {
						periapsis: 7157*2, apoapsis: 7157*2, size: 4.2, color: "blue", orbits: "earth", orbitalPeriod: 1.67,
						orientation: 90, inclination: 98.56, argumentOfPeriapsis: 90, longitudeOfAscendingNode: 128.7, lastPerihelion: "2023-12-01"
					},
					galileo: {
						periapsis: 29593*2, apoapsis: 29593*2, size: 2.4, color: "orange", orbits: "earth", orbitalPeriod: 14,
						orientation: 0, inclination: 56, argumentOfPeriapsis: 270, longitudeOfAscendingNode: 220.5, lastPerihelion: "2023-12-01"
					},
					glonass: {
						periapsis: 25471*2, apoapsis: 25471*2, size: 2.4, color: "red", orbits: "earth", orbitalPeriod: 11.26,
						orientation: 0, inclination: 64.8, argumentOfPeriapsis: 50, longitudeOfAscendingNode: 255.75, lastPerihelion: "2023-11-30"
					},
					starlink: {
						periapsis: 6921*2, apoapsis: 6921*2, size: 0.2, color: "gray", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 0, inclination: 53, argumentOfPeriapsis: 30, longitudeOfAscendingNode: 72.05, lastPerihelion: "2023-12-01"
					},
					gps3: {
						periapsis: 26571*2, apoapsis: 26571*2, size: 2.2, color: "gold", orbits: "earth", orbitalPeriod: 12,
						orientation: 0, inclination: 55, argumentOfPeriapsis: 270, longitudeOfAscendingNode: 115.7, lastPerihelion: "2023-11-29"
					},
					cosmos2542: {
						periapsis: 6771*2, apoapsis: 6771*2, size: 1.5, color: "darkgray", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 0, inclination: 51.6, argumentOfPeriapsis: 45, longitudeOfAscendingNode: 75.4, lastPerihelion: "2023-12-02"
					},
					aeolus: {
						periapsis: 6691*2, apoapsis: 6691*2, size: 4.4, color: "purple", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 0, inclination: 96.7, argumentOfPeriapsis: 20, longitudeOfAscendingNode: 102.3, lastPerihelion: "2023-12-01"
					},
					radarsat2: {
						periapsis: 7169*2, apoapsis: 7169*2, size: 4.3, color: "darkblue", orbits: "earth", orbitalPeriod: 1.67,
						orientation: 0, inclination: 98.6, argumentOfPeriapsis: 90, longitudeOfAscendingNode: 192.1, lastPerihelion: "2023-12-02"
					},
					terra: {
						periapsis: 7076*2, apoapsis: 7076*2, size: 4.8, color: "green", orbits: "earth", orbitalPeriod: 1.67,
						orientation: 0, inclination: 98.2, argumentOfPeriapsis: 75, longitudeOfAscendingNode: 104.7, lastPerihelion: "2023-12-01"
					},
					goes16: {
						periapsis: 42157*2, apoapsis: 42157*2, size: 3.1, color: "orange", orbits: "earth", orbitalPeriod: 24,
						orientation: 0, inclination: 0, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 75.2, lastPerihelion: "2023-12-01"
					},
					sentinel1a: {
						periapsis: 7064*2, apoapsis: 7064*2, size: 4, color: "blue", orbits: "earth", orbitalPeriod: 1.66,
						orientation: 0, inclination: 98.18, argumentOfPeriapsis: 60, longitudeOfAscendingNode: 210.4, lastPerihelion: "2023-12-01"
					},
					inmarSat: {
						periapsis: 42157*2, apoapsis: 42157*2, size: 3.2, color: "white", orbits: "earth", orbitalPeriod: 24,
						orientation: 0, inclination: 0, argumentOfPeriapsis: 0, longitudeOfAscendingNode: 25, lastPerihelion: "2023-12-01"
					},
					iridiumNEXT: {
						periapsis: 7151*2, apoapsis: 7151*2, size: 3, color: "silver", orbits: "earth", orbitalPeriod: 1.6,
						orientation: 0, inclination: 86.4, argumentOfPeriapsis: 30, longitudeOfAscendingNode: 95.3, lastPerihelion: "2023-12-01"
					},
					cosmos2543: {
						periapsis: 6771*2, apoapsis: 6771*2, size: 1.5, color: "gray", orbits: "earth", orbitalPeriod: 1.5,
						orientation: 0, inclination: 51.6, argumentOfPeriapsis: 45, longitudeOfAscendingNode: 76.1, lastPerihelion: "2023-12-02"
					},
				},
				comets: {
					halley: { 
						periapsis: 87870000, apoapsis: 5247100000, size: 11*500, color: 0xffffff, orbits: "sun", orbitalPeriod: 27740, 
						orientation: 58.42, inclination: 162.26, argumentOfPeriapsis: 111.33, longitudeOfAscendingNode: 58.42, lastPerihelion: "1986-02-09" 
					},
					encke: { 
						periapsis: 50917500, apoapsis: 611150000, size: 4.8*1000, color: 0x87ceeb, orbits: "sun", orbitalPeriod: 1205.325, 
						orientation: 334.57, inclination: 11.78, argumentOfPeriapsis: 186.45, longitudeOfAscendingNode: 334.57, lastPerihelion: "2023-11-22" 
					},
					hale_bopp: {
						periapsis: 136680000, apoapsis: 55350000000, size: 60*500, color: 0xadd8e6, orbits: "sun", orbitalPeriod: 919200, 
						orientation: 282.47, inclination: 89.4, argumentOfPeriapsis: 130.59, longitudeOfAscendingNode: 282.47, lastPerihelion: "1997-04-01" 
					},
				},
			};
			
			// Cargador de texturas
			const textureLoader = new THREE.TextureLoader();

			// Texturas específicas para cada cuerpo celeste
			const celestialBodiesTextures = {	
				sun: {
					map: textureLoader.load('./img/celestial_bodies/2k_sun.jpg'),
				},
				mercury: {
					map: textureLoader.load('./img/celestial_bodies/2k_mercury.jpg'),
				},
				venus: {
					map: textureLoader.load('./img/celestial_bodies/2k_venus_surface.jpg'),
				},
				earth: {
					map: textureLoader.load('./img/celestial_bodies/2k_earth_daymap.jpg'),
					bumpMap: textureLoader.load('./img/celestial_bodies/2k_earth_normal_map.jpg'),
					bumpScale: 0.05,
					cloudsMap: textureLoader.load('./img/celestial_bodies/2k_earth_clouds.jpg'),
					textureMeridianOffset: 180 // La textura comienza en el meridiano 180°
				},
				mars: {
					map: textureLoader.load('./img/celestial_bodies/2k_mars.jpg'),
					textureMeridianOffset: 0 // La textura comienza en el meridiano 0°
				},
				jupiter: {
					map: textureLoader.load('./img/celestial_bodies/2k_jupiter.jpg'),
				},
				saturn: {
					map: textureLoader.load('./img/celestial_bodies/2k_saturn.jpg'),
					mapRing: textureLoader.load('./img/celestial_bodies/2k_saturn_ring_alpha.png'),
				},
				uranus: {
					map: textureLoader.load('./img/celestial_bodies/2k_uranus.jpg'),
				},
				neptune: {
					map: textureLoader.load('./img/celestial_bodies/2k_neptune.jpg'),
				},
				moon: {
					map: textureLoader.load('./img/celestial_bodies/2k_moon.jpg'),
					bumpMap: textureLoader.load('./img/celestial_bodies/2k_moon_bump.jpg'),
					bumpScale: 0.002,
				},
			};
			
			/*
			// Crear una instancia de GLTFLoader
			const gltfLoader = new THREE.GLTFLoader();

			// Cargar el modelo 3D de la ISS
			loader.load(
				'./models/celestial/bodies/InternationalSpaceStation.glb',
				(gltf) => {
					const iss = celestialObjects['iss'];
					if (!iss) {
						console.warn('ISS no encontrada en celestialObjects.');
						return;
					}

					// Posicionar el modelo en la posición de la ISS
					const issPosition = new THREE.Vector3();
					iss.getWorldPosition(issPosition);

					gltf.scene.position.copy(issPosition);
					gltf.scene.scale.set(0.1, 0.1, 0.1); // Ajustar escala
					gltf.scene.rotation.set(0, Math.PI / 2, 0); // Ajustar orientación

					// Agregar el modelo a la escena
					scene.add(gltf.scene);
					console.log('Modelo de la ISS añadido correctamente.');
				},
				undefined,
				(error) => {
					console.error('Error al cargar el modelo de la ISS:', error);
				}
			);
			*/
			
			// Inicializar ángulos y objetos
			const angles = {};
			const celestialObjects = {};
			
			// Calcular ángulos iniciales
			Object.keys(CELESTIAL_BODIES).forEach((category) => {
				Object.keys(CELESTIAL_BODIES[category]).forEach((name) => {
					const body = CELESTIAL_BODIES[category][name];
					if (body.orbitalPeriod !== Infinity) {
						const perihelionDate = new Date(body.lastPerihelion);
						const daysSincePerihelion = (new Date() - perihelionDate) / (1000 * 60 * 60 * 24); // Días desde el perihelio
						const fractionOfOrbit = daysSincePerihelion / body.orbitalPeriod;
						angles[name] = 2 * Math.PI * fractionOfOrbit; // Ángulo inicial en radianes

						// Registrar la inclinación para referencia
						if (typeof body.inclination === "undefined") {
							console.warn(`${name} no tiene inclinación definida. Se usará 0 por defecto.`);
							body.inclination = 0; // Asegurar que todos los cuerpos tienen inclinación
						}
					}
				});
			});	
			
			//dev
/*			
			const eclipticPlaneGeometry = new THREE.PlaneGeometry(50000, 50000); // Ajustar tamaño del plano
const eclipticPlaneMaterial = new THREE.MeshBasicMaterial({
    color: 0x00ff00, // Verde para referencia
    side: THREE.DoubleSide,
    opacity: 0.2,
    transparent: true,
});
const eclipticPlane = new THREE.Mesh(eclipticPlaneGeometry, eclipticPlaneMaterial);
eclipticPlane.rotation.x = Math.PI / 2; // Alinear con el plano XY
scene.add(eclipticPlane);
*/
/*
function drawAdjustedAxes(scene, length = 1000) {
    const axesGroup = new THREE.Group();

    // Eje X (Rojo) - sin cambios
    const xAxisMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Rojo
    const xAxisGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(length, 0, 0),
    ]);
    const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);

    // Eje Z (Azul) - lo usaremos como "arriba"
    const zAxisMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff }); // Azul
    const zAxisGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 0, length),
    ]);
    const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);

    // Eje Y (Verde) - lo ajustamos a "profundidad"
    const yAxisMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 }); // Verde
    const yAxisGeometry = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, length, 0),
    ]);
    const yAxis = new THREE.Line(yAxisGeometry, yAxisMaterial);

    // Añadir los ejes al grupo
    axesGroup.add(xAxis);
    axesGroup.add(yAxis);
    axesGroup.add(zAxis);

    // Añadir el grupo a la escena
    scene.add(axesGroup);
}

// Llamar a la función para dibujar los ejes ajustados
drawAdjustedAxes(scene, 50000); // Ajusta el tamaño (5000) según sea necesario
*/

			// Crear una luz puntual y una esfera luminosa para el centro de la galaxia
			const galaxyGeometry = new THREE.SphereGeometry(0, 32, 32); // Tamaño y resolución de la esfera
			const galaxyMat = new THREE.MeshStandardMaterial({
				emissive: 0xffff00, // Luz cálida
				emissiveIntensity: 1,
				color: 0x000000, // Color base negro para resaltar el brillo
			});

			// Crear la luz para el centro galáctico
			const galaxyLight = new THREE.PointLight(0xffff00, 2, 5000, 2); // Luz puntual con intensidad y alcance
			const galaxyMesh = new THREE.Mesh(galaxyGeometry, galaxyMat); // Malla para representar la luz

			// Adjuntar la esfera luminosa al punto de luz
			galaxyLight.add(galaxyMesh); // La luz incluye la malla visual
			galaxyLight.position.set(0, 0, 0); // Posicionar el centro de la galaxia en el origen
			galaxyLight.castShadow = true; // Habilitar sombras proyectadas desde el centro galáctico

			// Agregar el centro de la galaxia a la escena
			scene.add(galaxyLight);

			// Guardar el centro galáctico en el objeto celestialObjects para futuras referencias
			celestialObjects["galaxy"] = galaxyLight;
			
			// Crear un array para los objetos interactuables
			const interactableObjects = [];

			// Crear cuerpos celestes y sus órbitas
			Object.keys(CELESTIAL_BODIES).forEach((category) => {
				Object.keys(CELESTIAL_BODIES[category]).forEach((name) => {
					const body = CELESTIAL_BODIES[category][name];
					
					if (category === "star") {
						// Para otros cuerpos celestes
						const textures = celestialBodiesTextures [name] || {};
						
						// Crear la geometría y el material del cuerpo celeste
						const geometry = new THREE.SphereGeometry(body.size * SCALE_SIZE, 64, 64);
						
						var alcance = 0;
						if (name === "sun"){
							alcance = 1000000; // Ajustar el alcance para el Sol
						} else {
							alcance = 100000; ; // Ajustar el alcance para estrellas
						}
						
						const mesh = new THREE.PointLight(0xffffff, 1, alcance, 2); // Ajustar el alcance para el Sol
						const materialOptions = {
								map: textures.map || null, // Usa la textura del mapa si está disponible
								bumpMap: textures.bumpMap || null, // Usa el bumpMap si está disponible
								bumpScale: textures.bumpScale || 0, // Ajusta el bumpScale si está disponible
								color: !textures.map ? body.color : null, // Si no hay textura, usa el color del cuerpo
								emissive: 0xffff00, // Luz cálida
								emissiveIntensity: 1,
							};				
						const material = new THREE.MeshStandardMaterial(materialOptions);						
						
						// Adjuntar la esfera luminosa al punto de luz
						mesh.add(new THREE.Mesh(geometry , material));
						mesh.position.set(0, 0, 0); // Posicionar el Sol en el centro
						
						mesh.castShadow = body.size * SCALE_SIZE >= 1; // Habilitar sombras solo para objetos suficientemente grandes

						if (mesh.castShadow) {
							const shadowMapSize = Math.min(4096, Math.max(512, body.size * 2)); // Ajustar resolución de sombras
							mesh.shadow.mapSize.width = shadowMapSize;
							mesh.shadow.mapSize.height = shadowMapSize;

							mesh.shadow.camera.near = Math.max(0.1, body.size * SCALE_SIZE * 0.5); // Ajustar rango cercano
							mesh.shadow.camera.far = Math.min(50000, body.size * SCALE_SIZE * 10); // Ajustar rango lejano

							// Ajustar intensidad de sombras para objetos grandes/pequeños
							const shadowIntensityFactor = body.size * SCALE_SIZE > 10 ? 1 : 0.5; 
							mesh.shadow.intensity = shadowIntensityFactor;
						}
						
						// Aplicar inclinación axial (si existe)
						if (body.axialTilt) {
							mesh.rotation.z = THREE.MathUtils.degToRad(body.axialTilt); // Inclinar el eje según `axialTilt`
						}	
						
						// **Cálculo de rotación inicial sincronizada**
						if (body.rotationPeriod && textures.textureMeridianOffset !== undefined) {
							const initialRotation = calculateInitialRotation(
								textures.textureMeridianOffset,
								body.rotationPeriod,
								new Date()
							);

							mesh.rotation.y += initialRotation; // Aplicar la rotación inicial
						}

						// Calcular la posición inicial del cuerpo celeste
						const position = calculateRelativePosition(
							angles[name],
							body.periapsis,
							body.apoapsis,
							body.longitudeOfAscendingNode,
							body.inclination,
							body.argumentOfPeriapsis
						);

						// Si el cuerpo orbita otro cuerpo, ajusta su posición
						if (body.orbits && celestialObjects[body.orbits]) {
							const centralPosition = celestialObjects[body.orbits].position;
							position.add(centralPosition);
						}
						
						// Establecer la posición del mesh
						mesh.position.set(position.x, position.y, position.z);
						
						
						// Asegurarse de que los objetos tengan geometría y posiciones actualizadas
						//mesh.geometry.computeBoundingSphere();
						mesh.updateMatrixWorld();
						interactableObjects.push(mesh);
						// Agregar el mesh a la escena
						scene.add(mesh);
						// Agregar el mesh al objeto `celestialObjects`
						celestialObjects[name] = mesh;
						
						// Dibujar la órbita del cuerpo celeste
						/*
						const orbit = drawOrbit(
							angles[name],
							body.periapsis,
							body.apoapsis,
							body.longitudeOfAscendingNode,
							body.inclination,
							body.argumentOfPeriapsis,
							body.color,
							body.orbits && celestialObjects[body.orbits]
								? celestialObjects[body.orbits].position
								: new THREE.Vector3(0, 0, 0)
						);

						if (orbit) {
							scene.add(orbit);
							celestialObjects[name].orbit = orbit;
						}*/
					} else {
						// Para otros cuerpos celestes
						const textures = celestialBodiesTextures [name] || {};
						
						const geometry = new THREE.SphereGeometry(body.size * SCALE_SIZE, 64, 64);						
						// Si es una estrella, agregar una luz puntual

						const materialOptions = {
							map: textures.map || null, // Usa la textura del mapa si está disponible
							bumpMap: textures.bumpMap || null, // Usa el bumpMap si está disponible
							bumpScale: textures.bumpScale || 0, // Ajusta el bumpScale si está disponible
							color: !textures.map ? body.color : null, // Si no hay textura, usa el color del cuerpo
						};
						const material = new THREE.MeshStandardMaterial(materialOptions);
						const mesh = new THREE.Mesh(geometry, material);
						
						// Habilitar sombras en los cuerpos celestes
						mesh.castShadow = true; // El cuerpo celeste proyecta sombras
						mesh.receiveShadow = true; // El cuerpo celeste recibe sombras		
						
						// Aplicar inclinación axial (si existe)
						if (body.axialTilt) {
							mesh.rotation.z = THREE.MathUtils.degToRad(body.axialTilt); // Inclinar el eje según `axialTilt`
						}
						
						// **Cálculo de rotación inicial sincronizada**
						if (body.rotationPeriod && textures.textureMeridianOffset !== undefined) {
							const initialRotation = calculateInitialRotation(
								textures.textureMeridianOffset,
								body.rotationPeriod,
								new Date()
							);

							mesh.rotation.y += initialRotation; // Aplicar la rotación inicial
						}

						const position = calculateRelativePosition(
							angles[name],
							body.periapsis,
							body.apoapsis,
							body.longitudeOfAscendingNode,
							body.inclination,
							body.argumentOfPeriapsis
						);

						if (body.orbits && celestialObjects[body.orbits]) {
							const centralPosition = celestialObjects[body.orbits].position;
							position.add(centralPosition);
						}

						mesh.position.set(position.x, position.y, position.z);
						
						// Asegurarse de que los objetos tengan geometría y posiciones actualizadas
						mesh.geometry.computeBoundingSphere();
						mesh.updateMatrixWorld();
						
						// Asocia el nombre del cuerpo celeste con el objeto
						mesh.userData = {
							name: name,
						};
						
						scene.add(mesh);
						
						// Hacer interactuable
						interactableObjects.push(mesh);
						
						celestialObjects[name] = mesh;
						
						/*
						// Crear una esfera auxiliar más grande para detección de clics
						const boundingGeometry = new THREE.SphereGeometry(body.size * SCALE_SIZE * 5.5, 8, 8); // Aumenta el tamaño para clics más fáciles
						const boundingMaterial = new THREE.MeshBasicMaterial({
							visible: true, // Invisible en la escena
							transparent:true,
							opacity: 0.1,
						});
						const boundingMesh = new THREE.Mesh(boundingGeometry, boundingMaterial);						

						// Sincronizar la posición con el cuerpo principal
						boundingMesh.userData = { name: name }; // También asignar el nombre
						scene.add(boundingMesh);
						interactableObjects.push(boundingMesh);	
						mesh.add(boundingMesh);
						*/
						
						// Si es la Tierra, agregar las nubes
						if (name === "earth" && textures.cloudsMap) {
							const cloudGeometry = new THREE.SphereGeometry(body.size * SCALE_SIZE * 1.01, 64, 64);
							const cloudMaterial = new THREE.MeshPhongMaterial({
								map: textures.cloudsMap,
								transparent: true,
								opacity: 0.8,
							});
							const cloudMesh = new THREE.Mesh(cloudGeometry, cloudMaterial);
							mesh.add(cloudMesh);
							/*const atmosphereMaterial = new THREE.ShaderMaterial({
								uniforms: {
									uLightPosition: { value: new THREE.Vector3(1, 1, 1) }, // Posición de la luz (por ejemplo, el sol)
									uPlanetPosition: { value: new THREE.Vector3(0, 0, 0) }, // Posición del planeta
									uAtmosphereRadius: { value: 1.5 }, // Radio de la atmósfera (mayor que el planeta)
									uPlanetRadius: { value: 1.0 }, // Radio del planeta
									uLightIntensity: { value: 1.0 }, // Intensidad de la luz
									uColor: { value: new THREE.Color(0x87CEEB) } // Color de la atmósfera (por ejemplo, azul cielo)
								},
								vertexShader: `
									varying vec3 vWorldPosition;

									void main() {
										vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
										gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
									}
								`,
								fragmentShader: `
									uniform vec3 uLightPosition;
									uniform vec3 uPlanetPosition;
									uniform float uAtmosphereRadius;
									uniform float uPlanetRadius;
									uniform float uLightIntensity;
									uniform vec3 uColor;

									varying vec3 vWorldPosition;

									void main() {
										// Distancia desde la posición actual al centro del planeta
										float distanceFromCenter = length(vWorldPosition - uPlanetPosition);

										// Normalizar el vector hacia la luz
										vec3 lightDirection = normalize(uLightPosition - vWorldPosition);

										// Factor de dispersión de luz (simula la dispersión atmosférica)
										float lightScatter = max(dot(lightDirection, normalize(vWorldPosition - uPlanetPosition)), 0.0);
										lightScatter = pow(lightScatter, 2.0); // Ajusta el efecto de dispersión

										// Atenuar la atmósfera hacia los bordes
										float atmosphereFactor = smoothstep(uPlanetRadius, uAtmosphereRadius, distanceFromCenter);

										// Color final de la atmósfera
										vec3 atmosphereColor = uColor * lightScatter * atmosphereFactor * uLightIntensity;

										gl_FragColor = vec4(atmosphereColor, atmosphereFactor * 0.8); // Alpha ajustado para transparencia
									}
								`,
								transparent: true, // Hacer que la atmósfera sea transparente
								side: THREE.BackSide // Renderizar solo la parte interior de la esfera de la atmósfera
							});
							const atmosphere = new THREE.Mesh(
								new THREE.SphereGeometry(body.size * SCALE_SIZE * 1.1, 32, 32),
								atmosphereMaterial
							);
							mesh.add(atmosphere);*/
						} else if (name === "saturn") {
							 // Crear los anillos de Saturno
							const ringGeometry = new THREE.RingGeometry(
								body.size * SCALE_SIZE * 1.2, // Radio interno del anillo
								body.size * SCALE_SIZE * 2.5, // Radio externo del anillo
								128 // Resolución angular (mayor valor para suavidad)
							);

							// Modificar las coordenadas UV para que mapeen correctamente desde el centro hacia afuera
							const uv = ringGeometry.attributes.uv;
							for (let i = 0; i < uv.count; i++) {
								const u = uv.getX(i);
								const v = uv.getY(i);
								const radius = Math.sqrt((u - 0.5) ** 2 + (v - 0.5) ** 2); // Radio normalizado

								// Mapeo de la textura desde el centro del anillo (izquierda de la imagen) hacia afuera (derecha de la imagen)
								uv.setXY(i, radius, radius);
							}

							// Actualizar el atributo UV en la geometría
							ringGeometry.attributes.uv.needsUpdate = true;

							// Crear el material para los anillos
							const ringMaterial = new THREE.MeshStandardMaterial({
								map: celestialBodiesTextures .saturn.mapRing, // Textura del anillo
								side: THREE.DoubleSide, // Renderizar ambos lados
								transparent: true, // Habilitar transparencia
							});

							// Crear el mesh de los anillos
							const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
							
							// Habilitar sombras en los anillos
							ringMesh.castShadow = false; // Proyecta sombras
							ringMesh.receiveShadow = true; // Recibe sombras

							// Rotar los anillos para colocarlos en el plano ecuatorial de Saturno
							ringMesh.rotation.x = THREE.MathUtils.degToRad(90); // Plano horizontal
							ringMesh.rotation.z = THREE.MathUtils.degToRad(body.axialTilt); // Ajustar inclinación de los anillos
							
							// Añadir los anillos como hijo del planeta
							mesh.add(ringMesh);
						}						
						
						const orbit = drawOrbit(
							angles[name],
							body.periapsis,
							body.apoapsis,
							body.longitudeOfAscendingNode,
							body.inclination,
							body.argumentOfPeriapsis,
							body.color,
							body.orbits && celestialObjects[body.orbits]
								? celestialObjects[body.orbits].position
								: new THREE.Vector3(0, 0, 0)
						);

						if (orbit) {
							scene.add(orbit);
							celestialObjects[name].orbit = orbit;
						}
					}
				});
			});		
			
			function calculateInitialRotation(textureMeridianOffset, rotationPeriod, date = new Date()) {
				// Hora UTC en fracciones de día
				const nowUTC = date.getUTCHours() / 24 + date.getUTCMinutes() / (24 * 60) + date.getUTCSeconds() / (24 * 3600);

				// Desplazamiento del meridiano inicial (convertir a fracciones de rotación)
				const textureOffset = textureMeridianOffset / 360;

				// Rotación inicial en fracciones del periodo de rotación
				const rotationFraction = nowUTC / rotationPeriod;

				// Combinar el desplazamiento inicial y la rotación actual
				const totalRotationFraction = (rotationFraction + textureOffset) % 1;

				// Convertir a ángulo en radianes
				return totalRotationFraction * 2 * Math.PI;
			}
			
			// Rotación para los planetas
			function rotateCelestialBody(mesh, rotationAxis, axialTilt, rotationSpeed, deltaTime, simulatedDate, precessionRate = 0) {
				// Calcular años desde la referencia (2024)
				const yearsSince2024 = (simulatedDate.getFullYear() - 2024) + simulatedDate.getMonth() / 12;

				// Aplicar precesión axial (si el planeta tiene precesión)
				if (precessionRate > 0) {
					const precessionAngle = THREE.MathUtils.degToRad(yearsSince2024 * precessionRate);
					const precessionAxis = new THREE.Vector3(0, 1, 0); // Precesión alrededor del eje Y galáctico
					rotationAxis.applyAxisAngle(precessionAxis, precessionAngle);
				}

				// Aplicar inclinación axial
				const tiltAxis = new THREE.Vector3(rotationAxis.x, rotationAxis.y, rotationAxis.z);
				tiltAxis.applyAxisAngle(new THREE.Vector3(0, 0, 1), THREE.MathUtils.degToRad(axialTilt));

				// Rotar el cuerpo alrededor de su eje inclinado
				mesh.rotateOnAxis(tiltAxis, rotationSpeed * deltaTime);
			}

			// Calcular posición relativa
			function calculateRelativePosition(angle, periapsis, apoapsis, longitudeOfAscendingNode = 0, inclination = 0, argumentOfPeriapsis = 0, centralPosition = new THREE.Vector3(0, 0, 0)) {
				if (!periapsis || !apoapsis || periapsis <= 0 || apoapsis <= 0) {
					return new THREE.Vector3(0, 0, 0); // Valores inválidos
				}

				// Convertir ángulos de grados a radianes
				const inclinationRad = THREE.MathUtils.degToRad(inclination);
				const longitudeOfAscendingNodeRad = THREE.MathUtils.degToRad(longitudeOfAscendingNode);
				const argumentOfPeriapsisRad = THREE.MathUtils.degToRad(argumentOfPeriapsis);

				// Semiejes mayor y menor
				const semiMajorAxis = (apoapsis + periapsis) / 2 * SCALE_DISTANCE;
				const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - Math.pow((apoapsis - periapsis) / (apoapsis + periapsis), 2));

				// Desplazamiento al foco
				const focusOffset = semiMajorAxis - (periapsis * SCALE_DISTANCE);

				// Posición en coordenadas polares (en el plano orbital)
				const x = focusOffset + semiMajorAxis * Math.cos(angle);
				const z = semiMinorAxis * Math.sin(angle);
				const position = new THREE.Vector3(x, 0, z);

				// Aplicar transformaciones orbitales en el orden correcto
				// 1. Rotación por nodo ascendente (alrededor del eje Z)
				position.applyAxisAngle(new THREE.Vector3(0, 0, 1), longitudeOfAscendingNodeRad);

				// 2. Rotación por inclinación (alrededor del eje X)
				position.applyAxisAngle(new THREE.Vector3(1, 0, 0), inclinationRad);

				// 3. Rotación por argumento del periapsis (en el plano orbital)
				position.applyAxisAngle(new THREE.Vector3(0, 0, 1), argumentOfPeriapsisRad);

				// Ajustar posición relativa al cuerpo central
				position.add(centralPosition);

				return position;
			}


			// Dibujar órbita
			function drawOrbit(name, periapsis, apoapsis, longitudeOfAscendingNode = 0, inclination = 0, argumentOfPeriapsis = 0, color, centralPosition = new THREE.Vector3(0, 0, 0)) {
				if (!periapsis || !apoapsis || periapsis <= 0 || apoapsis <= 0) {
					console.warn(`${name} Los valores de periapsis o apoapsis no son válidos para dibujar una órbita.`);
					return null; // Valores inválidos
				}

				const semiMajorAxis = (apoapsis + periapsis) / 2 * SCALE_DISTANCE;
				const semiMinorAxis = semiMajorAxis * Math.sqrt(1 - Math.pow((apoapsis - periapsis) / (apoapsis + periapsis), 2));
				const focusOffset = semiMajorAxis - (periapsis * SCALE_DISTANCE);

				const points = [];
				for (let angle = 0; angle <= Math.PI * 2; angle += 0.01) {
					// Coordenadas iniciales (en el plano orbital sin transformaciones)
					const x = focusOffset + semiMajorAxis * Math.cos(angle);
					const z = semiMinorAxis * Math.sin(angle);
					const position = new THREE.Vector3(x, 0, z);

					// Aplicar transformaciones orbitales en el orden correcto
					// 1. Rotación por nodo ascendente
					position.applyAxisAngle(new THREE.Vector3(0, 0, 1), THREE.MathUtils.degToRad(longitudeOfAscendingNode));

					// 2. Rotación por inclinación
					position.applyAxisAngle(new THREE.Vector3(1, 0, 0), THREE.MathUtils.degToRad(inclination));

					// 3. Rotación por argumento del periapsis
					position.applyAxisAngle(new THREE.Vector3(0, 0, 1), THREE.MathUtils.degToRad(argumentOfPeriapsis));

					// Ajustar posición respecto al cuerpo central
					position.add(centralPosition);
					points.push(position);
				}

				const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
				const orbitMaterial = new THREE.LineBasicMaterial({ color });
				return new THREE.LineLoop(orbitGeometry, orbitMaterial);
			}

			
			// Animación
			function animate() {
				requestAnimationFrame(animate);

				const currentTime = Date.now();
				const elapsed = (currentTime - lastTime) / 1000; // Tiempo transcurrido en segundos
				lastTime = currentTime;
				
				if (!isPaused) {
					const daysToAdvance = elapsed * speedFactor; // Avanzar en función de la velocidad actual
					simulatedDate = new Date(simulatedDate.getTime() + daysToAdvance * 24 * 60 * 60 * 1000);
					
					// Actualizar controles de la cámara
					updateCameraControls(elapsed);
					
					Object.keys(CELESTIAL_BODIES).forEach((category) => {
						Object.keys(CELESTIAL_BODIES[category]).forEach((name) => {
							const body = CELESTIAL_BODIES[category][name];
							if (body.orbitalPeriod !== Infinity) {
								const angularSpeed = (2 * Math.PI) / body.orbitalPeriod; // Velocidad angular en rad/día
								angles[name] += angularSpeed * daysToAdvance; // Avanzar el ángulo

								let position = calculateRelativePosition(
									angles[name],
									body.periapsis,
									body.apoapsis,
									body.longitudeOfAscendingNode,								
									body.inclination,
									body.argumentOfPeriapsis
								);

								if (body.orbits && celestialObjects[body.orbits]) {
									const centralPosition = celestialObjects[body.orbits].position;
									position.add(centralPosition); // Añadir posición del cuerpo central
								}

								celestialObjects[name].position.set(position.x, position.y, position.z);

								// Actualizar órbita si está definida
								if (celestialObjects[name].orbit) {
									const centralPosition = body.orbits && celestialObjects[body.orbits]
										? celestialObjects[body.orbits].position
										: new THREE.Vector3(0, 0, 0);

									const updatedOrbit = drawOrbit(
										angles[name],
										body.periapsis,
										body.apoapsis,
										body.longitudeOfAscendingNode,									
										body.inclination,
										body.argumentOfPeriapsis,									
										body.color,
										centralPosition
									);

									// Reemplazar la geometría de la órbita
									celestialObjects[name].orbit.geometry.copy(updatedOrbit.geometry);
								}
								
								const rotationSpeed = (2 * Math.PI / (body.rotationPeriod || 1)) * speedFactor; // Velocidad de rotación (en radianes/seg)
								const deltaTime = elapsed; // Tiempo transcurrido entre cuadros

								rotateCelestialBody(
									celestialObjects[name],
									body.rotationAxis || { x: 0, y: 1, z: 0 },
									body.axialTilt || 0,
									rotationSpeed,
									deltaTime,
									simulatedDate,
									body.precessionRate || 0 // Nuevo atributo en CELESTIAL_BODIES
								);

							}
						});
					});
					
				}

				// Mostrar la fecha y hora simulada
				document.getElementById("dateDisplay").innerText = `${simulatedDate.toLocaleDateString("es-ES", {
					day: "2-digit",
					month: "2-digit",
					year: "numeric",
				})} ${simulatedDate.toLocaleTimeString("es-ES", {
					hour: "2-digit",
					minute: "2-digit",
					second: "2-digit",
				})}`;
				
				renderer.render(scene, camera);
			}

//////////////////////////////////////////////////////////////////////////////////////////////
			
			// Crear el Raycaster y el vector para las coordenadas del ratón
			const raycaster = new THREE.Raycaster();
			const mouse = new THREE.Vector2();

			// Contenedor para la información del cuerpo celeste
			let infoDiv = null;

			// Evento de clic en el canvas
			renderer.domElement.addEventListener("mousedown", (event) => {
				// Solo responder a clics en el canvas
				if (event.target !== renderer.domElement) return;

				const rect = renderer.domElement.getBoundingClientRect();

				// Calcular coordenadas del ratón normalizadas
				mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
				mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

				// Forzar actualización de la cámara y la escena antes del raycasting
				camera.updateMatrixWorld();
				scene.updateMatrixWorld();

				// Configurar el raycaster
				raycaster.setFromCamera(mouse, camera);

				// Determinar las intersecciones
				const intersects = raycaster.intersectObjects(interactableObjects, true);

				console.log("Intersecciones detectadas:", intersects);

				if (intersects.length > 0) {
					const clickedObject = intersects[0].object;
					const bodyName = clickedObject.userData.name;

					if (bodyName) {
						console.log(`Hiciste clic en: ${bodyName}`);
						renderCelestialBodyInfo(bodyName); // Mostrar información
						focusOnCelestialBody(bodyName);   // Enfocar en el cuerpo celeste
					}
				}
			});

			// Función para renderizar información del cuerpo celeste
			function renderCelestialBodyInfo(bodyName) {
				const body =
					CELESTIAL_BODIES.planets[bodyName] ||
					CELESTIAL_BODIES.satellites[bodyName] ||
					CELESTIAL_BODIES.comets[bodyName] ||
					CELESTIAL_BODIES.star[bodyName];

				if (body) {
					// Si ya existe un contenedor, elimínalo
					if (infoDiv) {
						infoDiv.remove();
					}

					// Crear un contenedor HTML para la información
					infoDiv = document.createElement("div");
					infoDiv.style.position = "absolute";
					infoDiv.style.top = "10px";
					infoDiv.style.right = "10px";
					infoDiv.style.padding = "10px";
					infoDiv.style.backgroundColor = "rgba(0, 0, 0, 0.9)";
					infoDiv.style.color = "white";
					infoDiv.style.border = "1px solid white";
					infoDiv.style.zIndex = "1000";
					infoDiv.style.maxWidth = "300px";
					infoDiv.innerHTML = `
						<h2>${bodyName}</h2>
						<p><strong>Periapsis:</strong> ${body.periapsis} km</p>
						<p><strong>Apoapsis:</strong> ${body.apoapsis} km</p>
						<p><strong>Tamaño:</strong> ${body.size} km</p>
						<p><strong>Inclinación:</strong> ${body.inclination}°</p>
						<p><strong>Periodo Orbital:</strong> ${body.orbitalPeriod} días</p>
						<button id="closeInfoBtn" style="margin-top: 10px; padding: 5px 10px; background: red; color: white; border: none; cursor: pointer;">Cerrar</button>
					`;

					// Agregarlo al documento
					document.body.appendChild(infoDiv);

					// Agregar evento para cerrar la información
					document.getElementById("closeInfoBtn").addEventListener("click", () => {
						infoDiv.remove();
						infoDiv = null;
					});
				} else {
					console.log("No se encontró información para este cuerpo celeste.");
				}
			}

			console.log("Interactable Objects:", interactableObjects);
			
///////////////////////////////////////////////////////////////////////////////////////////////////////////		
			
			// Variables para el movimiento y rotación
			let velocity = new THREE.Vector3(); // Velocidad actual de la nave
			let acceleration = 0; // Aceleración controlada por los botones "+" y "-"
			const maxSpeed = 1000; // Velocidad máxima
			const minSpeed = -500; // Velocidad mínima
			const damping = 0.98; // Factor de amortiguación para la inercia
			const angularDamping = 0.95; // Amortiguación para rotaciones angulares

			// Variables para suavizar la rotación
			let pitchVelocity = 0; // Velocidad de rotación en el eje X (pitch)
			let rollVelocity = 0; // Velocidad de rotación en el eje Z (roll)
			let yawVelocity = 0; // Velocidad de rotación en el eje Y (yaw)
			const rotationAcceleration = Math.PI / 4; // Incremento de rotación por segundo^2
			const rotationDamping = 0.9; // Factor de amortiguación para las rotaciones

			// Sensibilidad del giroscopio
			const gyroSensitivity = 0.5; // Factor para reducir la sensibilidad del giroscopio

			// Escala gradual del giroscopio (lineal)
			const gyroScaleFactor = 2; // Factor para amplificar movimientos según el ángulo

			// Estado para controlar si el giroscopio está habilitado o deshabilitado
			let isGyroscopeEnabled = true;

			// HUD para información de la nave
			const hud = document.createElement("div");
			hud.id = "navigationPanel";
			hud.className = "controlPanel";
			hud.style.position = "fixed";
			hud.style.bottom = "10px";
			hud.style.left = "10px";

			hud.innerHTML = `
				<div>
					<!-- Velocidad -->
					<div style="display: flex; justify-content: space-between; margin: 5px 0;">
						<p style="margin: 0;"><strong>Velocidad:</strong></p>
						<p style="margin: 0; text-align: right; letter-spacing: 2px; width: 5ch; margin-right: -5px;">
							<span id="velocityHUD">0</span>
						</p>
						<p style="margin: 0;"><strong>Km/s</strong></p>
					</div>
					
					<!-- Panel de navegación -->
					<div style="margin: 5px 0;">
						<div style="display: flex; justify-content: center; align-items: center; gap: 10px;">
							<div style="width: 30px; text-align: left;">
								<strong>PDF:</strong>
							</div>
							<div style="width: 40px; text-align: center;">
								<span id="pitchHUD">0.00</span>
							</div>
							<div style="width: 40px; text-align: center;">
								<span id="rollHUD">0.00</span>
							</div>
							<div style="width: 40px; text-align: center;">
								<span id="yawHUD">0.00</span>
							</div>
						</div>
					</div>

					<!-- Coordenadas -->
					<p style="margin: 5px 0;"><strong>Coordenadas (Galácticas):</strong></p>
					<div style="margin-left: 5px;">
						<p style="margin: 2px 0;">X: <span id="coordX">0</span></p>
						<p style="margin: 2px 0;">Y: <span id="coordY">0</span></p>
						<p style="margin: 2px 0;">Z: <span id="coordZ">0</span></p>
					</div>
				</div>
			`;


			document.body.appendChild(hud);

			// Manejo de las teclas
			const keyState = {};

			// Detección de dispositivos móviles o tabletas
			const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

			// Detectar orientación del dispositivo (vertical u horizontal)
			let deviceOrientation = window.orientation || 0;

			window.addEventListener("orientationchange", () => {
				deviceOrientation = window.orientation || 0;
				console.log(`Nueva orientación del dispositivo: ${deviceOrientation}°`);
			});

			// Crear botones "+" y "-" solo si el dispositivo es móvil
			if (isMobile) {
				const controlsContainer = document.createElement("div");
				controlsContainer.style.position = "absolute";
				controlsContainer.style.bottom = "10px";
				controlsContainer.style.right = "10px";
				controlsContainer.style.display = "flex";
				controlsContainer.style.gap = "10px";

				const buttonPlus = document.createElement("button");
				buttonPlus.innerText = "+";
				buttonPlus.style.padding = "10px";
				buttonPlus.onclick = () => {
					acceleration += 5;
					acceleration = Math.min(acceleration, maxSpeed);

					if (acceleration > 25) {
						acceleration += 15;
					} else if (acceleration > 100) {
						acceleration += 25;
					}
					

					console.log(`Aceleración aumentada: ${acceleration}`);
				};

				const buttonMinus = document.createElement("button");
				buttonMinus.innerText = "-";
				buttonMinus.style.padding = "10px";
				buttonPlus.onclick = () => {
					acceleration -= 5;
					acceleration = Math.max(acceleration, minSpeed);
		if (acceleration > 25) {
						acceleration -= 15;
					} else if (acceleration > 100) {
						acceleration -= 25;
					}
					console.log(`Aceleración aumentada: ${acceleration}`);
				};
				
				const buttonResetGyro = document.createElement("button");
				buttonResetGyro.innerText = "R";
				buttonResetGyro.style.padding = "10px";
				buttonResetGyro.onclick = () => {
					resetGyroscope();
				};

				const buttonToggleGyro = document.createElement("button");
				buttonToggleGyro.innerText = "Gyro: ON";
				buttonToggleGyro.style.padding = "10px";
				buttonToggleGyro.onclick = () => {
					isGyroscopeEnabled = !isGyroscopeEnabled;
					buttonToggleGyro.innerText = isGyroscopeEnabled ? "Gyro: ON" : "Gyro: OFF";
					console.log(`Control del giroscopio: ${isGyroscopeEnabled ? "Habilitado" : "Deshabilitado"}`);
				};

				controlsContainer.appendChild(buttonMinus);
				controlsContainer.appendChild(buttonPlus);
				controlsContainer.appendChild(buttonResetGyro);
				controlsContainer.appendChild(buttonToggleGyro);
				document.body.appendChild(controlsContainer);
			}

			// Variables para el giroscopio
			let baseAlpha = 0; // Rotación inicial en yaw
			let baseBeta = 0; // Rotación inicial en pitch
			let baseGamma = 0; // Rotación inicial en roll
			let gyroInitialized = false;
			// Ajustar la sensibilidad del pitch y el roll
			const gyroPitchLimit = Math.PI / 3; // Límite de inclinación en radianes (60 grados)
			const gyroRollLimit = Math.PI / 2; // Límite del roll en radianes (90 grados)

			// Evento de orientación del dispositivo
			window.addEventListener("deviceorientation", (event) => {
				if (!gyroInitialized) {
					baseAlpha = event.alpha || 0;
					baseBeta = event.beta || 0;
					baseGamma = event.gamma || 0;
					gyroInitialized = true;
				}

				if (!isGyroscopeEnabled) return; // Si el giroscopio está deshabilitado, no aplicar cambios

				// Calcular las diferencias respecto a la base
				const deltaAlpha = ((event.alpha || 0) - baseAlpha) * (Math.PI / 180); // Yaw
				let deltaBeta = ((event.beta || 0) - baseBeta) * (Math.PI / 180); // Pitch
				let deltaGamma = ((event.gamma || 0) - baseGamma) * (Math.PI / 180); // Roll

				// Ajustar según la orientación del dispositivo
				if (deviceOrientation === 90) {
					[deltaBeta, deltaGamma] = [-deltaGamma, deltaBeta];
				} else if (deviceOrientation === -90) {
					[deltaBeta, deltaGamma] = [deltaGamma, -deltaBeta];
				} else if (deviceOrientation === 180) {
					deltaBeta = -deltaBeta;
					deltaGamma = -deltaGamma;
				}

				// Limitar el pitch y roll
				deltaBeta = Math.max(-gyroPitchLimit, Math.min(gyroPitchLimit, deltaBeta));
				deltaGamma = Math.max(-gyroRollLimit, Math.min(gyroRollLimit, deltaGamma));

				// Aplicar el escalado gradual para el pitch, roll y yaw
				pitchVelocity = deltaBeta * gyroScaleFactor * (1 - Math.abs(deltaBeta) / gyroPitchLimit);
				rollVelocity = deltaGamma * gyroScaleFactor * (1 - Math.abs(deltaGamma) / gyroRollLimit);
				yawVelocity = deltaAlpha * gyroScaleFactor;

				// Aplicar amortiguación adicional al pitch
				pitchVelocity *= rotationDamping;
				rollVelocity *= rotationDamping;
				yawVelocity *= rotationDamping;
			});

			// Función para resetear el giroscopio
			function resetGyroscope() {
				gyroInitialized = false;
				console.log("Giroscopio reiniciado");
			}

			// Evento para detectar cuándo se presiona una tecla
			window.addEventListener("keydown", (event) => {
				keyState[event.code] = true;
				if (event.key === "+" || (event.key === "=" && event.shiftKey)) {
					acceleration += 5;
					acceleration = Math.min(acceleration, maxSpeed);

					if (acceleration > 25) {
						acceleration += 15;
					} else if (acceleration > 100) {
						acceleration += 25;
					}

					console.log(`Aceleración aumentada: ${acceleration}`);
				} else if (event.key === "-") {
					acceleration -= 5;
					acceleration = Math.max(acceleration, minSpeed);
					
					if (acceleration > 25) {
						acceleration -= 15;
					} else if (acceleration > 100) {
						acceleration -= 25;
					}
					
					console.log(`Aceleración reducida: ${acceleration}`);
				} else if (event.key === "O" || event.key === "o") {
					toggleOrbitsVisibility();
					console.log(`Órbitas ${showOrbits ? "visibles" : "ocultas"}`);
				} 
				else if (event.key === "P" || event.key === "p") {
					toggleFullscreen();
					console.log("Modo de pantalla completa alternado.");
				}
			});

			// Evento para detectar cuándo se suelta una tecla
			window.addEventListener("keyup", (event) => {
				keyState[event.code] = false;
			});

			// Función para actualizar los controles de la cámara
			function updateCameraControls(deltaTime) {
				const stabilizationDamping = 0.9999; // Amortiguación ligera para estabilizar cuando no hay contrafuerza
				const rotationalInertia = 1.000001; // Factor para mantener inercia en rotaciones
				const stabilizationThreshold = 0.5; // Umbral por debajo del cual se estabiliza

				// Pitch (rotación sobre el eje X) - Controlado por ArrowUp, W y ArrowDown, S
				if (keyState["ArrowUp"] || keyState["KeyW"]) {
					pitchVelocity -= rotationAcceleration * deltaTime; // Incrementa la velocidad en dirección negativa
				} else if (keyState["ArrowDown"] || keyState["KeyS"]) {
					pitchVelocity += rotationAcceleration * deltaTime; // Incrementa la velocidad en dirección positiva
				} else {
					// Mantener la inercia del pitch
					if (Math.abs(pitchVelocity / deltaTime) < stabilizationThreshold) {
						pitchVelocity *= stabilizationDamping; // Amortiguación ligera cerca de la estabilización
						if (Math.abs(pitchVelocity) < 0.001) pitchVelocity = 0; // Estabilización total si es lo suficientemente pequeña
					} else {
						pitchVelocity *= rotationalInertia; // Reducir gradualmente la velocidad por inercia
					}
				}

				// Roll (rotación sobre el eje Z) - Controlado por ArrowLeft, A y ArrowRight, D
				if (keyState["ArrowLeft"] || keyState["KeyA"]) {
					rollVelocity += rotationAcceleration * deltaTime; // Incrementa la velocidad en dirección positiva
				} else if (keyState["ArrowRight"] || keyState["KeyD"]) {
					rollVelocity -= rotationAcceleration * deltaTime; // Incrementa la velocidad en dirección negativa
				} else {
					// Mantener la inercia del roll
					if (Math.abs(rollVelocity / deltaTime) < stabilizationThreshold) {
						rollVelocity *= stabilizationDamping; // Amortiguación ligera cerca de la estabilización
						if (Math.abs(rollVelocity) < 0.001) rollVelocity = 0; // Estabilización total si es lo suficientemente pequeña
					} else {
						rollVelocity *= rotationalInertia; // Reducir gradualmente la velocidad por inercia
					}
				}

				// Yaw (rotación sobre el eje Y) - Controlado por Q y E
				if (keyState["KeyQ"]) {
					yawVelocity += rotationAcceleration * deltaTime; // Incrementa la velocidad en dirección positiva
				} else if (keyState["KeyE"]) {
					yawVelocity -= rotationAcceleration * deltaTime; // Incrementa la velocidad en dirección negativa
				} else {
					// Mantener la inercia del yaw
					if (Math.abs(yawVelocity / deltaTime) < stabilizationThreshold) {
						yawVelocity *= stabilizationDamping; // Amortiguación ligera cerca de la estabilización
						if (Math.abs(yawVelocity) < 0.001) yawVelocity = 0; // Estabilización total si es lo suficientemente pequeña
					} else {
						yawVelocity *= rotationalInertia; // Reducir gradualmente la velocidad por inercia
					}
				}

				// Aplicar las rotaciones a la cámara
				camera.rotateX(pitchVelocity * deltaTime); // Pitch
				camera.rotateZ(rollVelocity * deltaTime); // Roll
				camera.rotateY(yawVelocity * deltaTime); // Yaw

				// Calcular la dirección hacia adelante de la cámara
				const direction = new THREE.Vector3();
				camera.getWorldDirection(direction);

				// Actualizar la velocidad basada en la aceleración y la dirección
				velocity.addScaledVector(direction, acceleration * deltaTime * (SCALE_DISTANCE * 100) / 2);

				// Aplicar amortiguación para simular inercia en el movimiento traslacional
				velocity.multiplyScalar(damping);

				// Actualizar la posición de la cámara en función de la velocidad
				camera.position.addScaledVector(velocity, deltaTime);

				// Actualizar el HUD
				updateHUD();
			}

			// Función para actualizar el HUD
			function updateHUD() {
				const velocityHUD = document.getElementById("velocityHUD");
				const coordX = document.getElementById("coordX");
				const coordY = document.getElementById("coordY");
				const coordZ = document.getElementById("coordZ");
				const pitchHUD = document.getElementById("pitchHUD");
				const rollHUD = document.getElementById("rollHUD");
				const yawHUD = document.getElementById("yawHUD");

				// Convertir la velocidad a km/s
				const velocityInKmPerSec = velocity.length()* (SCALE_DISTANCE  * 1000000); // Escalamos a kilómetros por segundo
				velocityHUD.textContent = velocityInKmPerSec.toFixed(0); // Mostrar velocidad en km/s

				// Convertir las coordenadas a escala galáctica
				const galacticCoords = getGalacticCoordinates(camera.position);
				coordX.textContent = galacticCoords.x;
				coordY.textContent = galacticCoords.y;
				coordZ.textContent = galacticCoords.z;

				// Convertir las rotaciones a grados
				pitchHUD.textContent = (pitchVelocity * 180 / Math.PI).toFixed(2);
				rollHUD.textContent = (rollVelocity * 180 / Math.PI).toFixed(2);
				yawHUD.textContent = (yawVelocity * 180 / Math.PI).toFixed(2);
			}

			// Obtener coordenadas galácticas
			function getGalacticCoordinates(position) {
				return {
					x: formatAsDegrees(position.x / SCALE_DISTANCE),
					y: formatAsDegrees(position.y / SCALE_DISTANCE),
					z: formatAsDegrees(position.z / SCALE_DISTANCE),
				};
			}

			// Formatear coordenadas en grados, minutos y segundos
			function formatAsDegrees(value) {
				const degrees = Math.floor(value);
				const minutes = Math.floor((value - degrees) * 60);
				const seconds = (((value - degrees) * 60) - minutes) * 60;
				return `${degrees}° ${minutes}' ${seconds.toFixed(2)}"`;
			}

			// Función para inicializar el giroscopio al estado predeterminado
			function initializeGyroscope() {
				gyroInitialized = false;
				pitchVelocity = 0;
				rollVelocity = 0;
				yawVelocity = 0;
				console.log("Giroscopio inicializado a los valores predeterminados.");
			}

/////////////////////////////////////////////////////////////////////////////////////////////////////

			let showOrbits = true; // Bandera para rastrear si las órbitas están visibles

			// Función para alternar la visibilidad de las órbitas
			function toggleOrbitsVisibility() {
				showOrbits = !showOrbits; // Alternar el estado

				// Recorrer los objetos celestes y actualizar la visibilidad de las órbitas
				Object.keys(celestialObjects).forEach((key) => {
					if (celestialObjects[key].orbit) {
						celestialObjects[key].orbit.visible = showOrbits;
					}
				});
			}
			
			// Función para activar la pantalla completa
			function toggleFullscreen() {
				if (!document.fullscreenElement) {
					document.documentElement.requestFullscreen().catch((err) => {
						alert(`Error al intentar activar pantalla completa: ${err.message}`);
					});
				} else {
					document.exitFullscreen();
				}
			}

			// Añadir funcionalidad a los botones
			document.getElementById("fullscreenBtn").addEventListener("click", toggleFullscreen);
			document.getElementById("toggleOrbits").addEventListener("click", toggleOrbitsVisibility);


 ////////////////////////////////////////////////////////////////////////////////////     

			// Actualizar la visualización del marcador de velocidad/tiempo
			function updateSpeedDisplay() {
				const speedIndex = speedRanges.indexOf(speedFactor);
				const displayText = speedDescriptions[speedIndex];
				document.getElementById("timeSpeedDisplay").innerText = `Tiempo: ${displayText}`;
				console.log(`Velocidad actual: ${displayText}`);
			}

			// Función para ajustar la velocidad
			function updateSpeed(newSpeedIndex) {
				if (newSpeedIndex >= 0 && newSpeedIndex < speedRanges.length) {
					speedFactor = speedRanges[newSpeedIndex];
					isPaused = speedFactor === 0; // Si la velocidad es 0, se considera pausa
					updateSpeedDisplay();
				}
			}

			// Botón para disminuir la velocidad (retroceder el tiempo o pausar)
			document.getElementById("decreaseSpeedBtn").addEventListener("click", () => {
				const currentIndex = speedRanges.indexOf(speedFactor);
				if (currentIndex > 0) {
					updateSpeed(currentIndex - 1); // Cambiar a la velocidad anterior
				}
			});

			// Botón para aumentar la velocidad (avanzar el tiempo)
			document.getElementById("increaseSpeedBtn").addEventListener("click", () => {
				const currentIndex = speedRanges.indexOf(speedFactor);
				if (currentIndex < speedRanges.length - 1) {
					updateSpeed(currentIndex + 1); // Cambiar a la velocidad siguiente
				}
			});

			// Botón de pausa
			document.getElementById("pauseBtn").addEventListener("click", () => {
				isPaused = !isPaused; // Alternar estado de pausa
				document.getElementById("timeSpeedDisplay").innerText = isPaused
					? "Tiempo: en Pausa"
					: `Tiempo: ${speedDescriptions[speedRanges.indexOf(speedFactor)]}`;
				console.log(isPaused ? "Simulación pausada" : "Simulación reanudada");
			});
			
			// Función para ajustar la simulación a la velocidad real y tiempo actual
			document.getElementById("realTimeSpeedBtn").addEventListener("click", () => {
				// Configurar la velocidad a tiempo real
				speedFactor = speedRanges[speedRanges.indexOf(0.000011574074074074073)]; // 1 seg = 1 seg

				// Actualizar el marcador de velocidad
				document.getElementById("timeSpeedDisplay").innerText = `Tiempo: +1 seg = T. Real`;

				// Sincronizar el tiempo simulado con el tiempo real
				const now = new Date();
				simulatedDate = now;

				// Ajustar las posiciones de los cuerpos celestes
				Object.keys(CELESTIAL_BODIES).forEach((category) => {
					Object.keys(CELESTIAL_BODIES[category]).forEach((name) => {
						const body = CELESTIAL_BODIES[category][name];
						if (body.orbitalPeriod !== Infinity) {
							const perihelionDate = new Date(body.lastPerihelion);
							const daysSincePerihelion = (now - perihelionDate) / (1000 * 60 * 60 * 24); // Días desde el perihelio
							const fractionOfOrbit = (daysSincePerihelion % body.orbitalPeriod) / body.orbitalPeriod;
							angles[name] = 2 * Math.PI * fractionOfOrbit; // Ángulo inicial en radianes, ajustado a [0, 2π]

							// Calcular la posición actual
							let position = calculateRelativePosition(
								angles[name],
								body.periapsis,
								body.apoapsis,
								body.longitudeOfAscendingNode,
								body.inclination,
								body.argumentOfPeriapsis
							);

							if (body.orbits && celestialObjects[body.orbits]) {
								const centralPosition = celestialObjects[body.orbits].position;
								position.add(centralPosition); // Añadir la posición del cuerpo central
							}

							// Actualizar la posición en la simulación
							celestialObjects[name].position.set(position.x, position.y, position.z);
						}
						
						// Actualizar la rotación para sincronizar con el tiempo real
						const textures = celestialBodiesTextures[name] || {};
						if (body.rotationPeriod && textures.textureMeridianOffset !== undefined) {
							const initialRotation = calculateInitialRotation(
								textures.textureMeridianOffset,
								body.rotationPeriod,
								now
							);
							celestialObjects[name].rotation.y = initialRotation;
						}
					});
				});

				console.log("Simulación ajustada a tiempo real.");
			});

///////////////////////////////////////////////////////////////////////////////

			// Configurar la posición inicial de la cámara detrás de la Tierra mirando al Sol, ajustada 15 grados a la derecha
			function adjustCameraToEarthSunView() {
				const earth = celestialObjects.earth; // Suponiendo que "earth" está en celestialObjects
				const sun = celestialObjects.sun; // Suponiendo que "sun" está en celestialObjects

				if (earth && sun) {
					const earthPosition = new THREE.Vector3();
					const sunPosition = new THREE.Vector3();

					// Obtener las posiciones actuales de la Tierra y el Sol
					earth.getWorldPosition(earthPosition);
					sun.getWorldPosition(sunPosition);

					// Calcular la dirección desde la Tierra hacia el Sol
					const directionToSun = new THREE.Vector3()
						.subVectors(sunPosition, earthPosition)
						.normalize();

					// Establecer la distancia detrás de la Tierra
					const distanceBehindEarth = 70; // Ajusta esta distancia según lo necesites

					// Calcular la posición detrás de la Tierra
					const cameraPosition = new THREE.Vector3()
						.copy(earthPosition)
						.sub(directionToSun.multiplyScalar(distanceBehindEarth));

					// Rotar la cámara 15 grados hacia la derecha alrededor de la Tierra
					const angleInRadians = THREE.MathUtils.degToRad(15);
					const axis = new THREE.Vector3(0, 1, 0); // Eje Y para rotación
					cameraPosition.sub(earthPosition).applyAxisAngle(axis, angleInRadians).add(earthPosition);

					// Establecer la posición y dirección de la cámara
					camera.position.copy(cameraPosition);
					camera.lookAt(sunPosition);

					console.log("Camera adjusted to view from Earth towards Sun with 20° right rotation.");
				} else {
					console.warn("Earth or Sun object not found in celestialObjects.");
				}
			}

			// Llama a la función para ajustar la cámara
			adjustCameraToEarthSunView();

			// Escuchar cambios de tamaño de ventana
			window.addEventListener("resize", () => {
				renderer.setSize(window.innerWidth, window.innerHeight);
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});

			interactableObjects.forEach((obj) => {
				console.log(obj.userData);
			});

			// Inicialización al cargar
			updateSpeedDisplay();
			// Iniciar la animación
			animate();
		</script>
	</body>
</html>
