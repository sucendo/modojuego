<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<!-- Favicon (sat1) -->
		<link rel="icon" type="image/png" sizes="32x32" href="img/satellite-rasteator/icons/32/sat1.png">
		<link rel="icon" type="image/png" sizes="64x64" href="img/satellite-rasteator/icons/64/sat1.png">
		<link rel="apple-touch-icon" sizes="180x180" href="img/satellite-rasteator/icons/64/sat1.png">
		<!-- Color de la barra del navegador (se sincroniza por JS con el header) -->
		<meta name="theme-color" content="#0e1540">
		<!-- PWA en Android/Chrome -->
		<meta name="mobile-web-app-capable" content="yes">
		<!-- Solo añadimos el meta de Apple en iOS para evitar el warning en Chrome -->
		<script>
		(function(){
			const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);
			if (isiOS){
			var m = document.querySelector('meta[name="apple-mobile-web-app-capable"]');
			if(!m){ m = document.createElement('meta'); m.setAttribute('name','apple-mobile-web-app-capable'); document.head.appendChild(m); }
			m.setAttribute('content','yes');
			} else {
			const m = document.querySelector('meta[name="apple-mobile-web-app-capable"]');
			if (m) m.remove();
			}
		})();
		</script>
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Satellite Rasteator</title>
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
		<style>
			/* ===== Variables de tema y responsivas ===== */
			:root{
				--bg:#0b1020; --panel:#121832; --text:#e6eef8;

				/* Scroll */
				--scroll-track:#0e1540;
				--scroll-thumb:#2a3a6b;
				--scroll-thumb-hover:#4a68c9;
				--scroll-corner:#0b1020;

				/* UI */
				--ui-gap:.6rem;
				--btn-size:36px;                    /* base de botones/iconos */
				--font-base:clamp(13px,1.2vw,15px); /* tipografía responsiva */
				--safe-bottom:env(safe-area-inset-bottom,0px);
			}
			@media (max-width:900px){ :root{ --btn-size:34px } }
			@media (max-width:700px){ :root{ --btn-size:30px } }
			@media (orientation:landscape) and (max-height:520px){ :root{ --btn-size:30px } }

			/* ===== Base ===== */
			html,body{height:100%; margin:0; background:var(--bg); color:var(--text); overflow-x:hidden}
			body{
				font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
				font-size:var(--font-base);
			}
			#app{display:grid; grid-template-rows:auto 1fr; height:100%; min-height:100vh; position:relative}
			#map{height:100%}

			/* ===== Header ===== */
			header{
				display:flex; align-items:center; gap:var(--ui-gap); flex-wrap:wrap;
				padding:.6rem .9rem; background:#0b1020; border-bottom:1px solid #1f284a;
			}
			#brandIcon{ width:32px; height:32px; image-rendering:auto; display:inline-block; flex:0 0 auto }
			header h1{
				font-size:clamp(.95rem,2.2vw,1.05rem); margin:0;
				max-width:40vw; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
			}
			header .actions{ margin-left:auto; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap }
			header button, header select{ background:#11173a; color:var(--text); border:1px solid #26315c; padding:.45rem .7rem; border-radius:.5rem; cursor:pointer }

			/* ===== Botones de icono y color ===== */
			.btn-icon{
				display:inline-flex; align-items:center; justify-content:center;
				width:var(--btn-size); height:var(--btn-size);
				border-radius:.4rem; border:1px solid #2a3a6b; background:#0e1540; color:var(--text);
				cursor:pointer; padding:0;
			}
			.btn-icon svg{ width:clamp(16px,2.3vw,18px); height:clamp(16px,2.3vw,18px); pointer-events:none }
			.btn-icon.active{ box-shadow: inset 0 0 0 2px #6aa8ff }
			.btn-color{ width:var(--btn-size); height:var(--btn-size) }

			/* Ubicarme punto azul */
			#locateMe.icon-only{ display:inline-flex; align-items:center; justify-content:center; width:var(--btn-size); height:var(--btn-size); padding:0 }
			.me-dot{ width:14px; height:14px; border-radius:50%; background:#2a7bff; border:2px solid #fff; box-shadow:0 0 0 4px rgba(42,123,255,.25) }

			/* Fullscreen (móvil, junto al ☰) */
			#fullScreenBtn{ display:none; align-items:center; justify-content:center; padding:.45rem .6rem }

			/* ===== Panel lateral / bottom sheet ===== */
			.panel{
				position:absolute; top:60px; right:8px; bottom:calc(24px + var(--safe-bottom));
				width:clamp(260px,28vw,360px); box-sizing:border-box;
				display:flex; flex-direction:column; gap:.6rem;
				padding:.75rem; border-radius:.6rem; background:var(--panel); border:1px solid #26315c;
				box-shadow:0 10px 30px rgba(0,0,0,.35); z-index:1000;
				transition:transform .25s ease, opacity .2s ease; will-change:transform,opacity;
				overflow:hidden; /* nada se desborda fuera del panel */
			}
			.panel h2{ margin:.2rem 0 .6rem; font-size:1rem }
			.panel .min-btn{
				position:absolute; top:8px; right:8px; border:1px solid #26315c; background:#0e1540; color:var(--text);
				border-radius:.5rem; padding:.25rem .5rem; cursor:pointer; font-size:.9rem;
			}
			.panel.collapsed{ transform:translateX(calc(100% + 16px)); opacity:0; pointer-events:none }
			.panel.collapsed-hidden{ display:none }

			.panel-toggle{
				position:absolute; top:60px; right:8px; z-index:1001;
				border:1px solid #26315c; background:#11173a; color:var(--text);
				border-radius:.5rem; padding:.5rem .7rem; cursor:pointer; display:none; align-items:center; gap:.4rem;
				box-shadow:0 8px 24px rgba(0,0,0,.35);
			}
			.panel-toggle .dot{ width:.6rem; height:.6rem; border-radius:999px; background:#5aa9ff; display:inline-block }

			/* ===== Lista de satélites ===== */
			.sat-item{
				display:grid; grid-template-columns:auto 1fr; grid-template-rows:auto auto;
				gap:.5rem; align-items:center; padding:.45rem .5rem; border-radius:.6rem; border:1px solid #223059; margin-bottom:.45rem;
			}
			.sat-item .actions-col{ display:flex; flex-direction:row !important; align-items:center; gap:.4rem; flex-wrap:wrap; width:100%; margin-top:.25rem; grid-column:1 / -1 }
			.sat-item .btn-icon{ width:32px; height:32px; background:#0e1540 }
			.sat-item .btn-icon svg{ width:16px; height:16px }
			.sat-item .btn-danger{ border-color:#5a2a2a; background:#3a0e0e }
			.sat-item .btn-color{
				width:32px; height:32px; border-radius:.4rem; border:1px solid #2a3a6b; cursor:pointer; padding:0;
				background:var(--col,#ff3333); background:conic-gradient(from 0deg, var(--col,#ff3333), var(--col,#ff3333));
			}

			/* Ficha: datos dinámicos */
			.kv{ font-size:.85rem; opacity:.9; white-space:pre-line; line-height:1.25 }
			.okv{ font-size:.82rem; opacity:.9; margin-top:.15rem; display:flex; flex-wrap:wrap; gap:.35rem }
			.okv .chip{ background:#0c1330; border:1px solid #2a3a6b; border-radius:.35rem; padding:.1rem .35rem }
			.sat-item .sat-name{ cursor:text; border-bottom:1px dashed rgba(230,238,248,.25) }
			.sat-item .sat-name:focus{ outline:none; background:#0c1330 }
			.sat-item .btn-icon.active{ box-shadow: inset 0 0 0 2px #6aa8ff }

			/* Scroll interno: lista y “añadir” */
			#satList{ flex:1 1 auto; overflow:auto; overscroll-behavior:contain; margin-top:.4rem; scrollbar-gutter:stable both-edges }
			#addSatPanel{ flex:0 0 auto; margin-top:.5rem; max-height:43vh; overflow:auto; scrollbar-gutter:stable }
			#addSatPanel textarea{ max-height:28vh }

			/* Firefox scroll */
			#satList, #addSatPanel{ scrollbar-width:thin; scrollbar-color:var(--scroll-thumb) transparent }
			/* WebKit scroll */
			#satList::-webkit-scrollbar, #addSatPanel::-webkit-scrollbar{ width:10px; height:10px }
			#satList::-webkit-scrollbar-track, #addSatPanel::-webkit-scrollbar-track{
				background:linear-gradient(180deg,rgba(0,0,0,0) 0%, rgba(0,0,0,.12) 100%), var(--panel);
				border-radius:8px; margin:4px;
			}
			#satList::-webkit-scrollbar-thumb, #addSatPanel::-webkit-scrollbar-thumb{
				background-color:var(--scroll-thumb); border-radius:8px; border:2px solid transparent; background-clip:content-box;
			}
			#satList::-webkit-scrollbar-thumb:hover, #addSatPanel::-webkit-scrollbar-thumb:hover{ background-color:var(--scroll-thumb-hover) }
			#satList::-webkit-scrollbar-corner, #addSatPanel::-webkit-scrollbar-corner{ background:var(--scroll-corner) }

			/* Añadir satélite: botón “primario” */
			#addSatPanel #addSatBtn{
				appearance:none; border:1px solid #2a3a6b; background:linear-gradient(180deg,#1b2a6a,#101a46);
				color:var(--text); border-radius:.6rem; padding:.55rem .9rem .55rem 2.1rem;
				font-weight:600; letter-spacing:.2px; position:relative; cursor:pointer;
				box-shadow:0 6px 18px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.04);
				transition:transform .08s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease, filter .2s ease;
			}
			#addSatPanel #addSatBtn::before{
				content:"+"; position:absolute; left:.65rem; top:50%; transform:translateY(-50%);
				width:1.25rem; height:1.25rem; line-height:1.2rem; border-radius:.4rem; text-align:center; font-weight:700; font-size:1rem; color:#fff;
				background:radial-gradient(100% 100% at 50% 50%, #3d8bfd 0%, #2a5be8 100%);
				box-shadow:0 2px 8px rgba(3,121,255,.45), inset 0 0 0 1px rgba(255,255,255,.15);
			}
			#addSatPanel #addSatBtn:hover{ filter:saturate(1.1) brightness(1.05); box-shadow:0 10px 24px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06) }
			#addSatPanel #addSatBtn:active{ transform:translateY(1px) scale(.985) }
			#addSatPanel #addSatBtn:focus-visible{ outline:2px solid #6aa8ff; outline-offset:2px }
			#addSatPanel #addSatBtn:disabled{ opacity:.6; cursor:not-allowed; filter:grayscale(25%) }

			#addSatPanel #newIconBtn{
				display:inline-flex; align-items:center; justify-content:center;
				width:32px; height:32px; border-radius:.4rem; border:1px solid #2a3a6b; background:#0e1540; color:var(--text); cursor:pointer; padding:0;
			}
			/* Compactar fila de botones/color en “Añadir” */
			#addSatPanel > div[style*="display:flex"]{ flex-wrap:wrap; gap:.5rem .6rem !important }

			/* Campos de texto */
			details{ border:1px dashed #2a3a6b; border-radius:.6rem; padding:.4rem .6rem; margin-top:.5rem }
			textarea{ width:100%; min-height:90px; background:#0c1330; color:var(--text); border:1px solid #2a3a6b; border-radius:.5rem; padding:.5rem; font-family:ui-monospace,Menlo,Consolas,monospace }
			.hint{ font-size:.8rem; opacity:.7 }

			/* Cloud-only WMTS */
			.clouds-only img{ mix-blend-mode:lighten; image-rendering:auto }

			/* Color input => igual aspecto que .btn-color */
			#addSatPanel #defaultOrbitColor{
				appearance:none; -webkit-appearance:none; width:32px; height:32px; border-radius:.4rem;
				border:1px solid #2a3a6b; background:#0e1540; padding:0; cursor:pointer;
			}
			#addSatPanel #defaultOrbitColor::-webkit-color-swatch-wrapper{ padding:0; border-radius:.35rem }
			#addSatPanel #defaultOrbitColor::-webkit-color-swatch{ border:none; border-radius:.35rem }
			#addSatPanel #defaultOrbitColor::-moz-color-swatch{ border:none; border-radius:.35rem }
			#addSatPanel #defaultOrbitColor:hover{ filter:saturate(1.05) brightness(1.05) }
			#addSatPanel #defaultOrbitColor:focus-visible{ outline:2px solid #6aa8ff; outline-offset:2px }
			@media (max-width:900px){ #addSatPanel #defaultOrbitColor{ width:32px; height:32px } }
			@media (max-width:700px){ #addSatPanel #defaultOrbitColor{ width:36px; height:36px } }

			/* Toggle (botón que abre/cierra la tira de acciones en móvil/tablet) */
			.actions-toggle{
				display:none; margin-left:auto; background:#11173a; color:var(--text);
				border:1px solid #26315c; border-radius:.5rem; padding:.45rem .6rem; cursor:pointer; line-height:1;
			}

			/* ===== Icon picker / TLE picker ===== */
			.icon-picker{
				position:fixed; z-index:2000; background:#0e1540; color:var(--text);
				border:1px solid #2a3a6b; border-radius:.6rem; box-shadow:0 12px 30px rgba(0,0,0,.45);
				padding:.5rem; width:220px; max-height:260px; overflow:auto;
			}
			.icon-picker h4{ margin:.1rem .1rem .4rem; font-size:.9rem; opacity:.85 }
			.icon-grid{ display:grid; grid-template-columns:repeat(5,1fr); gap:.35rem }
			.icon-item{
				background:#0c1330; border:1px solid #2a3a6b; border-radius:.45rem; width:36px; height:36px;
				display:flex; align-items:center; justify-content:center; cursor:pointer;
			}
			.icon-item img{ width:24px; height:24px; image-rendering:auto }
			.icon-item[aria-selected="true"]{ outline:2px solid #6aa8ff; outline-offset:1px; border-color:#6aa8ff }
			.icon-picker .close-row{ display:flex; justify-content:flex-end; margin-top:.4rem }
			.icon-picker .close-btn{ background:#11173a; border:1px solid #2a3a6b; color:var(--text); border-radius:.4rem; padding:.25rem .5rem; cursor:pointer }

			.tle-picker{
				position:fixed; z-index:2000; background:#0e1540; color:var(--text);
				border:1px solid #2a3a6b; border-radius:.6rem; box-shadow:0 12px 30px rgba(0,0,0,.45);
				padding:.6rem; width:460px; max-width:calc(100vw - 16px);
			}
			.tle-picker h4{ margin:.1rem .1rem .4rem; font-size:.95rem; opacity:.9 }
			.tle-picker .tle-area{
				width:96%; min-height:96px; resize:vertical; background:#0c1330; color:var(--text);
				border:1px solid #2a3a6b; border-radius:.45rem; padding:.5rem;
				font:13px/1.35 ui-monospace,SFMono-Regular,Menlo,Consolas,"Liberation Mono",monospace;
			}
			.tle-picker .meta{ display:flex; gap:.5rem; align-items:center; margin-top:.35rem; font-size:.85rem; opacity:.85 }
			.tle-picker .meta .pill{ border:1px solid #2a3a6b; border-radius:.45rem; padding:.15rem .4rem; background:#0c1330 }
			.tle-picker .meta .ok{ color:#9fe29f; border-color:#2f5a2f }
			.tle-picker .meta .bad{ color:#ffb0b0; border-color:#5a2f2f }
			.tle-picker .actions{ display:flex; gap:.5rem; justify-content:flex-end; margin-top:.5rem }
			.tle-picker .btn{ background:#11173a; border:1px solid #2a3a6b; color:var(--text); border-radius:.4rem; padding:.35rem .7rem; cursor:pointer }
			.tle-picker .btn[disabled]{ opacity:.5; cursor:not-allowed }

			/* ======= Time Controls (layout centrado con slider abajo, look tipo “chip”) ======= */
			.time-controls{
				position:absolute; left:50%; right:auto; transform:translateX(-50%);
				bottom:calc(25px + var(--safe-bottom)); z-index:1100; display:none;
				/* top row: [Ahora] [Rate] [Play centrado] [Fecha]  | bottom row: slider centrado */
				grid-template-columns:auto auto 1fr auto;
				grid-template-rows:auto auto;
				gap:.35rem .5rem; align-items:center; justify-items:start;
				background:rgba(14,21,64,.92); border:1px solid #26315c; border-radius:.6rem; padding:.4rem .55rem;
				backdrop-filter:saturate(120%) blur(2px); box-shadow:0 10px 20px rgba(0,0,0,.34);
				max-width:min(96vw, 500px);
			}
			.time-controls.active{ display:grid }
			.time-controls .btn{
				display:inline-flex; align-items:center; justify-content:center;
				width:var(--btn-size); height:var(--btn-size);
				border:1px solid #2a3a6b; border-radius:.45rem; background:#11173a; color:var(--text); cursor:pointer; padding:0;
			}
			.time-controls .rate-indicator{ font-size:.85rem; opacity:.9; min-width:8ch; text-align:right; font-variant-numeric:tabular-nums }
            /* Colocación base */
            #useNow{   grid-column:1; grid-row:1; white-space:nowrap }

            /* El contenedor de controles sirve como referencia para posicionar #scrubRate */
            .time-controls{ position:relative }

            /* Gap configurable entre el rate y el botón (desktop/móvil abajo) */
            :root{ --rate-gap: .35rem }

            /* #scrubRate: pegado a la izquierda del Play/Pause, alineado verticalmente */
            #scrubRate{
                position:absolute;
                top:50%;                                 /* centra verticalmente */
                left:calc(50% - 0.5 * var(--btn-size) - var(--rate-gap));
                transform:translate(-100%, -100%);       /* alinea el borde derecho del texto */
                padding:0; background:none; border:none; box-shadow:none;
                color:var(--text);
            }
            #scrubRate.is-now{ color:#aef3c0 }          /* verde en “Ahora” */
			
			
			/* ===== Estados visuales: "Ahora" (verde) vs Manual (blanco) ===== */
            /* Base (NO es ahora) → blanco */
            #useNow{ border-color:rgba(255,255,255,.85); color:var(--text); width: auto; }
            #scrubRate{ color:var(--text); }
            #useNow::before{ background:#8aa2c6 } /* puntito neutral */
            /* Es ahora → verde */
            #useNow.is-now, #scrubRate.is-now{ color:#aef3c0; }
            #useNow.is-now{ box-shadow:0 0 0 2px rgba(46,204,113,.25) inset }
            #useNow.is-now::before{ background:#26d07c }		

            @media (max-width:700px){
              :root{ --rate-gap:.2rem }
            }
			@media (max-width:700px){
				#scrubRate{ transform:translateX(calc(-.5 * var(--btn-size) - .2rem)); }
			}
			/* Play centrado respecto a TODO el contenedor (encima de la marca central) */
			#scrubPlay{ grid-column:1 / -1; grid-row:1; justify-self:center; z-index:1 }
			#refTime{  grid-column:4; grid-row:1; justify-self:end; min-width:0; max-width:min(52vw, 260px) }
			.slider-container{
				grid-column:1 / -1; grid-row:2; justify-self:center;
				width:100%; min-width:300px; /* ocupa todo el ancho disponible con mínimo 300px */
				position:relative; display:flex; align-items:center; gap:.5rem; margin-top: 15px;
			}

			/* Slider curvo + marca central */
			/* Slider curvo + marca central + “well” decorativo */
			.slider-container .slider-input{ width:100% }
			.slider-container .svg-parent{ position:absolute; pointer-events:none; left:0; right:0; margin:auto; width:100% }
 			.slider-container .center-mark{
				/* La posición exacta la fija JS según el ancho real del <input> */
				position:absolute; left:0; top:50%; transform:translate(-1px,-50%);
				/* la X exacta se fija desde JS con positionCenterMark() */
				position:absolute; left:0; top:50%; transform:translate(-1px,-50%);
				width:2px; height:18px; background:rgba(230,238,248,.35); border-radius:1px; pointer-events:none;
			}
			/* Range: pista + “pulgar” grande y arrastrable */
			.slider-input{
				appearance:none; height:3px; border-radius:999px;
				background:linear-gradient(90deg, rgba(106,168,255,.28), rgba(230,238,248,.28));
				outline:none;
			}
			.slider-input::-webkit-slider-thumb{
				-webkit-appearance:none; width:24px; height:24px; border-radius:50%;
				background:#e6eef8; border:2px solid #6aa8ff; box-shadow:0 0 12px rgba(106,168,255,.35), 0 0 0 5px rgba(106,168,255,.18); cursor:grab;
			}
			.slider-input::-webkit-slider-thumb:active{ cursor:grabbing }
			.slider-input::-moz-range-thumb{
				width:24px; height:24px; border-radius:50%;
				background:#e6eef8; border:2px solid #6aa8ff; box-shadow:0 0 12px rgba(106,168,255,.35), 0 0 0 5px rgba(106,168,255,.18); cursor:grab;
			}
			.slider-input::-moz-range-track{ height:8px; background:transparent; border:none; border-radius:999px }

			/* Fecha/Hora: apariencia de texto (sin chip) y se "abre" al enfocar */
			.time-controls input[type="datetime-local"]{
				background:transparent; border:none; box-shadow:none; padding:0; margin:0;
				color:var(--text); font-size:clamp(.85rem,1.8vw,.95rem); font-variant-numeric:tabular-nums;
				min-width:0; max-width:min(52vw, 260px);
				transition:background .12s ease, box-shadow .12s ease, padding .12s ease, border-color .12s ease;
				cursor:text; outline:none;
				-webkit-appearance:none;                  /* evita reservas raras en WebKit */
				caret-color: currentColor;                 /* cursor visible */
			}
			/* Al enfocar → mostrar chip editable (abre visualmente el campo) */
			.time-controls input[type="datetime-local"]:focus{
				background:#0f1848; border:1px solid #2a3a6b; border-radius:.6rem; padding:.35rem .55rem;
				box-shadow:inset 0 0 0 1px rgba(255,255,255,.03);
			}
			/* Ocultar iconos nativos y su espacio (el “hueco” de la derecha) */
			.time-controls input[type="datetime-local"]::-webkit-calendar-picker-indicator{ display:none }
			.time-controls input[type="datetime-local"]::-webkit-inner-spin-button{ display:none }
			.time-controls input[type="datetime-local"]::-webkit-clear-button{ display:none }

			/* En la fila de edición: el botón “Ahora” NO debe ser cuadrado */
			.time-controls .datetime-edit .btn{ width:auto; height:var(--btn-size); padding:.3rem .6rem }
			#useNow{ white-space:nowrap }			

			/* Botón del menú que muestra/oculta los controles de tiempo */
			#btnTimeControls.btn-icon.active{ box-shadow: inset 0 0 0 2px #6aa8ff }
			/* Estado “ahora” (tiempo real) → verde */
			#useNow{
				border-radius:.6rem; padding:.35rem .7rem; background:#0f1848; border:1px solid #2a3a6b; color:var(--text);
				box-shadow:inset 0 0 0 1px rgba(255,255,255,.03); display:inline-flex; align-items:center; gap:.45rem;
			}
			#useNow::before{
				content:""; width:.55rem; height:.55rem; border-radius:999px; background:#8aa2c6; box-shadow:0 0 0 2px rgba(255,255,255,.08) inset;
			}
			#useNow.is-now{ border-color:#2e9f5f; color:#aef3c0; box-shadow:0 0 0 2px rgba(46,204,113,.25) inset }
			#useNow.is-now::before{ background:#26d07c }
			/* Indicador de velocidad → solo texto */
			#scrubRate{
				background:none; padding:0; 
				color:var(--text); /* blanco en modo manual */
				font-size: .99rem;
			}
			#scrubRate.is-now{ color:#aef3c0 } /* verde cuando es “Ahora” */
			/* Botón play: cuadrado sutil */
			#scrubPlay{ background:#102058; border-color:#2a3a6b; box-shadow:0 2px 10px rgba(0,0,0,.25), inset 0 0 0 1px rgba(255,255,255,.04) }

			/* ===== Responsivo ===== */
			@media (max-width:1200px){
				header h1{ font-size:1rem }
				header .actions{ gap:.45rem }
				.panel{ width:300px; right:8px; bottom:20px; top:60px }
			}
			@media (max-width:900px){
				header{ padding:.5rem .7rem }
				header h1{ line-height:2rem }
				header button, header select, #refTime, #useNow{ font-size:.9rem; padding:.4rem .55rem }
				.actions-toggle{ display:inline-flex; align-items:center; justify-content:center }
				#fullScreenBtn{ display:inline-flex }
				header .actions{
					order:3; width:100%; display:flex; flex-wrap:wrap; gap:.45rem;
				}
				.panel{ width:300px; right:8px; bottom:18px; top:56px }
				.sat-item .btn-icon, .sat-item .btn-color{ width:32px; height:32px }
			}
			@media (max-width:700px){
				/* Header más compacto en móvil */
				header{ align-items:flex-start; gap:.35rem; position:relative; padding:.35rem .6rem }
				#brandIcon{ width:24px; height:24px }
				header h1{ max-width:55vw; font-size:.92rem }
				/* Tira de acciones como overlay bajo el header */
				header .actions{ display:none }
				header .actions.open{
					display:flex; position:fixed; left:0; right:0; top:var(--actionsTop,56px);
					z-index:1100; background:rgba(11,16,32,.98); border-bottom:1px solid #1f284a;
					padding:.4rem .5rem; gap:.4rem; box-sizing:border-box; max-width:100vw;
					overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch; scrollbar-gutter:stable;
				}
				header .actions.open>*{ flex:0 0 auto }
				header .actions.open::-webkit-scrollbar{ height:6px }

				/* Panel como “bottom sheet” */
				/* Panel ocupa más alto para que se vea mejor la lista */
				.panel{ left:6px; right:6px; top:auto; bottom:calc(64px + var(--safe-bottom)); width:auto; max-height:69vh }
				.panel-toggle{ top:auto; right:6px; bottom:calc(8px + var(--safe-bottom)) }
				.sat-item .btn-icon, .sat-item .btn-color{ width:36px; height:36px }
				.sat-item{ gap:.45rem }
				#addSatPanel{ max-height:38vh }
				#addSatPanel textarea{ max-height:26vh }

				/* Controles de tiempo compactos */
				.time-controls{
					left:50%; right:auto; transform:translateX(-50%); bottom:calc(6px + var(--safe-bottom));
					gap:.3rem .4rem; padding:.35rem .45rem; width:calc(100vw - 12px);
				}
				#scrubPlay{ width:30px; height:30px }
				#useNow{ height:30px; padding:.25rem .55rem }
				.slider-container{ width:100%; min-width:300px }
			}
			@media (max-height:540px){
				/* paisaje móvil */
				.panel{ bottom:calc(8px + var(--safe-bottom)); top:58px; max-height:calc(100vh - 80px) }
				#addSatPanel{ max-height:38vh }
				.time-controls{ grid-template-columns:auto 1fr auto }
			}
			
			/* ======= Móvil vertical muy estrecho (~360px) ======= */
			@media (max-width:380px){
				:root{ --rate-gap:.2rem }
				.time-controls{
					/* 2 columnas, 3 filas: [Ahora | Fecha] / [Play centrado] / [Slider] */
					grid-template-columns: 1fr 1fr;
					grid-template-rows: auto auto auto;
					gap:.25rem .35rem;
					padding:.35rem .45rem;
					max-width: calc(100vw - 8px);
					bottom: calc(8px + var(--safe-bottom));
				}
				#useNow{  grid-column:1; grid-row:1; justify-self:start }
				#refTime{ grid-column:2; grid-row:1; justify-self:end; max-width:62vw; font-size:.85rem }
				#scrubPlay{ grid-column:1 / -1; grid-row:2; justify-self:center }
				.slider-container{ grid-column:1 / -1; grid-row:3; width:100%; min-width:300px }
			}
		</style>

	</head>
	<body>
		<div id="app">
			<header>
				<img id="brandIcon" src="img/satellite-rasteator/icons/32/sat1.png" alt="" aria-hidden="true">
 				<h1>Satellite Rasteator</h1>
				<button id="actionsToggle" class="actions-toggle" aria-label="Mostrar opciones">☰</button>
				<button id="fullScreenBtn" aria-label="Pantalla completa" title="Pantalla completa">
					<svg viewBox="0 0 24 24" width="15" height="15" aria-hidden="true">
						<path fill="currentColor" d="M 4 9 L 4 4 L 9 4 L 9 2 L 2 2 L 2 9 L 4 9 Z M 4 15 L 4 20 L 9 20 L 9 22 L 2 22 L 2 15 L 4 15 Z M 20 9 L 22 9 L 22 2 L 15 2 L 15 4 L 20 4 L 20 9 Z M 20 20 L 14.945 20 L 14.952 22 L 22.001 21.959 L 22.003 14.68 L 20 14.68 L 20 20 Z"/>
					</svg>
				</button>
				<div class="actions">
					<!-- Botón Ubicarme (toggle) -->
					<button id="locateMe" class="btn-icon" aria-pressed="false" title="Ubicarme">
						<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
							<path fill="currentColor" d="M 11.007 1.99 L 13.002 1.998 L 12.998 3.953 C 16.266 4.036 19.975 7.678 20.001 10.999 L 22 11 L 22 12.998 L 20.001 12.996 C 19.932 16.036 16.553 19.9 13.001 20.001 L 12.998 21.999 L 10.996 21.993 L 10.997 20.002 C 7.66 19.944 4.008 16.162 3.999 12.997 L 2 13 L 2 10.999 L 3.999 10.995 C 4.039 7.891 7.56 4.024 10.995 3.958 L 11.007 1.99 Z M 12 7 C 8.151 7 5.745 11.167 7.67 14.5 C 9.594 17.833 14.406 17.833 16.33 14.5 C 16.769 13.74 17 12.878 17 12 C 16.997 9.24 14.76 7.003 12 7 Z M 12 9 C 14.309 9 15.753 11.5 14.598 13.5 C 13.443 15.5 10.557 15.5 9.402 13.5 C 9.139 13.044 9 12.527 9 12 C 9.002 10.344 10.344 9.002 12 9 Z"/>
						</svg>					
					</button>
					<!-- Día/Noche -->
					<button id="btnTerminator" class="btn-icon" aria-pressed="true" title="Día/Noche">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 2a10 10 0 1 0 10 10A8 8 0 0 1 12 2Z"/></svg>
					</button>
					<!-- Radar -->
					<button id="btnRadar" class="btn-icon" aria-pressed="true" title="Radar">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 3a9 9 0 1 0 9 9h-2a7 7 0 1 1-7-7V3Zm0 4a5 5 0 1 0 5 5h-2a3 3 0 1 1-3-3V7Z"/></svg>
					</button>
					<!-- Nubes -->
					<button id="btnClouds" class="btn-icon" aria-pressed="true" title="Nubes">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 18h11a4 4 0 0 0 0-8 5.5 5.5 0 0 0-10.4-2A4.5 4.5 0 0 0 6 18Z"/></svg>
					</button>
					<select id="baseSel">
						<option value="osm">OSM</option>
						<option value="light">Claro</option>
						<option value="dark">Oscuro</option>
						<option value="sat">Satélite</option>
					</select>
					<select id="trackHorizon">
						<option value="0">Sin traza</option>
						<option value="30">+30 min</option>
						<option value="60" selected>+60 min</option>
						<option value="90">+90 min</option>
					</select>
					<!-- Horizonte (huella) -->
					<button id="btnHorizon" class="btn-icon" aria-pressed="true" title="Horizonte">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M 17.186 5.933 C 18.262 4.745 20.059 4.62 21.101 5.62 C 22.079 6.559 22.108 8.34 20.98 9.67 C 20.883 9.55 20.569 8.729 20.037 8.244 C 19.975 8.187 18.726 6.936 18.559 6.806 C 17.981 6.357 17.213 5.947 17.189 5.935 M 11.733 4.961 C 19.531 4.961 24.313 12.509 20.504 18.472 C 16.7 24.426 15.415 16.502 12.853 10.649 C 12.474 9.784 11.113 6.597 7.942 7.558 C 5.263 8.37 1.592 14.051 1.602 13.97 C 2.202 9.028 6.143 4.969 11.733 4.961"/></svg>
					</button>
					<!-- Bajo consumo -->
					<button id="btnLowPower" class="btn-icon" aria-pressed="false" title="Modo bajo consumo">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M16 4h-1V2H9v2H8a3 3 0 0 0-3 3v10a3 3 0 0 0 3 3h8a3 3 0 0 0 3-3V7a3 3 0 0 0-3-3Zm1 13a1 1 0 0 1-1 1H8a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8a1 1 0 0 1 1 1Zm-5.5-1 3-6h-2.5V8l-3 6H11.5v2Z"/></svg>
					</button>
					<!-- Mostrar/ocultar barra temporal -->
					<button id="btnTimeControls" class="btn-icon" aria-pressed="false" title="Controles de tiempo">
						<!-- cronómetro -->
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M9 2h6v2H9V2Zm3 3a8 8 0 1 1-8 8 8.01 8.01 0 0 1 8-8Zm0 2a6 6 0 1 0 6 6 6.006 6.006 0 0 0-6-6Zm1 1h-2v4.586l3.707 3.707 1.414-1.414L13 12.586V8Z"/></svg>
					</button>
				</div>
			</header>
			
			<div id="map"></div>

			<div class="panel">
				<button class="min-btn" id="minimizePanel" title="Ocultar panel">⮞</button>
				<h2>Estado</h2>
				<div class="kv" id="status">TLE: esperando…</div>
				<div class="kv" id="utcStatus">UTC: —</div>
				
				<!-- Filtro rápido por nombre -->
				<div style="margin-top:.35rem">
					<input id="satFilter" placeholder="Filtrar satélites…" 
						style="width:93%;background:#0c1330;color:var(--text);border:1px solid #2a3a6b;border-radius:.5rem;padding:.45rem .55rem" />
				</div>
				
				<!-- Lista dinámica de satélites -->
				<div id="satList"></div>
				
				<details id="addSatPanel">
					<summary>➕ Añadir satélite (TLE)</summary>
					<p class="hint">Introduce el <b>nombre</b> y pega el TLE completo en un único campo (2 líneas empezando por <code>1</code> y <code>2</code>).</p>
					<label>Nombre del satélite</label>
					<input id="satName" placeholder="Ej: SENTINEL-2A" style="width:100%;background:#0c1330;color:var(--text);border:1px solid #2a3a6b;border-radius:.5rem;padding:.5rem" />
					<label style="display:block;margin-top:.5rem">TLE (2 líneas)</label>
					<textarea id="tleBlock" placeholder="1 42063U 17013A ...&#10;2 42063 98.5661 ..."></textarea>
					<!-- Estado de validación del TLE pegado -->
					<div id="addTleInfo" class="hint" style="margin:.25rem 0 .35rem">
						<span id="addLen">—</span> · <span id="addL1">L1: —</span> · <span id="addL2">L2: —</span> · <span id="addState">Estado: esperando…</span>
					</div>
					<div style="display:flex;align-items:center;gap:.5rem">
						<button id="addSatBtn">Añadir</button>
						<button id="newIconBtn" class="btn-icon" title="Elegir icono"></button>
						<input type="color" id="defaultOrbitColor" value="#ff3333" title="Color de órbita por defecto" />					
					</div>
				</details>
			</div>
			
			<!-- Botón flotante para reabrir el panel -->
			<button id="panelToggle" class="panel-toggle" aria-label="Mostrar panel"><span class="dot"></span> Panel</button>
						
			<!-- ===== Barra temporal (tipo NASA Eyes) ===== -->
			<nav class="time-controls active" id="timeControls">
				<button class="btn" id="useNow">Ahora</button>
				<div class="rate-indicator" id="scrubRate">Tiempo real</div>
				<button class="btn" id="scrubPlay" title="Reproducir / Pausar">▶</button>
				<input type="datetime-local" id="refTime" step="1" />
				<div class="slider-container">
					<div class="center-mark"></div>
 					<input id="scrubRange" class="slider-input" type="range" min="0" max="1000" step="1" />
 				</div>
 			</nav>
		</div>
		
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
		<script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
		<script>
			(function(){
				const MERC_MAX = 85.05112878;
				
				function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
				
				ready(function(){
				
					// Toggle de acciones en móvil
					const actionsToggle = document.getElementById('actionsToggle');
					const actionsBar = document.querySelector('header .actions');
					const headerEl = document.querySelector('header');
					if (actionsToggle && actionsBar){
						function positionActions(){
							const rect = headerEl.getBoundingClientRect();
							document.documentElement.style.setProperty('--actionsTop', `${Math.round(rect.bottom)}px`);
						}
						actionsToggle.addEventListener('click', ()=>{
							positionActions();
							actionsBar.classList.toggle('open');
						});
						// autocerrar y recolocar en resize/orientación
						const debounce = (fn,ms=120)=>{ let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a),ms); }; };
						window.addEventListener('resize', debounce(()=>{ actionsBar.classList.remove('open'); positionActions(); positionCenterMark(); map.invalidateSize(); }, 150));
						window.addEventListener('orientationchange', ()=>{ actionsBar.classList.remove('open'); positionActions(); setTimeout(()=>{ positionCenterMark(); map.invalidateSize(); }, 200); });
						document.addEventListener('fullscreenchange', ()=>{ setTimeout(()=>{ positionCenterMark(); map.invalidateSize(); }, 200); });
 					}
					
					// === Sincroniza <meta name="theme-color"> con el color real del header ===
					(function syncThemeColorWithHeader(){
						const meta = document.querySelector('meta[name="theme-color"]') || (()=>{ const m=document.createElement('meta'); m.setAttribute('name','theme-color'); document.head.appendChild(m); return m; })();
						const header = document.querySelector('header');
						if(!header) return;
						function rgbToHex(rgb){
							// rgb(14, 21, 64)  |  rgba(14, 21, 64, 0.9)
							const m = rgb.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*[\d.]+)?\s*\)/i);
							if(!m) return '#0e1540';
							return '#' + [m[1],m[2],m[3]].map(n => Number(n).toString(16).padStart(2,'0')).join('');
						}
						function apply(){
							const bg = getComputedStyle(header).backgroundColor;
							meta.setAttribute('content', rgbToHex(bg));
						}
						apply();
						// Reaplica si el sistema cambia de tema o si algo toca el estilo
						window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').addEventListener?.('change', apply);
					})();
					
					// === Botón Pantalla Completa (móvil) ===
					(function initFullscreen(){
						const btn = document.getElementById('fullScreenBtn');
						if(!btn) return;
						const appEl = document.getElementById('app') || document.documentElement;
						const ENTER_ICON = '<svg viewBox="0 0 24 24" width="15" height="15" aria-hidden="true"><path fill="currentColor" d="M 4 9 L 4 4 L 9 4 L 9 2 L 2 2 L 2 9 L 4 9 Z M 4 15 L 4 20 L 9 20 L 9 22 L 2 22 L 2 15 L 4 15 Z M 20 9 L 22 9 L 22 2 L 15 2 L 15 4 L 20 4 L 20 9 Z M 20 20 L 14.945 20 L 14.952 22 L 22.001 21.959 L 22.003 14.68 L 20 14.68 L 20 20 Z"/></svg>';
						const EXIT_ICON  = '<svg viewBox="0 0 24 24" width="15" height="15" aria-hidden="true"><path fill="currentColor" d="M 9 3 L 7 3 L 7 7 L 3 7 L 3 9 L 9 9 L 9 3 Z M 17 7 L 17 3 L 15 3 L 15 9 L 21 9 L 21 7 L 17 7 Z M 7 21 L 9.003 21 L 9 15 L 3 15 L 3 17 L 7 17 L 7 21 Z M 21 15 L 15 15 L 15 21 L 17 21 L 17 17 L 21 17 L 21 15 Z"/></svg>';
						function isFs(){
							return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
						}
						function refresh(){
							btn.title = isFs() ? 'Salir de pantalla completa' : 'Pantalla completa';
							btn.setAttribute('aria-label', btn.title);
							btn.innerHTML = isFs() ? EXIT_ICON : ENTER_ICON;
						}
						async function enterFs(){
							const el = appEl;
							try{
								if (el.requestFullscreen) await el.requestFullscreen();
								else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen(); // iOS Safari
								else if (el.msRequestFullscreen) await el.msRequestFullscreen();
							}catch(_){}
							refresh();
						}
						async function exitFs(){
							try{
								if (document.exitFullscreen) await document.exitFullscreen();
								else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
								else if (document.msExitFullscreen) await document.msExitFullscreen();
							}catch(_){}
							refresh();
						}
						btn.addEventListener('click', ()=>{
							isFs() ? exitFs() : enterFs();
						});
						document.addEventListener('fullscreenchange', refresh);
						document.addEventListener('webkitfullscreenchange', refresh);
						refresh();
					})();
				
					// --- MAPA (zoom/pan suaves) ---
					const map = L.map('map', {
						zoomControl: false,        // ← sin botones +/−
						worldCopyJump: false,
						// Zoom de rueda más fluido y con pasos fraccionados
						scrollWheelZoom: true,
						wheelDebounceTime: 25,       // respuesta rápida
					           wheelPxPerZoomLevel: 140,
					           // <-- pasos de 0.5 niveles
					           zoomSnap: 0.5,
					           zoomDelta: 0.5,
						zoomAnimation: true,
						zoomAnimationThreshold: 8,   // anima incluso saltos más grandes
						// Gestos táctiles/teclado centrados y panning con inercia suave
						touchZoom: 'center',
						doubleClickZoom: false,   // desactivamos el nativo (+1)
						inertia: true,
						inertiaDeceleration: 2500,
						inertiaMaxSpeed: 1500,
						easeLinearity: 0.2,
						 maxZoom: 22, minZoom: 2
					}).setView([0,0], 2);
					
					// Doble clic personalizado: +0.5 alrededor del punto clicado
					map.on('dblclick', (e) => {
						const next = Math.min(map.getMaxZoom(), map.getZoom() + 0.5);
						// setZoomAround mantiene el centro en el lugar del clic
						map.setZoomAround(e.latlng, next);
					});
					
					// --- Panel colapsable ---
					const panelEl = document.querySelector('.panel');
					const btnMin  = document.getElementById('minimizePanel');
					const btnFab  = document.getElementById('panelToggle');
					function setPanelCollapsed(collapsed){
						if(collapsed){
							// Quita ocultación dura para permitir la animación de salida si venía visible
							panelEl.classList.remove('collapsed-hidden');
							// Marca ARIA/inert para evitar foco y eventos mientras está fuera
							panelEl.setAttribute('aria-hidden','true');
							panelEl.setAttribute('inert','');
							// Activa animación hacia la derecha
							panelEl.classList.add('collapsed');
							// Cuando termine la transición, aplica ocultación dura
							const onEnd = (ev)=>{
								if(ev.propertyName !== 'transform') return;
								panelEl.classList.add('collapsed-hidden');
								panelEl.removeEventListener('transitionend', onEnd);
							};
							panelEl.addEventListener('transitionend', onEnd);
							btnFab.style.display = 'inline-flex';
						}else{
							// Quita ocultación dura y fuerza reflow para que se anime al entrar
							panelEl.classList.remove('collapsed-hidden');
							// Fuerza reflow para reiniciar la transición de 'transform'
							void panelEl.offsetWidth;
							panelEl.classList.remove('collapsed');
							// Restablece ARIA/inert
							panelEl.removeAttribute('aria-hidden');
							panelEl.removeAttribute('inert');
							btnFab.style.display = 'none';
						}
						try{ localStorage.setItem('panelCollapsed', collapsed ? '1' : '0'); }catch(e){}
					}
					// eventos
					if(btnMin) btnMin.addEventListener('click', ()=> setPanelCollapsed(true));
					if(btnFab) btnFab.addEventListener('click', ()=> setPanelCollapsed(false));
					// restaurar estado
					try{
						const saved = localStorage.getItem('panelCollapsed');
						if(saved === '1'){
							// Arrancar directamente oculto sin animar en el primer paint
							panelEl.classList.add('collapsed','collapsed-hidden');
							panelEl.setAttribute('aria-hidden','true');
							panelEl.setAttribute('inert','');
							btnFab.style.display = 'inline-flex';
						}
					}catch(e){}
										
					const baseCommonOpts = {
						maxNativeZoom: 19,   // detalle real de OSM
						maxZoom: 22,         // permite reescalar hasta 22
						updateWhenZooming: true, // actualiza durante la animación
						updateWhenIdle: false,   // prioriza fluidez
						keepBuffer: 3           // tiles alrededor para evitar parpadeos
					};
					const baseOSM   = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
						{ ...baseCommonOpts, maxNativeZoom: 19, attribution: 'OpenStreetMap contributors' }).addTo(map);
					const baseLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
						{ ...baseCommonOpts, maxNativeZoom: 20, attribution: 'OpenStreetMap & CARTO' });
					const baseDark  = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
						{ ...baseCommonOpts, maxNativeZoom: 20, attribution: 'OpenStreetMap & CARTO' });

					// Base satélite (Esri World Imagery)
					const baseSat   = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
						{ ...baseCommonOpts,  maxNativeZoom: 19, attribution: 'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community' });
					
					// Llevar control de la base actual para no borrar overlays al cambiar
					let currentBase = baseOSM;
								
					// ----- Estado de tiempo de referencia (auto vs manual) -----
					const timeState = { manual:false, value:new Date() };
					function refNow(){ return timeState.manual ? new Date(timeState.value) : new Date(); }
					// Formatea para <input type="datetime-local"> (zona local, sin 'Z')
					function toLocalDTValue(d){
						const pad = n => String(n).padStart(2,'0');
						const y=d.getFullYear(), m=pad(d.getMonth()+1), day=pad(d.getDate());
						const hh=pad(d.getHours()), mm=pad(d.getMinutes()), ss=pad(d.getSeconds());
						return `${y}-${m}-${day}T${hh}:${mm}:${ss}`;
					}
					
					// Línea global de UTC bajo "Estado"
					function updateUTCStatus(){
						const u = document.getElementById('utcStatus'); if(!u) return;
						const d = refNow();
						let s = 'UTC: ' + d.toISOString().replace('T',' ').replace('Z',' UTC');
						s += timeState.manual ? ' (manual)' : ' (reloj del sistema)';
						u.textContent = s;
					}
					
					// Recalcula todo cuando cambia el tiempo de referencia
					function applyRefTime(){
						if(window.dayNightLayer) window.dayNightLayer.setTime(refNow());
						if(typeof buildTerminatorLine === 'function') buildTerminatorLine();
						if(typeof tick === 'function') tick();
						if(typeof computeAllTracks === 'function') computeAllTracks();
						updateUTCStatus();
						// sincroniza scrubber si existe
						try{ if (typeof updateScrubberUI === 'function') updateScrubberUI(); }catch(_){}
					}
									
					// === Panes por orden: satélites > órbitas > día/noche > radar > nubes > mapa ===
					
					// Pane para satélites (TOP map panes)
					let satPane = map.getPane('satPane');
					if (!satPane) { map.createPane('satPane'); satPane = map.getPane('satPane'); }
					satPane.style.zIndex = '750';       // 1) SATÉLITES (más alto de los panes del mapa)
					satPane.style.pointerEvents = 'auto';
					
					// 2) ÓRBITAS (polylines/círculos)
					let orbitPane = map.getPane('orbitPane');
					if(!orbitPane){ map.createPane('orbitPane'); orbitPane = map.getPane('orbitPane'); }
					orbitPane.style.zIndex = '720';
					orbitPane.style.pointerEvents = 'none';

					// 4) DÍA/NOCHE (terminator)
					let paneEl = map.getPane('terminatorPane');
					if(!paneEl){ map.createPane('terminatorPane'); paneEl = map.getPane('terminatorPane'); }
					paneEl.style.zIndex = '500';
					paneEl.style.pointerEvents = 'none';

					// 5) RADAR (RainViewer)
					let radarPane = map.getPane('radarPane');
					if(!radarPane){ map.createPane('radarPane'); radarPane = map.getPane('radarPane'); }
					radarPane.style.zIndex = '390';
					radarPane.style.pointerEvents = 'none';

					// 6) NUBES (Sat IR)
					let cloudsPane = map.getPane('cloudsPane');
					if(!cloudsPane){ map.createPane('cloudsPane'); cloudsPane = map.getPane('cloudsPane'); }
					cloudsPane.style.zIndex = '380';
					cloudsPane.style.pointerEvents = 'none';								
														
														
					// ========================= RainViewer (sin TimeDimension) =========================
					// Usamos la API pública para obtener la lista de frames y elegimos:
					//  - si "Ahora": el frame MÁS RECIENTE disponible
					//  - si manual:  el frame más cercano ≤ refTime()
					const RAINV_META_URL = 'https://api.rainviewer.com/public/weather-maps.json';
					
					// Radar
					let rainv = {
						host: 'https://tilecache.rainviewer.com',
						frames: [],           // [{time, path}, ...] (segundos desde epoch)
						layer: null,
						lastUrl: '',
						_lastMeta: 0
					};
					// Satélite (infrared)
					let satv = {
						host: 'https://tilecache.rainviewer.com',
						frames: [],           // [{time, path}, ...]
						layer: null,
						lastUrl: '',
						_lastMeta: 0
					};
					
					function fetchRainMeta(){
						return fetch(RAINV_META_URL, { cache: 'no-store' })
						.then(r => r.json())
						.then(j => {
							const host = j?.host || rainv.host;
							rainv.host = host; satv.host = host;
							// Radar
							const past = Array.isArray(j?.radar?.past) ? j.radar.past : [];
							const nowc = Array.isArray(j?.radar?.nowcast) ? j.radar.nowcast : [];
							rainv.frames = past.concat(nowc).sort((a,b)=>a.time-b.time);
							rainv._lastMeta = Date.now();
							// Satélite (infrared)
							const infrared = Array.isArray(j?.satellite?.infrared) ? j.satellite.infrared : [];
							satv.frames = infrared.sort((a,b)=>a.time-b.time);
							satv._lastMeta = Date.now();
						})
						.catch(()=>{ /* silencio: sin conexión o CORS */ });
					}
					
					function pickBestFrame(frames, date){
						if (!frames.length) return null;
						const ts = Math.floor(date.getTime()/1000);
						if (!timeState.manual){
							// "Ahora": el último frame disponible
							return frames[frames.length-1];
						}
						// Manual: el frame más cercano que no supere refTime
						let best = frames[0];
						for (const f of frames){
							if (f.time <= ts) best = f; else break;
						}
						return best;
					}
					
					// Construye URL de teselas a partir de "path" de RainViewer
					// Formato: {host}{path}/256/{z}/{x}/{y}/{color}/{smooth}_{snow}.png
					// Elegimos color 3 (The Weather Channel), smooth=1, snow=1
					function pathToTileUrl(path){
						return `${rainv.host}${path}/256/{z}/{x}/{y}/3/1_1.png`;
					}
					
					function ensureRadar(){
					// Capa vacía al inicio; se rellena con setUrl cuando tengamos meta+frame
						if (!rainv.layer){
							rainv.layer = L.tileLayer('', {
								pane: 'radarPane',   // 5) radar por encima de nubes
								updateWhenZooming: true,
								updateWhenIdle: false,
								opacity: 0.85,
								maxNativeZoom: 9,   // límite actual de RainViewer
								maxZoom: 22,
								noWrap: true,
								crossOrigin: true,
								attribution: 'Radar © RainViewer'
							}).addTo(map);
							// Fuerza zoom entero en tiles RainViewer (evita '.../256/2.5/...')
							const _origGetTileUrlRadar = rainv.layer.getTileUrl.bind(rainv.layer);
							rainv.layer.getTileUrl = function(coords){
								const z = (this._tileZoom != null ? this._tileZoom : this._map.getZoom());
								// construye con z entero
								return L.Util.template(this._url, {
									s: this._getSubdomain(coords),
									x: coords.x, y: coords.y, z: Math.round(z)
								});
							};
						}
						// Carga metadatos (si hace >2 min que no actualizamos) y ajusta frame
						const needMeta = (Date.now() - rainv._lastMeta) > 120000 || !rainv.frames.length;
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(rainv.frames, refNow());
						if (!f) return;
						const url = pathToTileUrl(f.path);
						if (url !== rainv.lastUrl){
							rainv.layer.setUrl(url);
							rainv.lastUrl = url;
						}
						if (map.hasLayer(rainv.layer)) rainv.layer.bringToFront();
						// Mantén el terminador arriba
						if (window.dayNightLayer) window.dayNightLayer.bringToFront(); if (window.ringLine) window.ringLine.bringToFront();
						});
					}
					
					function updateRadar(){
						// Si estamos en "Ahora", refresca metadatos de vez en cuando
						const needMeta = !timeState.manual && ((Date.now() - rainv._lastMeta) > 120000);
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(rainv.frames, refNow());
						if (!f) return;
						const url = pathToTileUrl(f.path);
						if (url !== rainv.lastUrl){
							rainv.layer.setUrl(url);
							rainv.lastUrl = url;
						}
						});
					}
					
					// Inicializa radar
					ensureRadar();
					
					// ------------------------- Nubes (Satélite IR) -------------------------
					// color=0 (grayscale IR), usamos clase 'clouds-only' para blend "solo nubes"
					function pathToSatUrl(path){
						return `${satv.host}${path}/256/{z}/{x}/{y}/0/1_1.png`;
					}
					
					function ensureSatRV(){
					if (!satv.layer){
						satv.layer = L.tileLayer('', {
							pane: 'cloudsPane',      // 6) nubes por debajo de radar
							updateWhenZooming: true,
							updateWhenIdle: false,
							className: 'clouds-only',   // mix-blend-mode: lighten
							opacity: 0.95,
							maxNativeZoom: 9,
							maxZoom: 22,
							noWrap: true,
							crossOrigin: true,
							attribution: 'Satélite © RainViewer'
						}).addTo(map);
						// Fuerza zoom entero en tiles RainViewer (satélite)
						const _origGetTileUrlSat = satv.layer.getTileUrl.bind(satv.layer);
						satv.layer.getTileUrl = function(coords){
							const z = (this._tileZoom != null ? this._tileZoom : this._map.getZoom());
							return L.Util.template(this._url, {
								s: this._getSubdomain(coords),
								x: coords.x, y: coords.y, z: Math.round(z)
							});
						};
					}
					const needMeta = (Date.now() - satv._lastMeta) > 120000 || !satv.frames.length;
					const p = needMeta ? fetchRainMeta() : Promise.resolve();
					p.then(()=>{
					const f = pickBestFrame(satv.frames, refNow());
					if (!f) return;
					const url = pathToSatUrl(f.path);
					if (url !== satv.lastUrl){
						satv.layer.setUrl(url);
						satv.lastUrl = url;
					}
					if (map.hasLayer(satv.layer)) satv.layer.bringToFront();
					// Mantén el terminador arriba
						if (window.dayNightLayer) window.dayNightLayer.bringToFront(); if (window.ringLine) window.ringLine.bringToFront();
					});
					}
					
					function updateSatRV(){
						const needMeta = !timeState.manual && ((Date.now() - satv._lastMeta) > 120000);
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(satv.frames, refNow());
						if (!f) return;
						const url = pathToSatUrl(f.path);
						if (url !== satv.lastUrl){
							satv.layer.setUrl(url);
							satv.lastUrl = url;
						}
						});
					}
					
					// Inicializa nubes satélite
					ensureSatRV();
					
					// Toggle mostrar/ocultar
					
					// --- Centraliza el orden de capas dentro de cada pane ---
					// (Los zIndex de los panes ya fijan el orden global)
					function restoreOrder(){
						if (satv.layer  && map.hasLayer(satv.layer))   satv.layer.bringToFront();   // Nubes
						if (rainv.layer && map.hasLayer(rainv.layer))  rainv.layer.bringToFront();  // Radar
						if (window.ringLine)      window.ringLine.bringToFront();                   // Terminador (SVG)
						if (window.dayNightLayer) window.dayNightLayer.bringToFront();              // Terminador (tiles)
					}					
					
					// === Toggles como botones con icono ===
					const termBtn   = document.getElementById('btnTerminator');
					const radarBtn  = document.getElementById('btnRadar');
					const cloudsBtn = document.getElementById('btnClouds');
					const horizBtn  = document.getElementById('btnHorizon');
					function setBtn(btn, on){ if(!btn) return; btn.classList.toggle('active', !!on); btn.setAttribute('aria-pressed', on?'true':'false'); }
					function isOn(btn){ return !!(btn && btn.classList.contains('active')); }
					function applyTerm(on){
						setBtn(termBtn, on);
						if (on){ if (dayNightLayer) dayNightLayer.addTo(map); if (ringLine) ringLine.addTo(map); }
						else { if (dayNightLayer) map.removeLayer(dayNightLayer); if (ringLine) map.removeLayer(ringLine); }
						// reponer overlays activos al frente
						if (on){
							if (isOn(radarBtn)  && rainv?.layer){ rainv.layer.addTo(map); }
							if (isOn(cloudsBtn) && satv?.layer){ satv.layer.addTo(map); }
							restoreOrder?.();
						}
						try{ localStorage.setItem('sr.t.term', on?'1':'0'); }catch(_){}
					}
					function applyRadar(on){
						setBtn(radarBtn, on);
						if (on){ if (rainv.layer){ rainv.layer.addTo(map); rainv.layer.bringToFront(); } }
						else { if (rainv.layer) map.removeLayer(rainv.layer); }
						try{ localStorage.setItem('sr.t.radar', on?'1':'0'); }catch(_){}
					}
					function applyClouds(on){
						setBtn(cloudsBtn, on);
						if (on){ if (satv.layer){ satv.layer.addTo(map); satv.layer.bringToFront(); } }
						else { if (satv.layer) map.removeLayer(satv.layer); }
						try{ localStorage.setItem('sr.t.clouds', on?'1':'0'); }catch(_){}
					}
					function applyHorizon(on){
						setBtn(horizBtn, on);
						try{ localStorage.setItem('sr.t.horiz', on?'1':'0'); }catch(_){}
						for (const id in state.sats){
							const s = state.sats[id];
							// asegúrate de tener círculo calculado si está ON
							if (on){ updateSat(id); }
							if (!s.circle) continue;
							if (on && s.visible !== false){ if(!map.hasLayer(s.circle)) s.circle.addTo(map); }
							else { if(map.hasLayer(s.circle)) map.removeLayer(s.circle); }
						}
					}
					termBtn?.addEventListener('click',  ()=> applyTerm(!isOn(termBtn)));
					radarBtn?.addEventListener('click', ()=> applyRadar(!isOn(radarBtn)));
					cloudsBtn?.addEventListener('click',()=> applyClouds(!isOn(cloudsBtn)));
					horizBtn?.addEventListener('click', ()=> applyHorizon(!isOn(horizBtn)));
					
					// Inicializa el input con la hora actual (local) — AHORA sí, tras definir toLocalDTValue/applyRefTime
					const refInput = document.getElementById('refTime');
					if(refInput){
						refInput.value = toLocalDTValue(new Date());
						refInput.addEventListener('change', () => {
							const v = refInput.value;        // "YYYY-MM-DDTHH:mm[:ss]"
							if(!v) return;
							const d = new Date(v);           // interpretado en LOCAL
							if(isNaN(d.getTime())) return;
							timeState.manual = true;
							timeState.value  = d;
							applyRefTime();
							updateRadar();                   // sincroniza radar al nuevo frame
							updateSatRV();                   // sincroniza nubes al nuevo frame
							updateScrubberUI();
							updateNowBadge();
							updateUTCStatus();
						});
					}

					
					// Botón "Ahora" → vuelve a automático
					const useNowBtn = document.getElementById('useNow');
					if(useNowBtn){
						useNowBtn.addEventListener('click', () => {
							timeState.manual = false;
							timeState.value  = new Date();
							if(refInput) refInput.value = toLocalDTValue(new Date());
							applyRefTime();
							updateRadar();
							updateSatRV();
							// recuperar “ahora”: pausa reproducción y centra el slider (1×)
							try{
								if (scrub){
									scrub.playing=false; refreshPlayBtn();
									scrub.range.value = '500'; setSpeed(1); updateScrubberUI();
								}
							}catch(_){}
							updateNowBadge();
							updateUTCStatus();
						});
					}
					
					// ====== SCRUBBER (barra temporal tipo NASA Eyes) ======
					const scrub = {
						range: document.getElementById('scrubRange'),
						btnPlay: document.getElementById('scrubPlay'),
						playing:false,
						speed: parseFloat(localStorage.getItem('sr.scrub.speed') || '1'), // 1× por defecto
						lastReal: null,
						_lastOverlay: 0
					};
					function refreshPlayBtn(){
						if (!scrub.btnPlay) return;
						/* Muestra "pausa" tanto si está reproduciendo como si está en Tiempo real */
						const showPause = (scrub.playing || !timeState.manual);
						scrub.btnPlay.textContent = showPause ? '❚❚' : '▶';
						scrub.btnPlay.title = showPause ? 'Pausar' : 'Reproducir';
						window.__scrubPlaying = scrub.playing;
					}
					function setSpeed(val){
						// Persistimos la velocidad actual (puede ser negativa para rebobinar)
						scrub.speed = Number(val)||1;
						try{ localStorage.setItem('sr.scrub.speed', String(scrub.speed)); }catch(_){}
						// Actualiza indicador visual
						const rateEl = document.getElementById('scrubRate');
						if (rateEl){
							// Si estamos en "ahora" (modo tiempo real), prima el texto “Tiempo real”
							if (!timeState.manual){
								rateEl.textContent = 'Tiempo real';
								rateEl.title = 'Tiempo real';
							}else{
								const s = scrub.speed;
								const sign = s<0 ? '−' : '';
								const abs = Math.abs(s);
								const text = abs===1 ? '1×' : (abs<10 ? abs.toFixed(2)+'×' : (abs<100 ? abs.toFixed(1)+'×' : Math.round(abs)+'×'));
								rateEl.textContent = sign + text;
								rateEl.title = (s===1 ? 'Tiempo real' : (s>1 ? 'Acelerando' : 'Rebobinando'));
							}
						}
					}
					
					function updateNowBadge(){
						const nowOn = (timeState.manual === false);
						document.getElementById('useNow')?.classList.toggle('is-now', nowOn);
						const rateEl = document.getElementById('scrubRate');
						rateEl?.classList.toggle('is-now', nowOn);
						if (nowOn && rateEl){ rateEl.textContent = 'Tiempo real'; rateEl.title = 'Tiempo real'; }
					}
					
					// Mapeo del slider → velocidad (centro=1×, derecha>>+rápido, izquierda<<−rápido)
					function sliderToSpeed(){
						const raw = Number(scrub.range?.value||500);
						const pos = raw/1000; // 0..1
						const offset = pos - 0.5;
						const DEAD = 0.02; // zona muerta ±2% en el centro
						if (Math.abs(offset) < DEAD) return 1; // 1 seg × 1 seg
						const m = (Math.abs(offset) - DEAD) / (0.5 - DEAD); // 0..1
						const sign = offset > 0 ? 1 : -1;
						const MAX = 86400; // 1 día por segundo en los extremos
						const speed = Math.pow(MAX, m); // 1→MAX de forma exponencial
						return sign * speed;
					}
					function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

					function updateScrubberUI(){
						// reflejar el tiempo actual en el input datetime (si no está en edición)
						if (refInput && document.activeElement !== refInput){
							refInput.value = toLocalDTValue(refNow());
						}
						// Reposiciona la marca central exactamente en el centro visual del <input type="range">
						positionCenterMark();
					}
					// Eventos UI (play + slider activa reproducción)
					if (scrub.btnPlay){
						scrub.btnPlay.addEventListener('click', ()=>{
							scrub.playing = !scrub.playing;
							if (scrub.playing && !timeState.manual){ timeState.manual = true; timeState.value = new Date(); }
							refreshPlayBtn();
							updateNowBadge();
							if (scrub.playing){ scrub.lastReal=null; requestAnimationFrame(playLoop); }
						});
					}

					// Slider: al mover → activa reproducción, pasa a manual y ajusta velocidad
					if (scrub.range){
						scrub.range.addEventListener('input', ()=>{
							setSpeed(sliderToSpeed());
							if (!scrub.playing){
								scrub.playing = true;
								refreshPlayBtn();
								scrub.lastReal=null; requestAnimationFrame(playLoop);
							}
							// salir de "Ahora" al tocar el slider y actualizar estilos
							timeState.manual = true;
							updateNowBadge();
							updateUTCStatus();
							updateScrubberUI(); // solo mueve el knob
						});
						// valor inicial (centro = 1×)
						if (!scrub.range.value) scrub.range.value = String(500);
						setSpeed(sliderToSpeed());
					}
					
					// Calcula la posición de la marca central en píxeles respecto a .slider-container
					function positionCenterMark(){
						const cont = document.querySelector('.slider-container');
						const mark = cont?.querySelector('.center-mark');
						const rng  = document.getElementById('scrubRange');
						if (!cont || !mark || !rng) return;
						const cr = cont.getBoundingClientRect();
						const rr = rng.getBoundingClientRect();
						const x = rr.left + rr.width/2 - cr.left; // centro del input dentro del contenedor
						mark.style.left = x + 'px';
					}					
					
					function playLoop(ts){
						if (!scrub.playing) return;
						if (scrub.lastReal===null) scrub.lastReal = ts;
						const dt = (ts - scrub.lastReal)/1000; // seg reales
						scrub.lastReal = ts;
						// avanza tiempo simulado
						const cur = refNow().getTime();
						timeState.manual = true;
						timeState.value  = new Date(cur + dt * 1000 * scrub.speed);
						applyRefTime();
						// overlays (radar/nubes) cada 3 s como máx. durante reproducción
						if (ts - scrub._lastOverlay > 3000){ updateRadar(); updateSatRV(); scrub._lastOverlay = ts; }
						if (scrub.playing) requestAnimationFrame(playLoop);
					}
					// Inicializa UI
					refreshPlayBtn(); updateScrubberUI(); positionCenterMark(); updateNowBadge();
					
					// Garantiza reflow correcto del mapa al cambiar viewport (móvil/tablet)
					window.addEventListener('resize', (()=>{ let t; return ()=>{ clearTimeout(t); t=setTimeout(()=>map.invalidateSize(),120); }; })());
					window.addEventListener('orientationchange', ()=> setTimeout(()=>map.invalidateSize(), 200));

					// Mostrar/ocultar controles de tiempo desde el botón de menú (y ajustar panel para no tapar)
					(function initTimeToggle(){
						const btn = document.getElementById('btnTimeControls');
						const box = document.getElementById('timeControls');
						if(!btn || !box) return;
						const saved = localStorage.getItem('sr.ui.scrubVisible') === '1';
						box.classList.toggle('active', saved);
						btn.classList.toggle('active', saved);
						btn.setAttribute('aria-pressed', saved?'true':'false');
						function updateTCHeight(){
							const h = box.classList.contains('active') ? box.getBoundingClientRect().height : 0;
							document.documentElement.style.setProperty('--tc-height', `${Math.round(h)}px`);
						}
						updateTCHeight();
						btn.addEventListener('click', ()=>{
							const on = !box.classList.contains('active');
							box.classList.toggle('active', on);
							btn.classList.toggle('active', on);
							btn.setAttribute('aria-pressed', on?'true':'false');
							try{ localStorage.setItem('sr.ui.scrubVisible', on?'1':'0'); }catch(_){}
							updateTCHeight();
							setTimeout(()=>{ positionCenterMark(); map.invalidateSize(); }, 120);
						});
						window.addEventListener('resize', ()=>{ updateTCHeight(); positionCenterMark(); });
					})();
				
					document.getElementById('baseSel').addEventListener('change', (e)=>{
						const v = e.target.value;
						const nextBase = (v==='light' ? baseLight : v==='dark' ? baseDark : v==='sat' ? baseSat : baseOSM);
						if (currentBase && map.hasLayer(currentBase)) map.removeLayer(currentBase);
						nextBase.addTo(map);
						currentBase = nextBase;

						try{ localStorage.setItem('sr.base', v); }catch(_){}
						restoreOrder();
					});
				
					// --- DÍA/NOCHE por tiles (GridLayer Canvas) ---
					let dayNightLayer = null; window.dayNightLayer = null;
					let ringLine = null;      window.ringLine     = null;
				
					const rad = x => x*Math.PI/180;
					const deg = x => x*180/Math.PI;
					const normLon = d => { while(d<-180) d+=360; while(d>180) d-=360; return d; };
					const jdFromDate = date => date.getTime()/86400000 + 2440587.5;
				
					function subsolar(date){
						const JD = jdFromDate(date);
						const T = (JD - 2451545.0)/36525.0;
						let L0 = 280.46646 + 36000.76983*T + 0.0003032*T*T; L0 = ((L0%360)+360)%360;
						const M  = 357.52911 + 35999.05029*T - 0.0001537*T*T; const Mr = rad(M);
						const C  = (1.914602 - 0.004817*T - 0.000014*T*T)*Math.sin(Mr)
								+ (0.019993 - 0.000101*T)*Math.sin(2*Mr)
								+ 0.000289*Math.sin(3*Mr);
						const lambda = L0 + C; const Omega = 125.04 - 1934.136*T;
						const lambdaApp = lambda - 0.00569 - 0.00478*Math.sin(rad(Omega));
						const eps0 = 23 + 26/60 + 21.448/3600 - (46.8150/3600)*T - (0.00059/3600)*T*T + (0.001813/3600)*T*T*T;
						const eps  = eps0 + 0.00256*Math.cos(rad(Omega));
						const epsr = rad(eps), lamr = rad(lambdaApp);
						const alpha = Math.atan2(Math.cos(epsr)*Math.sin(lamr), Math.cos(lamr));
						const delta = Math.asin(Math.sin(epsr)*Math.sin(lamr));
						let Theta = 280.46061837 + 360.98564736629*(JD - 2451545.0) + 0.000387933*T*T - T*T*T/38710000.0;
						Theta = ((Theta%360)+360)%360;
						const alphaDeg = ((deg(alpha)%360)+360)%360;
						const lon = normLon(alphaDeg - Theta);
						const lat = deg(delta);
						return { lat, lon };
					}
				
					// GridLayer: usa paso dinámico según zoom para rendimiento
					const DayNight = L.GridLayer.extend({
					initialize: function(opts){ L.setOptions(this, opts||{}); this._sun = subsolar(new Date()); },
					setTime: function(date){ this._sun = subsolar(date); this.redraw(); },
					createTile: function(coords, done){
						const tile = L.DomUtil.create('canvas','leaflet-tile');
						const size = this.getTileSize(); tile.width = size.x; tile.height = size.y;
						const ctx = tile.getContext('2d');
						const z = this._map ? this._map.getZoom() : 2;
						// Más grueso a zoom bajos para ahorrar CPU, más fino con zoom altos
						const step = Math.max(2, 10 - Math.min(8, Math.floor(z))); // 8→2 px aprox.
						const origin = coords.scaleBy(size);
						ctx.fillStyle = '#000000';
						const opacity = (typeof this.options.opacity === 'number') ? this.options.opacity : 0.8;
						const s = this._sun; const sphi = rad(s.lat), slam = rad(s.lon);
						const sx = Math.cos(sphi)*Math.cos(slam), sy = Math.cos(sphi)*Math.sin(slam), sz = Math.sin(sphi);
						for (let y=0; y<size.y; y+=step){
						for (let x=0; x<size.x; x+=step){
							const ll = this._map.unproject(L.point(origin.x + x + step/2, origin.y + y + step/2));
							const phi = rad(ll.lat), lam = rad(ll.lng);
							const nx = Math.cos(phi)*Math.cos(lam), ny = Math.cos(phi)*Math.sin(lam), nz = Math.sin(phi);
							const cosz = nx*sx + ny*sy + nz*sz; // >0 día, <0 noche
							if (cosz < 0){ ctx.globalAlpha = opacity; ctx.fillRect(x, y, step, step); }
						}
						}
						ctx.globalAlpha = 1;
						if(done) done(null, tile);
						return tile;
					}
					});
				
					dayNightLayer = new DayNight({ tileSize: 256, opacity: 0.8, pane:'terminatorPane' }).addTo(map);
					window.dayNightLayer = dayNightLayer;
					dayNightLayer.setTime(refNow()); // ← sincroniza con la hora de referencia al inicio
				
					// Re-mapea una longitud para que quede "cerca" de una de referencia (evita saltos de 360°)
					function unwrapLon(lon, ref){
						let x = lon;
						while (x - ref > 180)  x -= 360;
						while (x - ref < -180) x += 360;
						return x;
						}
						// Envuelve de vuelta a [-180, 180]
						function wrapLon(lon){
						return ((lon + 180) % 360 + 360) % 360 - 180;
						}
						
						// Cierra cada segmento hacia el sur (edgeLat=-MERC_MAX) o norte (edgeLat=+MERC_MAX)
						// Asegura SIEMPRE los dos vértices inferiores: derecha (lonA) e izquierda (lonB)
						function segmentsToClosedRings(segments, closeToSouth = true){
						const rings = [];
						const edgeLat = closeToSouth ? -MERC_MAX : MERC_MAX;
						
						for (const seg of segments){
							if (!seg || seg.length < 2) continue;
						
							const first = seg[0];
							const last  = seg[seg.length - 1];
						
							// Referencia de "desenvoltura": la longitud del último punto
							const lonRef = last[1];
						
							// Copiamos el segmento "desenvuelto" para que no haya saltos en ±180°
							const unwrapped = seg.map(([la, lo]) => [la, unwrapLon(lo, lonRef)]);
						
							// Calculamos las dos longitudes inferiores "desenvueltas"
							const lonA = unwrapLon(last[1],  lonRef);   // derecha (desde el último)
							const lonB = unwrapLon(first[1], lonA);     // izquierda (con continuidad respecto a lonA)
						
							// Construimos el anillo: línea del terminador → bajar a fondo derecha → fondo izquierda → subir a inicio
							const ring = [
							...unwrapped,
							[edgeLat, lonA],
							[edgeLat, lonB],
							[first[0], lonB],
							].map(([la, lo]) => [la, wrapLon(lo)]);     // volvemos a ±180°
						
							rings.push(ring);
						}
						return rings;
					}
				
					// Línea/máscara del terminador (segmentada en ±180°)
					function buildTerminatorLine(){
						const s = subsolar(refNow());
					
						// Base ortonormal:
						const phi = rad(s.lat), lam = rad(s.lon);
						const cx = Math.cos(phi)*Math.cos(lam), cy = Math.cos(phi)*Math.sin(lam), cz = Math.sin(phi);
						let ax=0, ay=0, az=1; if (Math.abs(cz) > 0.99) { ax=1; ay=0; az=0; }
						let ux = ay*cz - az*cy, uy = az*cx - ax*cz, uz = ax*cy - ay*cx; const un = Math.hypot(ux,uy,uz); ux/=un; uy/=un; uz/=un;
						const vx = cy*uz - cz*uy, vy = cz*ux - cx*uz, vz = cx*uy - cy*ux;
					
						// 1) Línea del terminador (evitar salto ±180°)
						const segments = []; let seg = []; let prevLon = null; const TH = 170;
						for (let t=0; t<=360; t+=0.5){
							const tr = rad(t);
							const x = ux*Math.cos(tr) + vx*Math.sin(tr);
							const y = uy*Math.cos(tr) + vy*Math.sin(tr);
							const z = uz*Math.cos(tr) + vz*Math.sin(tr);
							let lat = deg(Math.asin(z));
							if (lat >  MERC_MAX) lat =  MERC_MAX;
							if (lat < -MERC_MAX) lat = -MERC_MAX;
							let lon = deg(Math.atan2(y, x)); lon = normLon(lon);
					
							if (prevLon !== null){
							if ((prevLon > TH && lon < -TH) || (prevLon < -TH && lon > TH)){
								if (seg.length) segments.push(seg);
								seg = [];
							}
							}
							seg.push([lat, lon]);
							prevLon = lon;
						}
						if (seg.length) segments.push(seg);
					
						// 2) ¿Cerrar al sur o al norte? (noche incluye el polo opuesto al subsolar)
						const closeToSouth = (s.lat >= 0); // sol en norte => noche al sur; sol en sur => noche al norte
						const rings = segmentsToClosedRings(segments, closeToSouth);
					
						// 3) Crear/actualizar la máscara
						const opts = {
							pane: 'terminatorPane',
							weight: 0,                      // sin borde visible (mejor máscara pura)
							color:  'rgba(0,0,0,0)',
							lineCap: 'round',
							lineJoin: 'round',
							fill: true,
							fillColor: '#001133',              // negro para noche (se integra con tiles)
							fillOpacity: 0.60,
							noClip: true,
							smoothFactor: 0,
							className: 'terminator-line',
							interactive: false,             // no bloquea eventos (además el pane tiene pointer-events:none)
							renderer: L.svg({ padding: 0 })
						};
					
						if (!window.ringLine){
							window.ringLine = L.polygon(rings, opts).addTo(map);
							ringLine = window.ringLine; // sincroniza ref. local para el toggle
						} else {
							window.ringLine.setLatLngs(rings);
							window.ringLine.setStyle(opts);
						}
						window.ringLine.bringToFront();
					}
						
					// Pintar ya
					buildTerminatorLine();
					
					// Toggle de ambas capas
					const termChk = document.getElementById('toggleTerminator');
					if (termChk) {
						termChk.addEventListener('change', function () {
							if (this.checked) {
							if (dayNightLayer) dayNightLayer.addTo(map);
							if (ringLine)      ringLine.addTo(map);
						
							// Reponer overlays si están activos y dejarlos AL FRENTE
							if (document.getElementById('toggleRadar')?.checked && rainv?.layer) {
								rainv.layer.addTo(map);
							}
							if (document.getElementById('toggleClouds')?.checked && satv?.layer) {
								satv.layer.addTo(map);
							}
						
							restoreOrder();
							} else {
							if (dayNightLayer) map.removeLayer(dayNightLayer);
							if (ringLine)      map.removeLayer(ringLine);
							}
						
							// ⇩⇩ Persistencia del toggle Día/Noche
							try { localStorage.setItem('sr.t.term', this.checked ? '1' : '0'); } catch (_) {}
						});
					}
				
					const state = { horizonMins:60, sats:{} }; // ahora dinámico (id -> objeto sat)

					// ===== Persistencia en navegador =====
					const STORAGE = {
						key: 'satRasteator.sats.v1',
						save(){
							try{
								const arr = Object.entries(state.sats).map(([id, s])=>({
									id,
									name: s.name,
									l1: s.l1,
									l2: s.l2,
									color: s.color || '#ff3333',
									visible: !!s.visible,
									iconKey: s.iconKey || null,
									iconUrl: s.iconUrl || null
								}));
								localStorage.setItem(this.key, JSON.stringify(arr));
							}catch(_){}
						},
						load(){
							try{
								const raw = localStorage.getItem(this.key);
								if(!raw) return [];
								const arr = JSON.parse(raw);
								return Array.isArray(arr) ? arr : [];
							}catch(_){ return []; }
						}
					};
				
					function toggleSat(id, on){
						const s=state.sats[id]; if (!s) return;
						s.visible=on;
						if(s.marker){ on?map.addLayer(s.marker):map.removeLayer(s.marker); }
						// círculo solo si el toggle global de horizonte está activo
						if(s.circle){
							const showHoriz = isOn(document.getElementById('btnHorizon'));
							if(on && showHoriz){ if(!map.hasLayer(s.circle)) map.addLayer(s.circle); }
							else { if(map.hasLayer(s.circle)) map.removeLayer(s.circle); }
						}
						if(s.track){  on?map.addLayer(s.track):map.removeLayer(s.track); }
						STORAGE.save();
					}
				
					// === Ubicarme como toggle (punto azul + precisión) ===
					let meLayer=null, meMarker=null, meAcc=null;
					const locBtn = document.getElementById('locateMe');
					function applyLocate(on){
						setBtn(locBtn, on);
						if (!on){
							if (meLayer) { try{ map.removeLayer(meLayer); }catch(_){ } meLayer=null; meMarker=null; meAcc=null; }
							return;
						}
						if(!navigator.geolocation){ alert('Geolocalización no soportada'); setBtn(locBtn,false); return; }
						navigator.geolocation.getCurrentPosition(function(pos){
							const lat=pos.coords.latitude, lon=pos.coords.longitude, acc=pos.coords.accuracy||0;
							const dotIcon = L.divIcon({ className:'me-dot', iconSize:[14,14], iconAnchor:[7,7] });
							if (!meLayer){
								meMarker = L.marker([lat,lon], { icon: dotIcon, interactive:false, pane:'satPane' });
								meAcc    = L.circle([lat,lon], { radius: acc, color:'#2a7bff', fillColor:'#2a7bff', weight:1, opacity:.4, fillOpacity:.15, pane:'orbitPane' });
								meLayer  = L.layerGroup([meAcc, meMarker]).addTo(map);
							} else {
								meMarker.setIcon(dotIcon).setLatLng([lat,lon]);
								meAcc.setLatLng([lat,lon]).setRadius(acc);
								if (!map.hasLayer(meLayer)) meLayer.addTo(map);
							}
							map.flyTo([lat,lon], Math.max(map.getZoom(), 7), {duration:1.0, easeLinearity:0.25, animate:true}); 						
						}, function(){ alert('No se pudo obtener ubicación'); setBtn(locBtn,false); });
					}
					locBtn?.addEventListener('click', ()=> applyLocate(!isOn(locBtn)));
										
					// === Bajo consumo (botón + auto cuando la pestaña está oculta) ===
					const lowBtn = document.getElementById('btnLowPower');
					function applyLow(on){
						setBtn(lowBtn, on);
						try{ localStorage.setItem('sr.t.low', on?'1':'0'); }catch(_){}
						// no reiniciamos timers: el propio tick hace throttle
					}
					lowBtn?.addEventListener('click', ()=> applyLow(!isOn(lowBtn)));
					document.addEventListener('visibilitychange', ()=>{ /* el tick lee document.hidden */ });
				
					document.getElementById('trackHorizon').addEventListener('change', function(e){
						state.horizonMins=parseInt(e.target.value,10)||0; computeAllTracks();
						try{ localStorage.setItem('sr.horizon', String(state.horizonMins)); }catch(_){}
					});
				
					const now = () => refNow();
					function toLLA(satrec, date){
						const pv = satellite.propagate(satrec, date);
						if(!pv.position||!pv.velocity) return null;
						const gmst = satellite.gstime(date);
						const gd = satellite.eciToGeodetic(pv.position, gmst);
						const lat = satellite.degreesLat(gd.latitude);
						const lon = satellite.degreesLong(gd.longitude);
						const altKm = gd.height;
						const v = pv.velocity; const speedKms = Math.hypot(v.x,v.y,v.z);
						return { lat, lon, altKm, speedKmh:speedKms*3600 };
					}
					
					// Radio de huella (arco sobre la superficie) ~ Re * acos(Re/(Re+h))
					function footprintRadiusMeters(altKm){
						const Re = 6371;                       // km
						const psi = Math.acos(Re / (Re + Math.max(altKm, 0.001)));
						return Re * psi * 1000;                // → metros
					}
					
					// Precarga de un icono local para evitar parpadeos
					(new Image()).src = 'img/satellite-rasteator/icons/32/sat1.png';

					// === Iconos locales (32/64 px) y fábrica de iconos ===
					const ICON_BASE = 'img/satellite-rasteator/icons';
					const ICON_FILES = {
						sat1: 'sat1.png',
						sat2: 'sat2.png',
						sat3: 'sat3.png',
						sat4: 'sat4.png',
						sat5: 'sat5.png',
						sat6: 'sat6.png',
						sat7: 'sat7.png',
						/*sat8: 'sat8.png',
						sat9: 'sat9.png',*/
						iss : 'iss.png'
					};
					function iconPath(key, size=32){
						const file = ICON_FILES[key] || ICON_FILES.sat1;
						return `${ICON_BASE}/${size}/${file}`;
					}
					// Acepta una clave (sat1…iss) o una URL absoluta/data:
					function makeIcon(keyOrUrl = 'sat1'){
						const isUrl = /^(https?:|data:|\/)/i.test(keyOrUrl);
						const file  = ICON_FILES[keyOrUrl] || ICON_FILES.sat1;
						const x1 = isUrl ? keyOrUrl : `${ICON_BASE}/32/${file}`;
						const x2 = isUrl ? keyOrUrl : `${ICON_BASE}/64/${file}`;
						return L.icon({
							iconUrl: x1,
							iconRetinaUrl: x2,
							iconSize: [32,32],
							iconAnchor: [16,16],
							popupAnchor: [0,-16],
							className: 'satellite-icon'
						});
					}
					
					// === Picker de TLE ===
					function tleChecksumOk(line){
						// Checksum TLE: suma dígitos + ( - cuenta como 1 ) mod 10 debe igualar último char
						if(!line || line.length < 69) return false;
						const csChar = line.trim().slice(-1);
						if(!/^[0-9]$/.test(csChar)) return false;
						const head = line.slice(0, 68);
						let s = 0;
						for (let i=0;i<head.length;i++){
							const ch = head[i];
							if (ch >= '0' && ch <= '9') s += ch.charCodeAt(0) - 48;
							else if (ch === '-') s += 1;
						}
						return (s % 10) === parseInt(csChar,10);
					}
					function openTlePicker(anchorBtn, l1Current='', l2Current='', onSave){
						// Cierra cualquier otro popover
						document.querySelectorAll('.tle-picker,.icon-picker').forEach(el=>el.remove());
						const pop = document.createElement('div');
						pop.className = 'tle-picker';
						pop.innerHTML = `
							<h4>Modificar TLE</h4>
							<textarea class="tle-area" placeholder="Pega aquí las 2 líneas (empiezan por 1 y 2)"></textarea>
							<div class="meta">
								<span class="pill len">—</span>
								<span class="pill chk1">L1: —</span>
								<span class="pill chk2">L2: —</span>
								<span class="pill status">Estado: esperando…</span>
							</div>
							<div class="actions">
								<button class="btn close-btn">Cancelar</button>
								<button class="btn save-btn" disabled>Guardar</button>
							</div>
						`;
						const area  = pop.querySelector('.tle-area');
						const lenEl = pop.querySelector('.len');
						const c1El  = pop.querySelector('.chk1');
						const c2El  = pop.querySelector('.chk2');
						const stEl  = pop.querySelector('.status');
						const btnSave = pop.querySelector('.save-btn');
						const btnClose= pop.querySelector('.close-btn');
						area.value = (l1Current ? (l1Current+'\n') : '') + (l2Current||'');
						function validate(){
							const raw = area.value.trim();
							const parsed = parseTLEBlock(raw) || {};
							const l1 = parsed.l1 || ''; const l2 = parsed.l2 || '';
							const l1ok = /^1\s/.test(l1) && l1.length>=60 && tleChecksumOk(l1);
							const l2ok = /^2\s/.test(l2) && l2.length>=60 && tleChecksumOk(l2);
							lenEl.textContent = `${raw.length} chars`;
							c1El.textContent  = `L1: ${l1ok?'OK':'X'}`; c1El.className = `pill ${l1ok?'ok':'bad'}`;
							c2El.textContent  = `L2: ${l2ok?'OK':'X'}`; c2El.className = `pill ${l2ok?'ok':'bad'}`;
							const ok = !!(l1 && l2 && l1ok && l2ok);
							btnSave.disabled = !ok;
							stEl.textContent = ok ? 'Estado: válido' : 'Estado: incompleto o inválido';
							return ok ? {l1,l2} : null;
						}
						area.addEventListener('input', validate);
						setTimeout(()=>{ area.focus(); area.setSelectionRange(area.value.length, area.value.length); validate(); }, 0);
						document.body.appendChild(pop);
						// Posicionar junto al botón
						const r = anchorBtn.getBoundingClientRect(), m=6;
						let left = Math.min(window.innerWidth - pop.offsetWidth - 8, Math.max(8, r.left));
						let top  = r.bottom + m; if (top + pop.offsetHeight + 8 > window.innerHeight) top = r.top - pop.offsetHeight - m;
						pop.style.left = `${left}px`; pop.style.top = `${top}px`;
						// Cerrar fuera / ESC
						const onDoc = (e)=>{ if(!pop.contains(e.target) && e.target!==anchorBtn){ pop.remove(); document.removeEventListener('mousedown',onDoc); } };
						document.addEventListener('mousedown', onDoc);
						window.addEventListener('keydown', function onEsc(ev){ if(ev.key==='Escape'){ pop.remove(); document.removeEventListener('mousedown',onDoc); window.removeEventListener('keydown', onEsc); }});
						btnClose.addEventListener('click', ()=>{ pop.remove(); document.removeEventListener('mousedown',onDoc); });
						btnSave.addEventListener('click', ()=>{
							const ok = validate();
							if(!ok) return;
							onSave(ok.l1, ok.l2);
							pop.remove(); document.removeEventListener('mousedown',onDoc);
						});
					}
					
					// === Popover genérico de selección de icono ===
					function openIconPicker(anchorBtn, currentKey, onChoose){
						// Cerrar si ya hay uno
						let existing = document.querySelector('.icon-picker');
						if (existing) existing.remove();
						const pop = document.createElement('div');
						pop.className = 'icon-picker';
						pop.innerHTML = `
							<h4>Elige un icono</h4>
							<div class="icon-grid"></div>
							<div class="close-row"><button class="close-btn">Cerrar</button></div>
						`;
						const grid = pop.querySelector('.icon-grid');
						const keys = Object.keys(ICON_FILES);
						keys.forEach(k=>{
							const it = document.createElement('button');
							it.type = 'button';
							it.className = 'icon-item';
							it.setAttribute('aria-selected', String(k===currentKey));
							it.innerHTML = `<img alt="${k}" src="${iconPath(k,32)}">`;
							it.addEventListener('click', ()=>{
								onChoose(k);
								pop.remove();
							});
							grid.appendChild(it);
						});
						document.body.appendChild(pop);
						// Posicionar junto al botón
						const r = anchorBtn.getBoundingClientRect();
						const margin = 6;
						let left = Math.min(window.innerWidth - pop.offsetWidth - 8, Math.max(8, r.left));
						let top  = r.bottom + margin;
						// si se sale por abajo, colócalo arriba
						if (top + 280 > window.innerHeight) top = r.top - pop.offsetHeight - margin;
						pop.style.left = `${left}px`;
						pop.style.top  = `${top}px`;
						// Cerrar fuera / ESC
						const onDoc = (e)=>{ if(!pop.contains(e.target) && e.target!==anchorBtn){ pop.remove(); document.removeEventListener('mousedown',onDoc); } };
						document.addEventListener('mousedown', onDoc);
						pop.querySelector('.close-btn').addEventListener('click', ()=>{ pop.remove(); document.removeEventListener('mousedown',onDoc); });
						window.addEventListener('keydown', function onEsc(ev){ if(ev.key==='Escape'){ pop.remove(); document.removeEventListener('mousedown',onDoc); window.removeEventListener('keydown', onEsc); }});
					}
					function setIconButtonVisual(btn, keyOrUrl){
						// Si es URL externa/data, úsala tal cual; si es clave, usa 32px local
						const isUrl = /^(https?:|data:|\/)/i.test(keyOrUrl);
						const src = isUrl ? keyOrUrl : iconPath(keyOrUrl||'sat1', 32);
						btn.innerHTML = `<img alt="icon" src="${src}" style="width:20px;height:20px;pointer-events:none">`;
					}
					
					// DEBUG: icono de prueba en (0,0). Quitar luego.
					//L.marker([0,0], { icon: satIcon, pane: 'satPane', title: 'TEST' }).addTo(map);
				
					function updateSat(id){
						const s = state.sats[id]; if(!s || !s.satrec) return;
						const p=toLLA(s.satrec, now()); if(!p) return;
						if(!s.marker){
							const keyOrUrl = s.iconUrl || s.iconKey || 'sat1';
							s.marker = L.marker([p.lat, p.lon], {
								title: s.name,
								icon: makeIcon(keyOrUrl),
								pane: 'satPane'
							}).addTo(map).bindPopup('<b>'+s.name+'</b>');
						} else {
							// ¡No recrear! solo mover el marker existente
							s.marker.setLatLng([p.lat, p.lon]);
						}
						
						const radius = typeof footprintRadiusMeters === 'function'
							? footprintRadiusMeters(p.altKm)
							: 145000; // fallback si no integraste la función de radio dinámico
						if(!s.circle){
							// 2) footprint/área en pane de ÓRBITAS (no añadir aún al mapa)
							s.circle = L.circle([p.lat, p.lon], {
								pane: 'orbitPane',
								radius,
								color: s.color || '#ff3333',
								fillColor: s.color || '#ff3333',
								weight: 1,
								opacity: 0.9,
								fillOpacity: 0.12
							});
						} else {
							s.circle.setLatLng([p.lat,p.lon]);
							// por si cambia la altitud o integras radio dinámico
							if (typeof s.circle.setRadius === 'function') s.circle.setRadius(radius);
						}
						
						// mostrar/ocultar según toggle global + visibilidad del satélite
						const showHoriz = isOn(document.getElementById('btnHorizon'));
						if (s.circle){
							if (showHoriz && s.visible !== false){
								if (!map.hasLayer(s.circle)) s.circle.addTo(map);
							} else {
								if (map.hasLayer(s.circle)) map.removeLayer(s.circle);
							}
						}
						
						// === Datos orbitales visibles en la fila ===
						const okv = document.getElementById('okv-'+id);
						if (okv){
							// i (deg), e, periodo (min), alt (km), v (km/s aprox.)
							const inclDeg = (s.satrec && typeof s.satrec.inclo==='number') ? (s.satrec.inclo*180/Math.PI) : NaN;
							const ecc     = (s.satrec && typeof s.satrec.ecco==='number') ? s.satrec.ecco : NaN;
							const revPerDay = (s.satrec && typeof s.satrec.no==='number') ? (s.satrec.no * 1440/(2*Math.PI)) : NaN;
							const periodMin = isFinite(revPerDay) && revPerDay>0 ? (1440/revPerDay) : NaN;
							const altKm  = isFinite(p.altKm) ? p.altKm : NaN;
							const Re     = 6371; const mu = 398600.4418; // Tierra
							const rKm    = isFinite(altKm) ? (Re + altKm) : NaN;
							const vKms   = isFinite(rKm) ? Math.sqrt(mu / rKm) : NaN; // circular aprox.
							const f = (x,n=2)=> (isFinite(x)? x.toFixed(n) : '—');
							const f3 = (x)=> (isFinite(x)? x.toFixed(3) : '—');
							okv.innerHTML = `
								<span class="chip">Lat: ${f3(p.lat)}°</span>
								<span class="chip">Lon: ${f3(p.lon)}°</span>
								<span class="chip">Incl: ${f(inclDeg,2)}°</span>
								<span class="chip">Exc: ${f(ecc,4)}</span>
								<span class="chip">Per: ${f(periodMin,1)} min</span>
								<span class="chip">Alt: ${f(altKm,0)} km</span>
								<span class="chip">Vel: ${f(vKms,2)} km/s</span>
							`;
						}
						
					}
				
					function computeTrack(id){
						const s=state.sats[id];
						if(!s.satrec || state.horizonMins<=0){ if(s.track){ map.removeLayer(s.track); s.track=null; } return; }
						const step=30; // 30s
						const total=state.horizonMins*60;
						const pts=[]; const start = refNow();
						for(let t=0; t<=total; t+=step){
							const d=new Date(start.getTime()+t*1000);
							const p=toLLA(s.satrec, d);
							if(p) pts.push([p.lat,p.lon]);
						}
						if(!s.track){
							s.track=L.polyline(pts,{
								pane:'orbitPane',
								color: s.color || '#ff3333',
								weight:1.2, opacity:.9
							}).addTo(map);
						} else {
							s.track.setLatLngs(pts);
							// aplica color si cambió
							s.track.setStyle({ color: s.color || '#ff3333' });
						}
					}
				
					function computeAllTracks(){
						for (const id in state.sats){ computeTrack(id); }
					}

					// === Bucle de renderizado: suave al reproducir, eficiente en reposo ===
					// Cadencias base (ms entre renders)
					const NORMAL_MS = 250, LOW_MS = 1000, HIDDEN_MS = 4000;
					const OVERLAY_MS_FAST = 600, OVERLAY_MS_SLOW = 3000; // actualización de overlays (día/noche, radar, nubes)
					let lastTickTs = 0, lastOverlayTs = 0;
					// Flag opcional para control externo (p.ej. scrubber): window.__scrubPlaying = true/false
					function tick(){
						const playing = (window.__scrubPlaying === true);
						const wantMs = playing ? 0 : (document.hidden ? HIDDEN_MS : (isOn(document.getElementById('btnLowPower')) ? LOW_MS : NORMAL_MS));
						const nowTs = performance.now();
						if (nowTs - lastTickTs < wantMs) return; // throttling
						lastTickTs = nowTs;
						// 1) Propaga y pinta TODOS los sats con el mismo tiempo de referencia
						for (const id in state.sats){ updateSat(id); }
						// 2) Sigue el satélite activo sin alterar el nivel de zoom
						if (followId && state.sats[followId] && state.sats[followId].marker){
							const ll = state.sats[followId].marker.getLatLng();
							map.setView(ll, map.getZoom(), { animate:false });
						}
						// 3) Sincroniza overlays al ritmo adecuado
						const overlayGap = playing ? OVERLAY_MS_FAST : OVERLAY_MS_SLOW;
						if (nowTs - lastOverlayTs >= overlayGap){
							if (window.dayNightLayer) window.dayNightLayer.setTime(refNow());
							// radar/nubes sólo si sus toggles están activos
							if (document.getElementById('btnRadar')?.classList.contains('active'))  updateRadar();
							if (document.getElementById('btnClouds')?.classList.contains('active')) updateSatRV();
							lastOverlayTs = nowTs;
						}
					}
				
					document.getElementById('status').textContent='TLE: esperando (usa el panel para pegarlas)';

					// ====== Gestión dinámica de satélites (refs DOM) — mover arriba para evitar TDZ ======
					const satListEl   = document.getElementById('satList');
					const addBtn      = document.getElementById('addSatBtn');
					const nameInp     = document.getElementById('satName');
					const tleBlockInp = document.getElementById('tleBlock');
					const defColInp   = document.getElementById('defaultOrbitColor');
					const newIconBtn  = document.getElementById('newIconBtn');
					const satFilterInp= document.getElementById('satFilter');
					// UI estado validación al añadir
					const addLenEl    = document.getElementById('addLen');
					const addL1El     = document.getElementById('addL1');
					const addL2El     = document.getElementById('addL2');
					const addStateEl  = document.getElementById('addState');
					let newSatIconKey = (localStorage.getItem('sr.newIcon') || 'sat1');
					let followId = null; // id del satélite en modo “seguir”

					// === Guardar vista del mapa (centro/zoom)
					map.on('moveend zoomend', ()=>{
						try{
							const c = map.getCenter();
							localStorage.setItem('sr.mapView', JSON.stringify({ center:[c.lat, c.lng], zoom: map.getZoom() }));
						}catch(_){}
					});

					// === Restaurar estado de UI
					function restoreUI(){
						try{
							// Base
							const savedBase = localStorage.getItem('sr.base');
							if (savedBase){
								const sel = document.getElementById('baseSel');
								if (sel) sel.value = savedBase;
								const nextBase = (savedBase==='light'?baseLight : savedBase==='dark'?baseDark : savedBase==='sat'?baseSat : baseOSM);
								if (currentBase && map.hasLayer(currentBase)) map.removeLayer(currentBase);
								nextBase.addTo(map); currentBase = nextBase;
							}
							// Vista
							const mv = JSON.parse(localStorage.getItem('sr.mapView')||'null');
							if (mv && Array.isArray(mv.center) && typeof mv.zoom==='number'){
								map.setView(mv.center, mv.zoom, {animate:false});
							}
							// Horizonte traza
							const h = localStorage.getItem('sr.horizon');
							if (h){
								state.horizonMins = parseInt(h,10)||0;
								const selH = document.getElementById('trackHorizon');
								if (selH) selH.value = String(state.horizonMins);
								computeAllTracks();
							}
							// Restaurar estado de botones desde localStorage
							applyTerm(   (localStorage.getItem('sr.t.term')   ?? '1') === '1' );
							applyRadar(  (localStorage.getItem('sr.t.radar')  ?? '1') === '1' );
							applyClouds( (localStorage.getItem('sr.t.clouds') ?? '1') === '1' );
							applyHorizon((localStorage.getItem('sr.t.horiz')  ?? '1') === '1' );
							applyLow((localStorage.getItem('sr.t.low')   ?? '0') === '1' );
						}catch(_){}
					}

					// Restaurar UI y luego satélites guardados
					restoreUI();	

					// Icono por defecto para nuevos satélites (UI)
					if (newIconBtn){
						setIconButtonVisual(newIconBtn, newSatIconKey);
						newIconBtn.addEventListener('click', ()=>{
							openIconPicker(newIconBtn, newSatIconKey, (k)=>{
								newSatIconKey = k;
								setIconButtonVisual(newIconBtn, newSatIconKey);
								try{ localStorage.setItem('sr.newIcon', newSatIconKey); }catch(_){}
							});
						});
					}					
					
					// Restaurar satélites guardados
					(function restoreSaved(){
						const saved = STORAGE.load();
						if (saved.length){
							for (const it of saved){
								const {id, name, l1, l2, color, visible, iconKey, iconUrl} = it || {};
 								if (name && l1 && l2){
									addSatellite({ id, name, l1, l2, color, visible, iconKey, iconUrl });
 								}
							}
							const st = document.getElementById('status');
							if (st) st.textContent = `TLE: cargado (${Object.keys(state.sats).length} satélites)`;
						}
					})();
					
					tick(); computeAllTracks();
					// Bucle continuo (requestAnimationFrame): tick decide si renderizar o saltar frame
					(function animate(){ tick(); requestAnimationFrame(animate); })();

					function parseTwoline(l1, l2){
						try{ return satellite.twoline2satrec(l1.trim(), l2.trim()); }catch(_){ return null; }
					}
					
					function parseTLEBlock(txt){
						if (!txt) return null;
						const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
						// Buscar la primera línea que empiece por "1 " y la primera que empiece por "2 "
						let l1 = lines.find(l => /^1\s/.test(l));
						let l2 = lines.find(l => /^2\s/.test(l));
						// Por si el usuario pegó más de dos líneas, tomar la siguiente "2 " tras la "1 "
						if (!l2 && l1){
							const i1 = lines.indexOf(l1);
							l2 = lines.slice(i1+1).find(l => /^2\s/.test(l));
						}
						return (l1 && l2) ? { l1, l2 } : null;
					}

					function uidFromName(name){
						const base = name.trim().toUpperCase().replace(/[^A-Z0-9]+/g,'-').replace(/^-+|-+$/g,'') || 'SAT';
						return base + '-' + Date.now().toString(36);
					}

					function createSatRow(id, s){
						const row = document.createElement('div');
						row.className = 'sat-item';
						row.id = 'row-'+id;
						row.innerHTML = `
							<input type="checkbox" id="chk-${id}" ${s.visible?'checked':''} />
							<div style="min-width:0">
								<div><b class="sat-name" data-id="${id}" title="Editar nombre (clic)">${s.name}</b></div>
								<!-- Línea única con datos dinámicos (incluye lat/lon) -->
								<div class="okv" id="okv-${id}"></div>
							</div>
							<div class="sat-actions actions-col">
								<button class="zoomSat btn-icon" data-id="${id}" title="Zoom/Seguir">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5Zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14Z"/></svg>
								</button>
								<button class="iconBtn btn-icon" data-id="${id}" title="Elegir icono"></button>
								<button class="colorBtn btn-color" data-id="${id}" title="Cambiar color de órbita"></button>
								<button class="editTLE btn-icon" data-id="${id}" title="Modificar TLE">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25ZM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
								</button>
								<button class="delSat btn-icon btn-danger" data-id="${id}" title="Eliminar satélite">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 7h12v2H6V7Zm2 3h8l-1 9H9L8 10Zm3-6h2v2h-2V4Z"/></svg>
								</button>
								<input type="color" class="colorPicker" id="col-${id}" value="${s.color || '#ff3333'}" style="position:absolute;opacity:0;pointer-events:none;width:0;height:0" />
							</div>
						`;
						satListEl.appendChild(row);

						// eventos
						row.querySelector('#chk-'+id).addEventListener('change', e=>{
							toggleSat(id, e.target.checked);
						});
						
						// Zoom (manteniendo nivel) + seguir / desenganchar sin mover
						const zoomBtn = row.querySelector('.zoomSat');
						function refreshZoomFollow(){
							if (followId === id){ zoomBtn.classList.add('active'); zoomBtn.title = 'Dejar de seguir'; }
							else { zoomBtn.classList.remove('active'); zoomBtn.title = 'Zoom/Seguir'; }
						}
						refreshZoomFollow();
						zoomBtn.addEventListener('click', ()=>{
							const sat = state.sats[id];
							if(!sat || !sat.marker) return;
							// Si ya seguimos este satélite → desenganchar y no mover el mapa
							if (followId === id){
								followId = null;
								refreshZoomFollow();
								return;
							}
							// Si seguimos a otro o a ninguno → viajar al satélite conservando el zoom actual y empezar a seguir
							const currentZoom = map.getZoom();
							map.flyTo(sat.marker.getLatLng(), currentZoom, { duration:1.2, easeLinearity:0.25, animate:true });
							followId = id;
							// actualizar estilos en todos los botones
							document.querySelectorAll('.zoomSat').forEach(b=>b.classList.remove('active'));
							refreshZoomFollow();
						});
						
						const colorBtn = row.querySelector('.colorBtn');
						const colorInp = row.querySelector('#col-'+id);
						// color inicial del chip (asegurado por JS)
						colorBtn.style.setProperty('--col', s.color || '#ff3333');
						colorBtn.addEventListener('click', ()=> colorInp.click());
						colorInp.addEventListener('input', (e)=>{
							const c = e.target.value;
							const sat = state.sats[id];
							sat.color = c;
							if (sat.track)  sat.track.setStyle({ color:c });
							if (sat.circle) sat.circle.setStyle({ color:c, fillColor:c });
							// actualizar chip visual del botón
							colorBtn.style.setProperty('--col', c);
							STORAGE.save();
						});
						
						// elegir icono (presets: sat/dot/tri o URL)
						// Botón de icono: muestra miniatura actual y abre picker
						const iconBtn = row.querySelector('.iconBtn');
						setIconButtonVisual(iconBtn, s.iconUrl || s.iconKey || 'sat1');
						iconBtn.addEventListener('click', ()=>{
							const sat = state.sats[id];
							openIconPicker(iconBtn, sat.iconKey || 'sat1', (k)=>{
								sat.iconKey = k; sat.iconUrl = null;
								setIconButtonVisual(iconBtn, k);
								if (sat.marker) sat.marker.setIcon(makeIcon(k));
								STORAGE.save();
							});
						});
						
						// botón editar TLE → abre picker popover
						const editBtn = row.querySelector('.editTLE');
						editBtn.addEventListener('click', ()=>{
							const sat = state.sats[id];
							openTlePicker(editBtn, sat.l1, sat.l2, (newL1, newL2)=>{
								sat.l1 = newL1; sat.l2 = newL2;
								try{ sat.satrec = parseTwoline(newL1, newL2); }catch(e){ console.warn('parseTwoline error', e); }
								STORAGE.save();
							});
						});
						
						// eliminar satélite
						row.querySelector('.delSat').addEventListener('click', ()=>{
							removeSatellite(id);
						});
						
						// nombre editable al clic
						const nameEl = row.querySelector('.sat-name');
						nameEl.addEventListener('click', ()=>{
							nameEl.setAttribute('contenteditable','true');
							const sel = window.getSelection(); const r = document.createRange();
							r.selectNodeContents(nameEl); sel.removeAllRanges(); sel.addRange(r);
							nameEl.focus();
						});
						nameEl.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ ev.preventDefault(); nameEl.blur(); }});
						nameEl.addEventListener('blur', ()=>{
							nameEl.removeAttribute('contenteditable');
							const newName = nameEl.textContent.trim() || s.name;
							s.name = newName;
							if (s.marker && s.marker.getPopup()) s.marker.getPopup().setContent('<b>'+s.name+'</b>');
							else if (s.marker) s.marker.bindPopup('<b>'+s.name+'</b>');
							STORAGE.save();
						});
					}

					function addSatellite({id, name, l1, l2, color, visible, iconKey, iconUrl}){
 						const satrec = parseTwoline(l1, l2);
						if(!satrec){ alert('TLE inválido'); return; }
						const _id = id || uidFromName(name);
						if (state.sats[_id]) { /* evita duplicados si ya existiera */ return; }
						state.sats[_id] = {
							name, l1, l2, satrec,
							color: color || '#ff3333',
							iconKey: iconKey || newSatIconKey || 'sat1',
							iconUrl: iconUrl || null,
							marker:null, circle:null, track:null,
							visible: (visible === false ? false : true)
						};
						createSatRow(_id, state.sats[_id]);
						// fuerza primer tick/track
						updateSat(_id);
						computeTrack(_id);
						// respetar visibilidad restaurada
						if (visible === false) toggleSat(_id, false);
						// UI feedback
						const st = document.getElementById('status');
						if (st) st.textContent = `TLE: cargado (${Object.keys(state.sats).length} satélites)`;
						// guardar
						STORAGE.save();
					}
					
					function removeSatellite(id){
						const s = state.sats[id];
						if(!s) return;
						// elimina capas del mapa
						if (s.marker) { try{ map.removeLayer(s.marker); }catch(_){} }
						if (s.circle) { try{ map.removeLayer(s.circle); }catch(_){} }
						if (s.track)  { try{ map.removeLayer(s.track);  }catch(_){} }
						// borra del estado
						delete state.sats[id];
						// si se estaba siguiendo, cancelar seguimiento
						if (followId === id) followId = null;
						// borra la fila
						const row = document.getElementById('row-'+id);
						if (row && row.parentNode) row.parentNode.removeChild(row);
						// feedback de estado
						const st = document.getElementById('status');
						const n  = Object.keys(state.sats).length;
						if (st) st.textContent = n ? `TLE: cargado (${n} satélites)` : 'TLE: esperando…';
						// guardar
						STORAGE.save();
					}

					if(addBtn){
						addBtn.addEventListener('click', ()=>{
							const name  = (nameInp.value || '').trim();
							const color = defColInp.value || '#ff3333';
							const parsed = parseTLEBlock(tleBlockInp.value || '');
							if (!name || !parsed){
								alert('Indica un nombre y pega un TLE válido (2 líneas que empiecen por 1 y 2).');
								return;
							}
							addSatellite({ name, l1: parsed.l1, l2: parsed.l2, color, iconKey: newSatIconKey });
							// limpia y cierra
							nameInp.value = ''; tleBlockInp.value = '';
							try{ document.getElementById('addSatPanel').open = false; }catch(_){}
						});
						// validación en vivo del TLE para el botón Añadir
						function validateAddTLE(){
							const raw = (tleBlockInp.value||'').trim();
							const parsed = parseTLEBlock(raw) || {};
							const l1 = parsed.l1||''; const l2 = parsed.l2||'';
							const l1ok = /^1\s/.test(l1) && l1.length>=60 && tleChecksumOk(l1);
							const l2ok = /^2\s/.test(l2) && l2.length>=60 && tleChecksumOk(l2);
							if (addLenEl) addLenEl.textContent = `${raw.length} chars`;
							if (addL1El)  addL1El.textContent  = `L1: ${l1ok?'OK':'X'}`;
							if (addL2El)  addL2El.textContent  = `L2: ${l2ok?'OK':'X'}`;
							if (addStateEl) addStateEl.textContent = (l1ok&&l2ok) ? 'Estado: válido' : 'Estado: incompleto o inválido';
							addBtn.disabled = !(l1ok && l2ok && (nameInp.value||'').trim());
						}
						tleBlockInp.addEventListener('input', validateAddTLE);
						nameInp.addEventListener('input', validateAddTLE);
						// primera pasada
						validateAddTLE();
					}
					
					// Filtro por nombre
					if (satFilterInp){
						satFilterInp.addEventListener('input', ()=>{
							const q = satFilterInp.value.trim().toLowerCase();
							for (const id in state.sats){
								const s = state.sats[id];
								const row = document.getElementById('row-'+id);
								if (!row) continue;
								const show = !q || (s.name||'').toLowerCase().includes(q);
								row.style.display = show ? '' : 'none';
							}
						});
					}
					
					// === HEARTBEAT global (1/min) ===
					const HEARTBEAT_MS = 60000;
					function heartbeat(){
						if (window.dayNightLayer) window.dayNightLayer.setTime(refNow());
						if (typeof buildTerminatorLine === 'function') buildTerminatorLine();
						if (typeof computeAllTracks === 'function') computeAllTracks();
						updateRadar();
						updateSatRV();
					}
					setInterval(heartbeat, HEARTBEAT_MS);

					// Si estamos en "Ahora", refresca el input visible cada segundo para que "corra" el reloj
					setInterval(()=>{
						if (!timeState.manual && refInput){
							refInput.value = toLocalDTValue(new Date());
						}
					// Actualiza el reloj UTC global cada segundo
					updateUTCStatus();
					}, 1000);
					
				});
			})();
		</script>
		<script>
		  // API opcional para scrubbers externos:
		  window.simTime = {
			set: (date)=>{ timeState.manual = true; timeState.value = new Date(date); /* no tocamos aquí; animate() llamará tick() */ },
			play: (on)=>{ window.__scrubPlaying = !!on; }
		  };
		</script>
	</body>
</html>
