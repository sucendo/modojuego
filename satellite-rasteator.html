<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Satellite Rasteator</title>
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
		<style>
			:root{ --bg:#0b1020; --panel:#121832; --text:#e6eef8; }
			/* Colores del scroll (puedes personalizarlos) */
			:root{
				--scroll-track: #0e1540;
				--scroll-thumb: #2a3a6b;
				--scroll-thumb-hover: #4a68c9;
				--scroll-corner: #0b1020;
			}
			html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; overflow-x:hidden} 
			#app{display:grid; grid-template-rows:auto 1fr; height:100%}
			header{display:flex; gap:1rem; align-items:center; padding:.6rem 1rem; background:#0b1020; border-bottom:1px solid #1f284a}
			header h1{font-size:1.05rem; margin:0}
			header .actions{margin-left:auto; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap} /* wrap en tablet */
			header button, header select{background:#11173a; color:var(--text); border:1px solid #26315c; padding:.45rem .7rem; border-radius:.5rem; cursor:pointer}
			#map{height:100%;}			
			.panel{
				position:absolute; top:60px; right:5px; bottom:25px; /* ← anclado arriba y abajo */
				width:300px; box-sizing: border-box;
				display:flex; flex-direction:column; /* ← layout en columna */
				background:var(--panel); border:1px solid #26315c; border-radius:12px;
				padding:.75rem; box-shadow:0 10px 30px rgba(0,0,0,.35); z-index:1000;
				transition:transform .25s ease, opacity .2s ease; will-change:transform, opacity;
				overflow:hidden; /* ← nada se desborda fuera del panel */
			}
			.panel h2{margin:.2rem 0 .6rem; font-size:1rem}
			
			.sat-item{
				display:grid;
				grid-template-columns:auto 1fr;   /* checkbox | info */
				grid-template-rows:auto auto;     /* info arriba, acciones debajo */
				gap:.5rem;
				align-items:center;
				padding:.45rem .5rem;
				border-radius:.6rem; border:1px solid #223059; margin-bottom:.45rem;
			}
			/* bloque de acciones debajo, a lo ancho (horizontal) */
			.sat-actions{
				grid-column: 1 / -1;
				display: flex;
				flex-direction: row;      /* ← horizontal */
				align-items: center;
				gap: .4rem;
				flex-wrap: wrap;          /* si no caben, saltan de línea */
				width: 100%;
				margin-top: .25rem;
			}
			
			/* alias por compatibilidad: forzamos horizontal, por si otra regla pisa */
			.sat-item .actions-col{ display:flex; flex-direction:row !important; align-items:center; gap:.4rem; flex-wrap:wrap }

			/* === Scroll interno solo en la lista === */
			#satList{
				flex:1 1 auto;             /* ocupa todo el espacio disponible */
				overflow:auto;              /* ← scroll aquí */
				overscroll-behavior:contain;
				margin-top:.4rem;
				/* Reserva siempre el canal del scrollbar para que no “salte” el layout */
				scrollbar-gutter: stable both-edges;
			}
			/* El bloque de “Añadir satélite” queda fijo al pie y nunca empuja el panel fuera */
			#addSatPanel{
				flex:0 0 auto;              /* altura natural; no crece */
				margin-top:.5rem;
				max-height:42vh;            /* por si lo abres, que no coma toda la columna */
				overflow:auto;              /* si hiciera falta, scrollea solo su contenido */
				scrollbar-gutter: stable;
			}
			#addSatPanel textarea{
				max-height:28vh;            /* evita que el textarea se haga enorme */
			}
			/* ===== Firefox: estilo de scroll ===== */
			#satList,
			#addSatPanel{
				scrollbar-width: thin; /* auto | thin | none */
				scrollbar-color: var(--scroll-thumb) transparent; /* pulgar | pista */
			}
			
			/* ===== Chromium / WebKit: estilo de scroll ===== */
			#satList::-webkit-scrollbar,
			#addSatPanel::-webkit-scrollbar{
				width: 10px;
				height: 10px;
			}
			#satList::-webkit-scrollbar-track,
			#addSatPanel::-webkit-scrollbar-track{
				background:
					linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.12) 100%),
					var(--panel);
				border-radius: 8px;
				margin: 4px; /* deja respirar el canal al principio/fin */
			}
			#satList::-webkit-scrollbar-thumb,
			#addSatPanel::-webkit-scrollbar-thumb{
				background-color: var(--scroll-thumb);
				border-radius: 8px;
				border: 2px solid transparent;     /* crea un “acolchado” interno */
				background-clip: content-box;       /* mantiene el acolchado */
			}
			#satList::-webkit-scrollbar-thumb:hover,
			#addSatPanel::-webkit-scrollbar-thumb:hover{
				background-color: var(--scroll-thumb-hover);
			}
			#satList::-webkit-scrollbar-corner,
			#addSatPanel::-webkit-scrollbar-corner{
				background: var(--scroll-corner);
			}
			
			/* nombre editable (al clic) */
			.sat-item .sat-name{
				cursor:text;
				border-bottom:1px dashed rgba(230,238,248,.25);
			}
			.sat-item .sat-name:focus{ outline: none; background:#0c1330; }
			
			/* ===== Estilo “primario” para el botón Añadir del panel ===== */
			#addSatPanel #addSatBtn{
			  appearance: none;
			  border: 1px solid #2a3a6b;
			  background: linear-gradient(180deg, #1b2a6a, #101a46);
			  color: var(--text);
			  border-radius: .6rem;
			  padding: .55rem .9rem .55rem 2.1rem; /* hueco para el icono */
			  font-weight: 600;
			  letter-spacing: .2px;
			  position: relative;
			  cursor: pointer;
			  box-shadow:
				0 6px 18px rgba(0,0,0,.35),
				inset 0 0 0 1px rgba(255,255,255,.04);
			  transition: transform .08s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease, filter .2s ease;
			}

			/* Icono + “chip” luminoso a la izquierda (sin cambiar el HTML) */
			#addSatPanel #addSatBtn::before{
			  content: "+";
			  position: absolute;
			  left: .65rem; top: 50%;
			  transform: translateY(-50%);
			  width: 1.25rem; height: 1.25rem; line-height: 1.2rem;
			  border-radius: .4rem;
			  text-align: center;
			  font-weight: 700; font-size: 1rem;
			  color: #fff;
			  background: radial-gradient(100% 100% at 50% 50%, #3d8bfd 0%, #2a5be8 100%);
			  box-shadow: 0 2px 8px rgba(3,121,255,.45), inset 0 0 0 1px rgba(255,255,255,.15);
			}

			/* Estados */
			#addSatPanel #addSatBtn:hover{
			  filter: saturate(1.1) brightness(1.05);
			  box-shadow:
				0 10px 24px rgba(0,0,0,.45),
				inset 0 0 0 1px rgba(255,255,255,.06);
			}
			#addSatPanel #addSatBtn:active{
			  transform: translateY(1px) scale(.985);
			}
			#addSatPanel #addSatBtn:focus-visible{
			  outline: 2px solid #6aa8ff;
			  outline-offset: 2px;
			}
			#addSatPanel #addSatBtn:disabled{
			  opacity: .6;
			  cursor: not-allowed;
			  filter: grayscale(25%);
			}

			/* (Opcional) compacta el contenedor del botón + color para que se vea fino en pantallas pequeñas */
			#addSatPanel > div[style*="display:flex"]{
			  flex-wrap: wrap;
			  gap: .5rem .6rem !important;
			}
			
			.kv{font-size:.85rem; opacity:.9}
			/* En la ficha del satélite, respeta los saltos de línea (\n) */
			.sat-item .kv{
			  white-space: pre-line;   /* convierte \n en saltos de línea */
			  line-height: 1.25;
			}
						
			details{border:1px dashed #2a3a6b; border-radius:.6rem; padding:.4rem .6rem; margin-top:.5rem}
			textarea{width:100%; min-height:110px; background:#0c1330; color:var(--text); border:1px solid #2a3a6b; border-radius:.5rem; padding:.5rem; font-family:ui-monospace,Menlo,Consolas,monospace}
			.hint{font-size:.8rem; opacity:.7}
			/* Si quieres forzar SIN relleno para pruebas, descomenta:
			#map .terminator-line { fill: none !important; }
			*/
			/* Solo nubes (WMTS IR): el fondo oscuro desaparece, quedan píxeles claros (nubes) */
			.clouds-only img{
				mix-blend-mode: lighten;
				image-rendering:auto;
			}
			/* --- Panel colapsable --- */
			/* Estado colapsado: animamos fuera de la pantalla sin provocar overflow ni foco */
			.panel.collapsed{
				transform: translateX(calc(100% + 16px));
				opacity:0;
				pointer-events:none;
			}
			.panel .min-btn{
				position:absolute; top:8px; right:8px; border:1px solid #26315c; background:#0e1540;
				color:var(--text); border-radius:.5rem; padding:.25rem .5rem; cursor:pointer; font-size:.9rem;
			}
			/* Ocultación dura tras la animación (ya sin efecto) */
			.panel.collapsed-hidden{ display:none; }
			.panel-toggle{
				position:absolute; top:60px; right:5px; z-index:1001;
				border:1px solid #26315c; background:#11173a; color:var(--text);
				border-radius:999px; padding:.5rem .7rem; cursor:pointer; display:none; align-items:center; gap:.4rem;
				box-shadow:0 8px 24px rgba(0,0,0,.35);
			}
			.panel-toggle .dot{
				width:.6rem; height:.6rem; border-radius:999px; background:#5aa9ff; display:inline-block;
			}
			/* --- Botones icono en filas de satélites --- */
			.sat-item .btn-icon{
				display:inline-flex; align-items:center; justify-content:center;
				width:28px; height:28px; border-radius:.4rem; border:1px solid #2a3a6b;
				background:#0e1540; color:var(--text); cursor:pointer; padding:0;
			}
			.sat-item .btn-icon svg{ width:16px; height:16px; pointer-events:none }
			.sat-item .btn-danger{ border-color:#5a2a2a; background:#3a0e0e }
			/* Botón de color: muestra el color actual; con fallback por si no hay conic-gradient */
			.sat-item .btn-color{
				width:28px; height:28px; border-radius:.4rem; border:1px solid #2a3a6b;
				cursor:pointer; padding:0;
				background: var(--col, #ff3333);
				background: conic-gradient(from 0deg, var(--col, #ff3333), var(--col, #ff3333));
			}
			
			/* Toggle (oculto por defecto en desktop) */
			.actions-toggle{
				display:none;
				margin-left:auto;
				background:#11173a;
				color:var(--text);
				border:1px solid #26315c;
				border-radius:.5rem;
				padding:.45rem .6rem;
				cursor:pointer;
				line-height:1;
			}
			
			/* ======= Responsivo: tablet y móvil ======= */
			@media (max-width: 1200px){
				header h1{ font-size:1rem }
				header .actions{ gap:.45rem }
				.panel{ width:300px; right:8px; bottom:20px; top:60px }
			}
			@media (max-width: 900px){
				header{ padding:.5rem .7rem }
				header h1{ font-size:.95rem }
				header button, header select, #refTime, #useNow{ font-size:.9rem; padding:.4rem .55rem }
				/* Mostrar el toggle y mandar acciones a la 2ª línea */
				.actions-toggle{ display:inline-flex; align-items:center; justify-content:center }
					header .actions{
					order:3;
					width:100%;
					display:flex;
					flex-wrap:wrap;
					gap:.45rem;
				}
				.panel{ width:300px; right:8px; bottom:18px; top:56px }
				/* botones más “tocables” en pantallas táctiles */
				.sat-item .btn-icon, .sat-item .btn-color{ width:32px; height:32px }
			}
			@media (max-width: 700px){
				/* En móvil: overlay fijo bajo el header (no empuja el layout) */
				header{ align-items:flex-start; gap:.5rem; position:relative }
				header .actions{ display:none }
				header .actions.open{
					display:flex;
					position: fixed;
					left: 0; right: 0;
					top: var(--actionsTop, 56px);   /* la fijamos desde JS al abrir */
					z-index: 1100;
					background: rgba(11,16,32,.98);
					border-bottom: 1px solid #1f284a;
					padding: .5rem .65rem;
					gap: .5rem;
					box-sizing: border-box;
					max-width: 100vw;               /* nunca más ancho que la pantalla */
					overflow-x: auto;               /* scroll horizontal si no cabe */
					overflow-y: hidden;
					-webkit-overflow-scrolling: touch;
					scrollbar-gutter: stable;
				}
				header .actions.open > *{ flex: 0 0 auto } /* que no intenten crecer/romper */
				header .actions.open::-webkit-scrollbar{ height:6px }
				/* Panel como “hoja” inferior, a ancho casi completo */
				.panel{
					right:5px; width:auto; max-width: 300px;
					top:auto; bottom:40px;            /* deja hueco para el botón flotante */
					max-height:62vh;
				}
				.panel-toggle{
					top:auto; right:6px; bottom:40px; /* botón para mostrar panel en móvil */
				}
				/* Botones más grandes para dedo */
				.sat-item .btn-icon, .sat-item .btn-color{ width:36px; height:36px }
				/* Ajustes del listado para pantallas estrechas */
				.sat-item{ gap:.45rem }
				#addSatPanel{ max-height:45vh }
				#addSatPanel textarea{ max-height:30vh }
			}
			@media (max-height: 540px){ /* paisaje de móvil: menos alto */
				.panel{ bottom:60px; max-height:55vh }
				#addSatPanel{ max-height:38vh }
			}
			
		</style>
	</head>
	<body>
		<div id="app">
			<header>
				<h1>Satellite Rasteator</h1>
				<button id="actionsToggle" class="actions-toggle" aria-label="Mostrar opciones">☰</button>
				<div class="actions">
					<button id="locateMe">Ubicarme</button>
					<label style="display:flex;align-items:center;gap:.35rem">
						<input type="checkbox" id="toggleTerminator" checked /> Día/Noche
					</label>
					<label style="display:flex;align-items:center;gap:.35rem">
						<input type="checkbox" id="toggleRadar" checked /> Radar
					</label>
					<label style="display:flex;align-items:center;gap:.35rem">
						<input type="checkbox" id="toggleClouds" checked /> Nubes
					</label>
					<select id="baseSel">
						<option value="osm">OSM</option>
						<option value="light">Claro</option>
						<option value="dark">Oscuro</option>
						<option value="sat">Satélite</option>
					</select>
					<select id="trackHorizon">
						<option value="0">Sin traza</option>
						<option value="30">+30 min</option>
						<option value="60" selected>+60 min</option>
						<option value="90">+90 min</option>
					</select>
					<input type="datetime-local" id="refTime" step="1" style="background:#11173a;color:#e6eef8;border:1px solid #26315c;border-radius:.5rem;padding:.45rem .5rem" />
					<button id="useNow">Ahora</button>
				</div>
			</header>
			<div id="map"></div>
		</div>
		
		<div class="panel">
			<button class="min-btn" id="minimizePanel" title="Ocultar panel">⮞</button>
			<h2>Estado</h2>
			<div class="kv" id="status">TLE: esperando…</div>
			<div class="kv" id="timeStatus">Tiempo ref: auto (reloj del sistema)</div>
			<div class="kv" id="utcStatus">UTC: —</div>
			
			<!-- Lista dinámica de satélites -->
			<div id="satList"></div>
			
			<details id="addSatPanel">
				<summary>➕ Añadir satélite (TLE)</summary>
				<p class="hint">Introduce el <b>nombre</b> y pega el TLE completo en un único campo (2 líneas empezando por <code>1</code> y <code>2</code>).</p>
				<label>Nombre del satélite</label>
				<input id="satName" placeholder="Ej: SENTINEL-2A" style="width:100%;background:#0c1330;color:var(--text);border:1px solid #2a3a6b;border-radius:.5rem;padding:.5rem" />
				<label style="display:block;margin-top:.5rem">TLE (2 líneas)</label>
				<textarea id="tleBlock" placeholder="1 42063U 17013A ...&#10;2 42063 98.5661 ..."></textarea>
				<div style="display:flex;align-items:center;gap:.5rem">
					<button id="addSatBtn">Añadir</button>
					<input type="color" id="defaultOrbitColor" value="#ff3333" title="Color de órbita por defecto" />
					<span class="hint">Color de órbita por defecto</span>
				</div>
			</details>

		</div>
		
		<!-- Botón flotante para reabrir el panel -->
		<button id="panelToggle" class="panel-toggle" aria-label="Mostrar panel"><span class="dot"></span> Panel</button>
		
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
		<script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
		<script>
			(function(){
				const MERC_MAX = 85.05112878;
				
				function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
				
				ready(function(){
				
					// Toggle de acciones en móvil
					const actionsToggle = document.getElementById('actionsToggle');
					const actionsBar = document.querySelector('header .actions');
					const headerEl = document.querySelector('header');
					if (actionsToggle && actionsBar){
						actionsToggle.addEventListener('click', ()=>{
							// Calcula el borde inferior del header para anclar el overlay
							const rect = headerEl.getBoundingClientRect();
							document.documentElement.style.setProperty('--actionsTop', `${Math.round(rect.bottom)}px`);
							actionsBar.classList.toggle('open');
						});

						// Cerrar al clicar fuera (solo en móvil)
						document.addEventListener('click', (e)=>{
							if (window.innerWidth > 700) return;
							if (!actionsBar.classList.contains('open')) return;
							const inside = actionsBar.contains(e.target) || actionsToggle.contains(e.target);
							if (!inside) actionsBar.classList.remove('open');
						});
						// Cerrar con Escape / al redimensionar / cambiar orientación
						window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') actionsBar.classList.remove('open'); });
						window.addEventListener('resize', ()=> actionsBar.classList.remove('open'));
						window.addEventListener('orientationchange', ()=> actionsBar.classList.remove('open'));
					}
				
					// --- MAPA (zoom/pan suaves) ---
					const map = L.map('map', {
						zoomControl: false,        // ← sin botones +/−
						worldCopyJump: false,
						// Zoom de rueda más fluido y con pasos fraccionados
						scrollWheelZoom: true,
						wheelDebounceTime: 25,       // respuesta rápida
					           wheelPxPerZoomLevel: 140,
					           // <-- pasos de 0.5 niveles
					           zoomSnap: 0.5,
					           zoomDelta: 0.5,
						zoomAnimation: true,
						zoomAnimationThreshold: 8,   // anima incluso saltos más grandes
						// Gestos táctiles/teclado centrados y panning con inercia suave
						touchZoom: 'center',
						doubleClickZoom: false,   // desactivamos el nativo (+1)
						inertia: true,
						inertiaDeceleration: 2500,
						inertiaMaxSpeed: 1500,
						easeLinearity: 0.2,
						 maxZoom: 22, minZoom: 2
					}).setView([0,0], 2);
					
					// Doble clic personalizado: +0.5 alrededor del punto clicado
					map.on('dblclick', (e) => {
						const next = Math.min(map.getMaxZoom(), map.getZoom() + 0.5);
						// setZoomAround mantiene el centro en el lugar del clic
						map.setZoomAround(e.latlng, next);
					});
					
					// --- Panel colapsable ---
					const panelEl = document.querySelector('.panel');
					const btnMin  = document.getElementById('minimizePanel');
					const btnFab  = document.getElementById('panelToggle');
					function setPanelCollapsed(collapsed){
						if(collapsed){
							// Quita ocultación dura para permitir la animación de salida si venía visible
							panelEl.classList.remove('collapsed-hidden');
							// Marca ARIA/inert para evitar foco y eventos mientras está fuera
							panelEl.setAttribute('aria-hidden','true');
							panelEl.setAttribute('inert','');
							// Activa animación hacia la derecha
							panelEl.classList.add('collapsed');
							// Cuando termine la transición, aplica ocultación dura
							const onEnd = (ev)=>{
								if(ev.propertyName !== 'transform') return;
								panelEl.classList.add('collapsed-hidden');
								panelEl.removeEventListener('transitionend', onEnd);
							};
							panelEl.addEventListener('transitionend', onEnd);
							btnFab.style.display = 'inline-flex';
						}else{
							// Quita ocultación dura y fuerza reflow para que se anime al entrar
							panelEl.classList.remove('collapsed-hidden');
							// Fuerza reflow para reiniciar la transición de 'transform'
							void panelEl.offsetWidth;
							panelEl.classList.remove('collapsed');
							// Restablece ARIA/inert
							panelEl.removeAttribute('aria-hidden');
							panelEl.removeAttribute('inert');
							btnFab.style.display = 'none';
						}
						try{ localStorage.setItem('panelCollapsed', collapsed ? '1' : '0'); }catch(e){}
					}
					// eventos
					if(btnMin) btnMin.addEventListener('click', ()=> setPanelCollapsed(true));
					if(btnFab) btnFab.addEventListener('click', ()=> setPanelCollapsed(false));
					// restaurar estado
					try{
						const saved = localStorage.getItem('panelCollapsed');
						if(saved === '1'){
							// Arrancar directamente oculto sin animar en el primer paint
							panelEl.classList.add('collapsed','collapsed-hidden');
							panelEl.setAttribute('aria-hidden','true');
							panelEl.setAttribute('inert','');
							btnFab.style.display = 'inline-flex';
						}
					}catch(e){}
										
					const baseCommonOpts = {
						maxNativeZoom: 19,   // detalle real de OSM
						maxZoom: 22,         // permite reescalar hasta 22
						updateWhenZooming: true, // actualiza durante la animación
						updateWhenIdle: false,   // prioriza fluidez
						keepBuffer: 3           // tiles alrededor para evitar parpadeos
					};
					const baseOSM   = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
						{ ...baseCommonOpts, maxNativeZoom: 19, attribution: 'OpenStreetMap contributors' }).addTo(map);
					const baseLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
						{ ...baseCommonOpts, maxNativeZoom: 20, attribution: 'OpenStreetMap & CARTO' });
					const baseDark  = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
						{ ...baseCommonOpts, maxNativeZoom: 20, attribution: 'OpenStreetMap & CARTO' });

					// Base satélite (Esri World Imagery)
					const baseSat   = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
						{ ...baseCommonOpts,  maxNativeZoom: 19, attribution: 'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community' });
					
					// Llevar control de la base actual para no borrar overlays al cambiar
					let currentBase = baseOSM;
								
					// ----- Estado de tiempo de referencia (auto vs manual) -----
					const timeState = { manual:false, value:new Date() };
					function refNow(){ return timeState.manual ? new Date(timeState.value) : new Date(); }
					// Formatea para <input type="datetime-local"> (zona local, sin 'Z')
					function toLocalDTValue(d){
						const pad = n => String(n).padStart(2,'0');
						const y=d.getFullYear(), m=pad(d.getMonth()+1), day=pad(d.getDate());
						const hh=pad(d.getHours()), mm=pad(d.getMinutes()), ss=pad(d.getSeconds());
						return `${y}-${m}-${day}T${hh}:${mm}:${ss}`;
					}
					// Actualiza el label de estado
					function updateTimeStatus(){
						const el = document.getElementById('timeStatus'); if(!el) return;
						if(timeState.manual){
							const d = refNow();
							el.textContent = `Tiempo ref: manual → ${d.toLocaleString()} (local) | ${d.toISOString().replace('T',' ').replace('Z',' UTC')}`;
						} else {
							el.textContent = 'Tiempo ref: auto (reloj del sistema)';
						}
						updateUTCStatus(); // sincroniza la línea de UTC global
					}
					
					// Línea global de UTC bajo "Estado"
					function updateUTCStatus(){
						const u = document.getElementById('utcStatus'); if(!u) return;
						const d = refNow();
						u.textContent = 'UTC: ' + d.toISOString().replace('T',' ').replace('Z',' UTC');
					}
					
					// Recalcula todo cuando cambia el tiempo de referencia
					function applyRefTime(){
						if(window.dayNightLayer) window.dayNightLayer.setTime(refNow());
						if(typeof buildTerminatorLine === 'function') buildTerminatorLine();
						if(typeof tick === 'function') tick();
						if(typeof computeAllTracks === 'function') computeAllTracks();
						updateTimeStatus();
						updateUTCStatus();
					}
									
					// === Panes por orden: satélites > órbitas > día/noche > radar > nubes > mapa ===
					
					// Pane para satélites (TOP map panes)
					let satPane = map.getPane('satPane');
					if (!satPane) { map.createPane('satPane'); satPane = map.getPane('satPane'); }
					satPane.style.zIndex = '750';       // 1) SATÉLITES (más alto de los panes del mapa)
					satPane.style.pointerEvents = 'auto';
					
					// 2) ÓRBITAS (polylines/círculos)
					let orbitPane = map.getPane('orbitPane');
					if(!orbitPane){ map.createPane('orbitPane'); orbitPane = map.getPane('orbitPane'); }
					orbitPane.style.zIndex = '720';
					orbitPane.style.pointerEvents = 'none';

					// 4) DÍA/NOCHE (terminator)
					let paneEl = map.getPane('terminatorPane');
					if(!paneEl){ map.createPane('terminatorPane'); paneEl = map.getPane('terminatorPane'); }
					paneEl.style.zIndex = '500';
					paneEl.style.pointerEvents = 'none';

					// 5) RADAR (RainViewer)
					let radarPane = map.getPane('radarPane');
					if(!radarPane){ map.createPane('radarPane'); radarPane = map.getPane('radarPane'); }
					radarPane.style.zIndex = '390';
					radarPane.style.pointerEvents = 'none';

					// 6) NUBES (Sat IR)
					let cloudsPane = map.getPane('cloudsPane');
					if(!cloudsPane){ map.createPane('cloudsPane'); cloudsPane = map.getPane('cloudsPane'); }
					cloudsPane.style.zIndex = '380';
					cloudsPane.style.pointerEvents = 'none';								
														
														
					// ========================= RainViewer (sin TimeDimension) =========================
					// Usamos la API pública para obtener la lista de frames y elegimos:
					//  - si "Ahora": el frame MÁS RECIENTE disponible
					//  - si manual:  el frame más cercano ≤ refTime()
					const RAINV_META_URL = 'https://api.rainviewer.com/public/weather-maps.json';
					
					// Radar
					let rainv = {
						host: 'https://tilecache.rainviewer.com',
						frames: [],           // [{time, path}, ...] (segundos desde epoch)
						layer: null,
						lastUrl: '',
						_lastMeta: 0
					};
					// Satélite (infrared)
					let satv = {
						host: 'https://tilecache.rainviewer.com',
						frames: [],           // [{time, path}, ...]
						layer: null,
						lastUrl: '',
						_lastMeta: 0
					};
					
					function fetchRainMeta(){
						return fetch(RAINV_META_URL, { cache: 'no-store' })
						.then(r => r.json())
						.then(j => {
							const host = j?.host || rainv.host;
							rainv.host = host; satv.host = host;
							// Radar
							const past = Array.isArray(j?.radar?.past) ? j.radar.past : [];
							const nowc = Array.isArray(j?.radar?.nowcast) ? j.radar.nowcast : [];
							rainv.frames = past.concat(nowc).sort((a,b)=>a.time-b.time);
							rainv._lastMeta = Date.now();
							// Satélite (infrared)
							const infrared = Array.isArray(j?.satellite?.infrared) ? j.satellite.infrared : [];
							satv.frames = infrared.sort((a,b)=>a.time-b.time);
							satv._lastMeta = Date.now();
						})
						.catch(()=>{ /* silencio: sin conexión o CORS */ });
					}
					
					function pickBestFrame(frames, date){
						if (!frames.length) return null;
						const ts = Math.floor(date.getTime()/1000);
						if (!timeState.manual){
							// "Ahora": el último frame disponible
							return frames[frames.length-1];
						}
						// Manual: el frame más cercano que no supere refTime
						let best = frames[0];
						for (const f of frames){
							if (f.time <= ts) best = f; else break;
						}
						return best;
					}
					
					// Construye URL de teselas a partir de "path" de RainViewer
					// Formato: {host}{path}/256/{z}/{x}/{y}/{color}/{smooth}_{snow}.png
					// Elegimos color 3 (The Weather Channel), smooth=1, snow=1
					function pathToTileUrl(path){
						return `${rainv.host}${path}/256/{z}/{x}/{y}/3/1_1.png`;
					}
					
					function ensureRadar(){
					// Capa vacía al inicio; se rellena con setUrl cuando tengamos meta+frame
						if (!rainv.layer){
							rainv.layer = L.tileLayer('', {
								pane: 'radarPane',   // 5) radar por encima de nubes
								updateWhenZooming: true,
								updateWhenIdle: false,
								opacity: 0.85,
								maxNativeZoom: 9,   // límite actual de RainViewer
								maxZoom: 22,
								noWrap: true,
								crossOrigin: true,
								attribution: 'Radar © RainViewer'
							}).addTo(map);
						}
						// Carga metadatos (si hace >2 min que no actualizamos) y ajusta frame
						const needMeta = (Date.now() - rainv._lastMeta) > 120000 || !rainv.frames.length;
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(rainv.frames, refNow());
						if (!f) return;
						const url = pathToTileUrl(f.path);
						if (url !== rainv.lastUrl){
							rainv.layer.setUrl(url);
							rainv.lastUrl = url;
						}
						if (map.hasLayer(rainv.layer)) rainv.layer.bringToFront();
						// Mantén el terminador arriba
						if (window.dayNightLayer) window.dayNightLayer.bringToFront(); if (window.ringLine) window.ringLine.bringToFront();
						});
					}
					
					function updateRadar(){
						// Si estamos en "Ahora", refresca metadatos de vez en cuando
						const needMeta = !timeState.manual && ((Date.now() - rainv._lastMeta) > 120000);
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(rainv.frames, refNow());
						if (!f) return;
						const url = pathToTileUrl(f.path);
						if (url !== rainv.lastUrl){
							rainv.layer.setUrl(url);
							rainv.lastUrl = url;
						}
						});
					}
					
					// Inicializa radar
					ensureRadar();
					
					// ------------------------- Nubes (Satélite IR) -------------------------
					// color=0 (grayscale IR), usamos clase 'clouds-only' para blend "solo nubes"
					function pathToSatUrl(path){
						return `${satv.host}${path}/256/{z}/{x}/{y}/0/1_1.png`;
					}
					
					function ensureSatRV(){
					if (!satv.layer){
					satv.layer = L.tileLayer('', {
						pane: 'cloudsPane',      // 6) nubes por debajo de radar
						updateWhenZooming: true,
						updateWhenIdle: false,
						className: 'clouds-only',   // mix-blend-mode: lighten
						opacity: 0.95,
						maxNativeZoom: 9,
						maxZoom: 22,
						noWrap: true,
						crossOrigin: true,
						attribution: 'Satélite © RainViewer'
					}).addTo(map);
					}
					const needMeta = (Date.now() - satv._lastMeta) > 120000 || !satv.frames.length;
					const p = needMeta ? fetchRainMeta() : Promise.resolve();
					p.then(()=>{
					const f = pickBestFrame(satv.frames, refNow());
					if (!f) return;
					const url = pathToSatUrl(f.path);
					if (url !== satv.lastUrl){
						satv.layer.setUrl(url);
						satv.lastUrl = url;
					}
					if (map.hasLayer(satv.layer)) satv.layer.bringToFront();
					// Mantén el terminador arriba
						if (window.dayNightLayer) window.dayNightLayer.bringToFront(); if (window.ringLine) window.ringLine.bringToFront();
					});
					}
					
					function updateSatRV(){
						const needMeta = !timeState.manual && ((Date.now() - satv._lastMeta) > 120000);
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(satv.frames, refNow());
						if (!f) return;
						const url = pathToSatUrl(f.path);
						if (url !== satv.lastUrl){
							satv.layer.setUrl(url);
							satv.lastUrl = url;
						}
						});
					}
					
					// Inicializa nubes satélite
					ensureSatRV();
					
					// Toggle mostrar/ocultar
					
					// --- Centraliza el orden de capas dentro de cada pane ---
					// (Los zIndex de los panes ya fijan el orden global)
					function restoreOrder(){
						if (satv.layer  && map.hasLayer(satv.layer))   satv.layer.bringToFront();   // Nubes
						if (rainv.layer && map.hasLayer(rainv.layer))  rainv.layer.bringToFront();  // Radar
						if (window.ringLine)      window.ringLine.bringToFront();                   // Terminador (SVG)
						if (window.dayNightLayer) window.dayNightLayer.bringToFront();              // Terminador (tiles)
					}					
					
					const radarChk = document.getElementById('toggleRadar');
					if (radarChk){
						radarChk.addEventListener('change', function(){
							if (this.checked){
								if (rainv.layer){ rainv.layer.addTo(map); rainv.layer.bringToFront(); }
							} else {
								if (rainv.layer) map.removeLayer(rainv.layer);
							}
							try{ localStorage.setItem('sr.t.radar', this.checked?'1':'0'); }catch(_){}
						});
					}
					const cloudsChk = document.getElementById('toggleClouds');
					if (cloudsChk){
						cloudsChk.addEventListener('change', function(){
							if (this.checked){
								if (satv.layer) { satv.layer.addTo(map); satv.layer.bringToFront(); }
							} else {
								if (satv.layer) map.removeLayer(satv.layer);
							}
							try{ localStorage.setItem('sr.t.clouds', this.checked?'1':'0'); }catch(_){}
						});
					}
					
					// Inicializa el input con la hora actual (local) — AHORA sí, tras definir toLocalDTValue/applyRefTime
					const refInput = document.getElementById('refTime');
					if(refInput){
						refInput.value = toLocalDTValue(new Date());
						refInput.addEventListener('change', () => {
							const v = refInput.value;        // "YYYY-MM-DDTHH:mm[:ss]"
							if(!v) return;
							const d = new Date(v);           // interpretado en LOCAL
							if(isNaN(d.getTime())) return;
							timeState.manual = true;
							timeState.value  = d;
							applyRefTime();
							updateRadar();                   // sincroniza radar al nuevo frame
							updateSatRV();                   // sincroniza nubes al nuevo frame
						});
					}

					
					// Botón "Ahora" → vuelve a automático
					const useNowBtn = document.getElementById('useNow');
					if(useNowBtn){
						useNowBtn.addEventListener('click', () => {
							timeState.manual = false;
							timeState.value  = new Date();
							if(refInput) refInput.value = toLocalDTValue(new Date());
							applyRefTime();
							updateRadar();
							updateSatRV();
						});
					}
				
					document.getElementById('baseSel').addEventListener('change', (e)=>{
						const v = e.target.value;
						const nextBase = (v==='light' ? baseLight : v==='dark' ? baseDark : v==='sat' ? baseSat : baseOSM);
						if (currentBase && map.hasLayer(currentBase)) map.removeLayer(currentBase);
						nextBase.addTo(map);
						currentBase = nextBase;

						try{ localStorage.setItem('sr.base', v); }catch(_){}
						restoreOrder();
					});
				
					// --- DÍA/NOCHE por tiles (GridLayer Canvas) ---
					let dayNightLayer = null; window.dayNightLayer = null;
					let ringLine = null;      window.ringLine     = null;
				
					const rad = x => x*Math.PI/180;
					const deg = x => x*180/Math.PI;
					const normLon = d => { while(d<-180) d+=360; while(d>180) d-=360; return d; };
					const jdFromDate = date => date.getTime()/86400000 + 2440587.5;
				
					function subsolar(date){
						const JD = jdFromDate(date);
						const T = (JD - 2451545.0)/36525.0;
						let L0 = 280.46646 + 36000.76983*T + 0.0003032*T*T; L0 = ((L0%360)+360)%360;
						const M  = 357.52911 + 35999.05029*T - 0.0001537*T*T; const Mr = rad(M);
						const C  = (1.914602 - 0.004817*T - 0.000014*T*T)*Math.sin(Mr)
								+ (0.019993 - 0.000101*T)*Math.sin(2*Mr)
								+ 0.000289*Math.sin(3*Mr);
						const lambda = L0 + C; const Omega = 125.04 - 1934.136*T;
						const lambdaApp = lambda - 0.00569 - 0.00478*Math.sin(rad(Omega));
						const eps0 = 23 + 26/60 + 21.448/3600 - (46.8150/3600)*T - (0.00059/3600)*T*T + (0.001813/3600)*T*T*T;
						const eps  = eps0 + 0.00256*Math.cos(rad(Omega));
						const epsr = rad(eps), lamr = rad(lambdaApp);
						const alpha = Math.atan2(Math.cos(epsr)*Math.sin(lamr), Math.cos(lamr));
						const delta = Math.asin(Math.sin(epsr)*Math.sin(lamr));
						let Theta = 280.46061837 + 360.98564736629*(JD - 2451545.0) + 0.000387933*T*T - T*T*T/38710000.0;
						Theta = ((Theta%360)+360)%360;
						const alphaDeg = ((deg(alpha)%360)+360)%360;
						const lon = normLon(alphaDeg - Theta);
						const lat = deg(delta);
						return { lat, lon };
					}
				
					// GridLayer: usa paso dinámico según zoom para rendimiento
					const DayNight = L.GridLayer.extend({
					initialize: function(opts){ L.setOptions(this, opts||{}); this._sun = subsolar(new Date()); },
					setTime: function(date){ this._sun = subsolar(date); this.redraw(); },
					createTile: function(coords, done){
						const tile = L.DomUtil.create('canvas','leaflet-tile');
						const size = this.getTileSize(); tile.width = size.x; tile.height = size.y;
						const ctx = tile.getContext('2d');
						const z = this._map ? this._map.getZoom() : 2;
						// Más grueso a zoom bajos para ahorrar CPU, más fino con zoom altos
						const step = Math.max(2, 10 - Math.min(8, Math.floor(z))); // 8→2 px aprox.
						const origin = coords.scaleBy(size);
						ctx.fillStyle = '#000000';
						const opacity = (typeof this.options.opacity === 'number') ? this.options.opacity : 0.8;
						const s = this._sun; const sphi = rad(s.lat), slam = rad(s.lon);
						const sx = Math.cos(sphi)*Math.cos(slam), sy = Math.cos(sphi)*Math.sin(slam), sz = Math.sin(sphi);
						for (let y=0; y<size.y; y+=step){
						for (let x=0; x<size.x; x+=step){
							const ll = this._map.unproject(L.point(origin.x + x + step/2, origin.y + y + step/2));
							const phi = rad(ll.lat), lam = rad(ll.lng);
							const nx = Math.cos(phi)*Math.cos(lam), ny = Math.cos(phi)*Math.sin(lam), nz = Math.sin(phi);
							const cosz = nx*sx + ny*sy + nz*sz; // >0 día, <0 noche
							if (cosz < 0){ ctx.globalAlpha = opacity; ctx.fillRect(x, y, step, step); }
						}
						}
						ctx.globalAlpha = 1;
						if(done) done(null, tile);
						return tile;
					}
					});
				
					dayNightLayer = new DayNight({ tileSize: 256, opacity: 0.8, pane:'terminatorPane' }).addTo(map);
					window.dayNightLayer = dayNightLayer;
					dayNightLayer.setTime(refNow()); // ← sincroniza con la hora de referencia al inicio
				
					// Re-mapea una longitud para que quede "cerca" de una de referencia (evita saltos de 360°)
					function unwrapLon(lon, ref){
						let x = lon;
						while (x - ref > 180)  x -= 360;
						while (x - ref < -180) x += 360;
						return x;
						}
						// Envuelve de vuelta a [-180, 180]
						function wrapLon(lon){
						return ((lon + 180) % 360 + 360) % 360 - 180;
						}
						
						// Cierra cada segmento hacia el sur (edgeLat=-MERC_MAX) o norte (edgeLat=+MERC_MAX)
						// Asegura SIEMPRE los dos vértices inferiores: derecha (lonA) e izquierda (lonB)
						function segmentsToClosedRings(segments, closeToSouth = true){
						const rings = [];
						const edgeLat = closeToSouth ? -MERC_MAX : MERC_MAX;
						
						for (const seg of segments){
							if (!seg || seg.length < 2) continue;
						
							const first = seg[0];
							const last  = seg[seg.length - 1];
						
							// Referencia de "desenvoltura": la longitud del último punto
							const lonRef = last[1];
						
							// Copiamos el segmento "desenvuelto" para que no haya saltos en ±180°
							const unwrapped = seg.map(([la, lo]) => [la, unwrapLon(lo, lonRef)]);
						
							// Calculamos las dos longitudes inferiores "desenvueltas"
							const lonA = unwrapLon(last[1],  lonRef);   // derecha (desde el último)
							const lonB = unwrapLon(first[1], lonA);     // izquierda (con continuidad respecto a lonA)
						
							// Construimos el anillo: línea del terminador → bajar a fondo derecha → fondo izquierda → subir a inicio
							const ring = [
							...unwrapped,
							[edgeLat, lonA],
							[edgeLat, lonB],
							[first[0], lonB],
							].map(([la, lo]) => [la, wrapLon(lo)]);     // volvemos a ±180°
						
							rings.push(ring);
						}
						return rings;
					}
				
					// Línea/máscara del terminador (segmentada en ±180°)
					function buildTerminatorLine(){
						const s = subsolar(refNow());
					
						// Base ortonormal:
						const phi = rad(s.lat), lam = rad(s.lon);
						const cx = Math.cos(phi)*Math.cos(lam), cy = Math.cos(phi)*Math.sin(lam), cz = Math.sin(phi);
						let ax=0, ay=0, az=1; if (Math.abs(cz) > 0.99) { ax=1; ay=0; az=0; }
						let ux = ay*cz - az*cy, uy = az*cx - ax*cz, uz = ax*cy - ay*cx; const un = Math.hypot(ux,uy,uz); ux/=un; uy/=un; uz/=un;
						const vx = cy*uz - cz*uy, vy = cz*ux - cx*uz, vz = cx*uy - cy*ux;
					
						// 1) Línea del terminador (evitar salto ±180°)
						const segments = []; let seg = []; let prevLon = null; const TH = 170;
						for (let t=0; t<=360; t+=0.5){
							const tr = rad(t);
							const x = ux*Math.cos(tr) + vx*Math.sin(tr);
							const y = uy*Math.cos(tr) + vy*Math.sin(tr);
							const z = uz*Math.cos(tr) + vz*Math.sin(tr);
							let lat = deg(Math.asin(z));
							if (lat >  MERC_MAX) lat =  MERC_MAX;
							if (lat < -MERC_MAX) lat = -MERC_MAX;
							let lon = deg(Math.atan2(y, x)); lon = normLon(lon);
					
							if (prevLon !== null){
							if ((prevLon > TH && lon < -TH) || (prevLon < -TH && lon > TH)){
								if (seg.length) segments.push(seg);
								seg = [];
							}
							}
							seg.push([lat, lon]);
							prevLon = lon;
						}
						if (seg.length) segments.push(seg);
					
						// 2) ¿Cerrar al sur o al norte? (noche incluye el polo opuesto al subsolar)
						const closeToSouth = (s.lat >= 0); // sol en norte => noche al sur; sol en sur => noche al norte
						const rings = segmentsToClosedRings(segments, closeToSouth);
					
						// 3) Crear/actualizar la máscara
						const opts = {
							pane: 'terminatorPane',
							weight: 0,                      // sin borde visible (mejor máscara pura)
							color:  'rgba(0,0,0,0)',
							lineCap: 'round',
							lineJoin: 'round',
							fill: true,
							fillColor: '#001133',              // negro para noche (se integra con tiles)
							fillOpacity: 0.60,
							noClip: true,
							smoothFactor: 0,
							className: 'terminator-line',
							interactive: false,             // no bloquea eventos (además el pane tiene pointer-events:none)
							renderer: L.svg({ padding: 0 })
						};
					
						if (!window.ringLine){
							window.ringLine = L.polygon(rings, opts).addTo(map);
							ringLine = window.ringLine; // sincroniza ref. local para el toggle
						} else {
							window.ringLine.setLatLngs(rings);
							window.ringLine.setStyle(opts);
						}
						window.ringLine.bringToFront();
					}
						
					// Pintar ya
					buildTerminatorLine();
					
					// Toggle de ambas capas
					const termChk = document.getElementById('toggleTerminator');
					if (termChk) {
						termChk.addEventListener('change', function () {
							if (this.checked) {
							if (dayNightLayer) dayNightLayer.addTo(map);
							if (ringLine)      ringLine.addTo(map);
						
							// Reponer overlays si están activos y dejarlos AL FRENTE
							if (document.getElementById('toggleRadar')?.checked && rainv?.layer) {
								rainv.layer.addTo(map);
							}
							if (document.getElementById('toggleClouds')?.checked && satv?.layer) {
								satv.layer.addTo(map);
							}
						
							restoreOrder();
							} else {
							if (dayNightLayer) map.removeLayer(dayNightLayer);
							if (ringLine)      map.removeLayer(ringLine);
							}
						
							// ⇩⇩ Persistencia del toggle Día/Noche
							try { localStorage.setItem('sr.t.term', this.checked ? '1' : '0'); } catch (_) {}
						});
					}
				
					const state = { horizonMins:60, sats:{} }; // ahora dinámico (id -> objeto sat)

					// ===== Persistencia en navegador =====
					const STORAGE = {
						key: 'satRasteator.sats.v1',
						save(){
							try{
								const arr = Object.entries(state.sats).map(([id, s])=>({
									id,
									name: s.name,
									l1: s.l1,
									l2: s.l2,
									color: s.color || '#ff3333',
									visible: !!s.visible,
									iconKey: s.iconKey || null,
									iconUrl: s.iconUrl || null
								}));
								localStorage.setItem(this.key, JSON.stringify(arr));
							}catch(_){}
						},
						load(){
							try{
								const raw = localStorage.getItem(this.key);
								if(!raw) return [];
								const arr = JSON.parse(raw);
								return Array.isArray(arr) ? arr : [];
							}catch(_){ return []; }
						}
					};
				
					function toggleSat(id, on){
						const s=state.sats[id]; if (!s) return;
						s.visible=on;
						if(s.marker){ on?map.addLayer(s.marker):map.removeLayer(s.marker); }
						if(s.circle){ on?map.addLayer(s.circle):map.removeLayer(s.circle); }
						if(s.track){  on?map.addLayer(s.track):map.removeLayer(s.track); }
						STORAGE.save();
					}
				
					let meMarker = null;
					document.getElementById('locateMe').addEventListener('click', function(){
						if(!navigator.geolocation){ alert('Geolocalizacion no soportada'); return; }
						navigator.geolocation.getCurrentPosition(function(pos){
							const lat=pos.coords.latitude; const lon=pos.coords.longitude;
							if (!meMarker){
								meMarker = L.marker([lat,lon],{title:'Mi ubicación'}).addTo(map);
								meMarker.bindPopup('Estás aquí');
							} else {
								meMarker.setLatLng([lat,lon]);
							}
							meMarker.openPopup();
							map.flyTo([lat,lon],5,{duration:1.2, easeLinearity:0.25, animate:true});
						}, function(){ alert('No se pudo obtener ubicacion'); });
					});
				
					document.getElementById('trackHorizon').addEventListener('change', function(e){
						state.horizonMins=parseInt(e.target.value,10)||0; computeAllTracks();
						try{ localStorage.setItem('sr.horizon', String(state.horizonMins)); }catch(_){}
					});
				
					const now = () => refNow();
					function toLLA(satrec, date){
						const pv = satellite.propagate(satrec, date);
						if(!pv.position||!pv.velocity) return null;
						const gmst = satellite.gstime(date);
						const gd = satellite.eciToGeodetic(pv.position, gmst);
						const lat = satellite.degreesLat(gd.latitude);
						const lon = satellite.degreesLong(gd.longitude);
						const altKm = gd.height;
						const v = pv.velocity; const speedKms = Math.hypot(v.x,v.y,v.z);
						return { lat, lon, altKm, speedKmh:speedKms*3600 };
					}
					
					// Radio de huella (arco sobre la superficie) ~ Re * acos(Re/(Re+h))
					function footprintRadiusMeters(altKm){
						const Re = 6371;                       // km
						const psi = Math.acos(Re / (Re + Math.max(altKm, 0.001)));
						return Re * psi * 1000;                // → metros
					}
					
					// Precarga de un icono local para evitar parpadeos
					(new Image()).src = 'img/satellite-rasteator/icons/32/sat1.png';

					// === Iconos locales (32/64 px) y fábrica de iconos ===
					const ICON_BASE = 'img/satellite-rasteator/icons';
					const ICON_FILES = {
						sat1: 'sat1.png',
						sat2: 'sat2.png',
						sat3: 'sat3.png',
						sat4: 'sat4.png',
						sat5: 'sat5.png',
						sat6: 'sat6.png',
						sat7: 'sat7.png',
						iss : 'iss.png'
					};
					// Acepta una clave (sat1…iss) o una URL absoluta/data:
					function makeIcon(keyOrUrl = 'sat1'){
						const isUrl = /^(https?:|data:|\/)/i.test(keyOrUrl);
						const file  = ICON_FILES[keyOrUrl] || ICON_FILES.sat1;
						const x1 = isUrl ? keyOrUrl : `${ICON_BASE}/32/${file}`;
						const x2 = isUrl ? keyOrUrl : `${ICON_BASE}/64/${file}`;
						return L.icon({
							iconUrl: x1,
							iconRetinaUrl: x2,
							iconSize: [32,32],
							iconAnchor: [16,16],
							popupAnchor: [0,-16],
							className: 'satellite-icon'
						});
					}
					
					// DEBUG: icono de prueba en (0,0). Quitar luego.
					//L.marker([0,0], { icon: satIcon, pane: 'satPane', title: 'TEST' }).addTo(map);
				
					function updateSat(id){
						const s = state.sats[id]; if(!s || !s.satrec) return;
						const p=toLLA(s.satrec, now()); if(!p) return;
						if(!s.marker){
							const keyOrUrl = s.iconUrl || s.iconKey || 'sat1';
							s.marker = L.marker([p.lat, p.lon], {
								title: s.name,
								icon: makeIcon(keyOrUrl),
								pane: 'satPane'
							}).addTo(map).bindPopup('<b>'+s.name+'</b>');
						} else {
							// ¡No recrear! solo mover el marker existente
							s.marker.setLatLng([p.lat, p.lon]);
						}
						
						const radius = typeof footprintRadiusMeters === 'function'
							? footprintRadiusMeters(p.altKm)
							: 145000; // fallback si no integraste la función de radio dinámico
						if(!s.circle){
							// 2) footprint/área en pane de ÓRBITAS (color y relleno desde el inicio)
							s.circle = L.circle([p.lat, p.lon], {
								pane: 'orbitPane',
								radius,
								color: s.color || '#ff3333',
								fillColor: s.color || '#ff3333',
								weight: 1,
								opacity: 0.9,
								fillOpacity: 0.12
								}).addTo(map);
							} else {
								s.circle.setLatLng([p.lat,p.lon]);
								// por si cambia la altitud o integras radio dinámico
								if (typeof s.circle.setRadius === 'function') s.circle.setRadius(radius);
							}
						
						const el=document.getElementById('kv-'+id);
						if(el){
							let txt='Lat: '+p.lat.toFixed(3)+' deg, Lon: '+p.lon.toFixed(3)+' deg';
							txt+='\nAlt: '+p.altKm.toFixed(1)+' km | Vel: '+p.speedKmh.toFixed(0)+' km/h';
							el.textContent=txt;
						}
					}
				
					function computeTrack(id){
						const s=state.sats[id];
						if(!s.satrec || state.horizonMins<=0){ if(s.track){ map.removeLayer(s.track); s.track=null; } return; }
						const step=30; // 30s
						const total=state.horizonMins*60;
						const pts=[]; const start = refNow();
						for(let t=0; t<=total; t+=step){
							const d=new Date(start.getTime()+t*1000);
							const p=toLLA(s.satrec, d);
							if(p) pts.push([p.lat,p.lon]);
						}
						if(!s.track){
							s.track=L.polyline(pts,{
								pane:'orbitPane',
								color: s.color || '#ff3333',
								weight:1.2, opacity:.9
							}).addTo(map);
						} else {
							s.track.setLatLngs(pts);
							// aplica color si cambió
							s.track.setStyle({ color: s.color || '#ff3333' });
						}
					}
				
					function computeAllTracks(){
						for (const id in state.sats){ computeTrack(id); }
					}
					function tick(){
						for (const id in state.sats){ updateSat(id); }
					}
				
					document.getElementById('status').textContent='TLE: esperando (usa el panel para pegarlas)';

					// ====== Gestión dinámica de satélites (refs DOM) — mover arriba para evitar TDZ ======
					const satListEl   = document.getElementById('satList');
					const addBtn      = document.getElementById('addSatBtn');
					const nameInp     = document.getElementById('satName');
					const tleBlockInp = document.getElementById('tleBlock');
					const defColInp   = document.getElementById('defaultOrbitColor');

					// === Guardar vista del mapa (centro/zoom)
					map.on('moveend zoomend', ()=>{
						try{
							const c = map.getCenter();
							localStorage.setItem('sr.mapView', JSON.stringify({ center:[c.lat, c.lng], zoom: map.getZoom() }));
						}catch(_){}
					});

					// === Restaurar estado de UI
					function restoreUI(){
						try{
							// Base
							const savedBase = localStorage.getItem('sr.base');
							if (savedBase){
								const sel = document.getElementById('baseSel');
								if (sel) sel.value = savedBase;
								const nextBase = (savedBase==='light'?baseLight : savedBase==='dark'?baseDark : savedBase==='sat'?baseSat : baseOSM);
								if (currentBase && map.hasLayer(currentBase)) map.removeLayer(currentBase);
								nextBase.addTo(map); currentBase = nextBase;
							}
							// Vista
							const mv = JSON.parse(localStorage.getItem('sr.mapView')||'null');
							if (mv && Array.isArray(mv.center) && typeof mv.zoom==='number'){
								map.setView(mv.center, mv.zoom, {animate:false});
							}
							// Horizonte traza
							const h = localStorage.getItem('sr.horizon');
							if (h){
								state.horizonMins = parseInt(h,10)||0;
								const selH = document.getElementById('trackHorizon');
								if (selH) selH.value = String(state.horizonMins);
								computeAllTracks();
							}
							// Toggles
							const t1 = localStorage.getItem('sr.t.term');
							if (t1!==null){ const chk = document.getElementById('toggleTerminator'); if(chk){ chk.checked = (t1==='1'); chk.dispatchEvent(new Event('change')); } }
							const t2 = localStorage.getItem('sr.t.radar');
							if (t2!==null){ const chk = document.getElementById('toggleRadar'); if(chk){ chk.checked = (t2==='1'); chk.dispatchEvent(new Event('change')); } }
							const t3 = localStorage.getItem('sr.t.clouds');
							if (t3!==null){ const chk = document.getElementById('toggleClouds'); if(chk){ chk.checked = (t3==='1'); chk.dispatchEvent(new Event('change')); } }
						}catch(_){}
					}

					// Restaurar UI y luego satélites guardados
					restoreUI();					
					
					// Restaurar satélites guardados
					(function restoreSaved(){
						const saved = STORAGE.load();
						if (saved.length){
							for (const it of saved){
								const {id, name, l1, l2, color, visible, iconKey, iconUrl} = it || {};
 								if (name && l1 && l2){
									addSatellite({ id, name, l1, l2, color, visible, iconKey, iconUrl });
 								}
							}
							const st = document.getElementById('status');
							if (st) st.textContent = `TLE: cargado (${Object.keys(state.sats).length} satélites)`;
						}
					})();
					tick(); computeAllTracks();
					
					setInterval(tick,1000);

					function parseTwoline(l1, l2){
						try{ return satellite.twoline2satrec(l1.trim(), l2.trim()); }catch(_){ return null; }
					}
					
					function parseTLEBlock(txt){
						if (!txt) return null;
						const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
						// Buscar la primera línea que empiece por "1 " y la primera que empiece por "2 "
						let l1 = lines.find(l => /^1\s/.test(l));
						let l2 = lines.find(l => /^2\s/.test(l));
						// Por si el usuario pegó más de dos líneas, tomar la siguiente "2 " tras la "1 "
						if (!l2 && l1){
							const i1 = lines.indexOf(l1);
							l2 = lines.slice(i1+1).find(l => /^2\s/.test(l));
						}
						return (l1 && l2) ? { l1, l2 } : null;
					}

					function uidFromName(name){
						const base = name.trim().toUpperCase().replace(/[^A-Z0-9]+/g,'-').replace(/^-+|-+$/g,'') || 'SAT';
						return base + '-' + Date.now().toString(36);
					}

					function createSatRow(id, s){
						const row = document.createElement('div');
						row.className = 'sat-item';
						row.id = 'row-'+id;
						row.innerHTML = `
							<input type="checkbox" id="chk-${id}" ${s.visible?'checked':''} />
							<div style="min-width:0">
								<div><b class="sat-name" data-id="${id}" title="Editar nombre (clic)">${s.name}</b></div>
								<div class="kv" id="kv-${id}"></div>
							</div>
							<div class="sat-actions actions-col">
								<button class="zoomSat btn-icon" data-id="${id}" title="Zoom">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5Zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14Z"/></svg>
								</button>
								<button class="iconBtn btn-icon" data-id="${id}" title="Elegir icono">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M21 19V5a2 2 0 0 0-2-2H5C3.9 3 3 3.9 3 5v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2ZM8.5 12.5l2.5 3.01 3.5-4.51L19 18H5l3.5-5.5ZM8 8a2 2 0 1 1 0 4 2 2 0 0 1 0-4Z"/></svg>
								</button>
								<button class="colorBtn btn-color" data-id="${id}" title="Cambiar color de órbita"></button>
								<button class="editTLE btn-icon" data-id="${id}" title="Modificar TLE">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25ZM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
								</button>
								<button class="delSat btn-icon btn-danger" data-id="${id}" title="Eliminar satélite">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 7h12v2H6V7Zm2 3h8l-1 9H9L8 10Zm3-6h2v2h-2V4Z"/></svg>
								</button>
								<input type="color" class="colorPicker" id="col-${id}" value="${s.color || '#ff3333'}" style="position:absolute;opacity:0;pointer-events:none;width:0;height:0" />
							</div>
						`;
						satListEl.appendChild(row);

						// eventos
						row.querySelector('#chk-'+id).addEventListener('change', e=>{
							toggleSat(id, e.target.checked);
						});
						row.querySelector('.zoomSat').addEventListener('click', ()=>{
							const sat = state.sats[id];
							if(sat && sat.marker){ map.flyTo(sat.marker.getLatLng(), 4, {duration:1.2, easeLinearity:0.25, animate:true}); }
						});
						const colorBtn = row.querySelector('.colorBtn');
						const colorInp = row.querySelector('#col-'+id);
						// color inicial del chip (asegurado por JS)
						colorBtn.style.setProperty('--col', s.color || '#ff3333');
						colorBtn.addEventListener('click', ()=> colorInp.click());
						colorInp.addEventListener('input', (e)=>{
							const c = e.target.value;
							const sat = state.sats[id];
							sat.color = c;
							if (sat.track)  sat.track.setStyle({ color:c });
							if (sat.circle) sat.circle.setStyle({ color:c, fillColor:c });
							// actualizar chip visual del botón
							colorBtn.style.setProperty('--col', c);
							STORAGE.save();
						});
							
						// editar TLE (prompt de 2 líneas)
						row.querySelector('.editTLE').addEventListener('click', ()=>{
							const s = state.sats[id];
							const curr = (s.l1||'')+'\n'+(s.l2||'');
							const text = prompt('Pega el TLE (2 líneas, empiezan por 1 y 2):', curr);
							if (!text) return;
							const parsed = parseTLEBlock(text);
							if (!parsed){ alert('TLE inválido'); return; }
							const sr = parseTwoline(parsed.l1, parsed.l2);
							if (!sr){ alert('TLE inválido'); return; }
							s.l1 = parsed.l1; s.l2 = parsed.l2; s.satrec = sr;
							computeTrack(id); updateSat(id);
							STORAGE.save();
						});
						
						// elegir icono (presets: sat/dot/tri o URL)
						row.querySelector('.iconBtn').addEventListener('click', ()=>{
							const s = state.sats[id];
							const keys = Object.keys(ICON_FILES).join(', ');
							let val = prompt(
								`Icono:\n- Escribe una clave: ${keys}\n- o pega una URL (PNG/SVG)\nActual:`,
								s.iconUrl || s.iconKey || 'sat1'
							);
							if (!val) return;
							val = val.trim();
							// compatibilidad por si escriben "sat"
							if (val.toLowerCase() === 'sat') val = 'sat1';
							const isUrl = /^(https?:|data:|\/)/i.test(val);
							if (isUrl) {
								s.iconUrl = val; s.iconKey = null;
							} else {
								s.iconKey = ICON_FILES[val] ? val : 'sat1';
								s.iconUrl = null;
							}
							if (s.marker) s.marker.setIcon(makeIcon(s.iconUrl || s.iconKey));
							STORAGE.save();
						});
						
						// eliminar satélite
						row.querySelector('.delSat').addEventListener('click', ()=>{
							removeSatellite(id);
						});
						
						// nombre editable al clic
						const nameEl = row.querySelector('.sat-name');
						nameEl.addEventListener('click', ()=>{
							nameEl.setAttribute('contenteditable','true');
							const sel = window.getSelection(); const r = document.createRange();
							r.selectNodeContents(nameEl); sel.removeAllRanges(); sel.addRange(r);
							nameEl.focus();
						});
						nameEl.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ ev.preventDefault(); nameEl.blur(); }});
						nameEl.addEventListener('blur', ()=>{
							nameEl.removeAttribute('contenteditable');
							const newName = nameEl.textContent.trim() || s.name;
							s.name = newName;
							if (s.marker && s.marker.getPopup()) s.marker.getPopup().setContent('<b>'+s.name+'</b>');
							else if (s.marker) s.marker.bindPopup('<b>'+s.name+'</b>');
							STORAGE.save();
						});
					}

					function addSatellite({id, name, l1, l2, color, visible, iconKey, iconUrl}){
 						const satrec = parseTwoline(l1, l2);
						if(!satrec){ alert('TLE inválido'); return; }
						const _id = id || uidFromName(name);
						if (state.sats[_id]) { /* evita duplicados si ya existiera */ return; }
						state.sats[_id] = {
							name, l1, l2, satrec,
							color: color || '#ff3333',
							iconKey: iconKey || 'sat1',
							iconUrl: iconUrl || null,
							marker:null, circle:null, track:null,
							visible: (visible === false ? false : true)
						};
						createSatRow(_id, state.sats[_id]);
						// fuerza primer tick/track
						updateSat(_id);
						computeTrack(_id);
						// respetar visibilidad restaurada
						if (visible === false) toggleSat(_id, false);
						// UI feedback
						const st = document.getElementById('status');
						if (st) st.textContent = `TLE: cargado (${Object.keys(state.sats).length} satélites)`;
						// guardar
						STORAGE.save();
					}
					
					function removeSatellite(id){
						const s = state.sats[id];
						if(!s) return;
						// elimina capas del mapa
						if (s.marker) { try{ map.removeLayer(s.marker); }catch(_){} }
						if (s.circle) { try{ map.removeLayer(s.circle); }catch(_){} }
						if (s.track)  { try{ map.removeLayer(s.track);  }catch(_){} }
						// borra del estado
						delete state.sats[id];
						// borra la fila
						const row = document.getElementById('row-'+id);
						if (row && row.parentNode) row.parentNode.removeChild(row);
						// feedback de estado
						const st = document.getElementById('status');
						const n  = Object.keys(state.sats).length;
						if (st) st.textContent = n ? `TLE: cargado (${n} satélites)` : 'TLE: esperando…';
						// guardar
						STORAGE.save();
					}

					if(addBtn){
						addBtn.addEventListener('click', ()=>{
							const name  = (nameInp.value || '').trim();
							const color = defColInp.value || '#ff3333';
							const parsed = parseTLEBlock(tleBlockInp.value || '');
							if (!name || !parsed){
								alert('Indica un nombre y pega un TLE válido (2 líneas que empiecen por 1 y 2).');
								return;
							}
							addSatellite({ name, l1: parsed.l1, l2: parsed.l2, color });
							// limpia y cierra
							nameInp.value = ''; tleBlockInp.value = '';
							try{ document.getElementById('addSatPanel').open = false; }catch(_){}
						});
					}
					
					// === HEARTBEAT global (1/min) ===
					const HEARTBEAT_MS = 60000;
					function heartbeat(){
						if (window.dayNightLayer) window.dayNightLayer.setTime(refNow());
						if (typeof buildTerminatorLine === 'function') buildTerminatorLine();
						if (typeof computeAllTracks === 'function') computeAllTracks();
						updateRadar();
						updateSatRV();
					}
					setInterval(heartbeat, HEARTBEAT_MS);

					// Si estamos en "Ahora", refresca el input visible cada segundo para que "corra" el reloj
					setInterval(()=>{
						if (!timeState.manual && refInput){
							refInput.value = toLocalDTValue(new Date());
						}
					// Actualiza el reloj UTC global cada segundo
					updateUTCStatus();
					}, 1000);
					
				});
			})();
		</script>
	</body>
</html>
