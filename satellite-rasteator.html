<!doctype html>
<html lang="es">
	<head>
		<meta charset="utf-8">
		<!-- Favicon (sat1) -->
		<link rel="icon" type="image/png" sizes="32x32" href="img/satellite-rasteator/icons/32/sat1.png">
		<link rel="icon" type="image/png" sizes="64x64" href="img/satellite-rasteator/icons/64/sat1.png">
		<link rel="apple-touch-icon" sizes="180x180" href="img/satellite-rasteator/icons/64/sat1.png">
		<!-- Color de la barra del navegador (se sincroniza por JS con el header) -->
		<meta name="theme-color" content="#0e1540">
		<!-- PWA en Android/Chrome -->
		<meta name="mobile-web-app-capable" content="yes">
		<!-- Solo añadimos el meta de Apple en iOS para evitar el warning en Chrome -->
		<script>
		(function(){
			const isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || (navigator.platform==='MacIntel' && navigator.maxTouchPoints>1);
			if (isiOS){
			var m = document.querySelector('meta[name="apple-mobile-web-app-capable"]');
			if(!m){ m = document.createElement('meta'); m.setAttribute('name','apple-mobile-web-app-capable'); document.head.appendChild(m); }
			m.setAttribute('content','yes');
			} else {
			const m = document.querySelector('meta[name="apple-mobile-web-app-capable"]');
			if (m) m.remove();
			}
		})();
		</script>
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Satellite Rasteator</title>
		<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
		<style>
			:root{ --bg:#0b1020; --panel:#121832; --text:#e6eef8; }
			/* Colores del scroll (puedes personalizarlos) */
			:root{
				--scroll-track: #0e1540;
				--scroll-thumb: #2a3a6b;
				--scroll-thumb-hover: #4a68c9;
				--scroll-corner: #0b1020;
			}
			html,body{height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; overflow-x:hidden} 
			#app{display:grid; grid-template-rows:auto 1fr; height:100%; position:relative}
			header{display:flex; gap:1rem; align-items:center; padding:.6rem 1rem; background:#0b1020; border-bottom:1px solid #1f284a}
			/* Icono de marca (sat1) antes del título */
			#brandIcon{
				width:32px; height:32px; flex:0 0 22px;
				image-rendering:auto; display:inline-block;
			}
			header h1{font-size:1.05rem; margin:0}
			header .actions{margin-left:auto; display:flex; gap:.5rem; align-items:center; flex-wrap:wrap} /* wrap en tablet */
			/* Botones toggle estilo “follow” */
			.btn-icon{
				display:inline-flex; align-items:center; justify-content:center;
				width:36px; height:36px; border-radius:.4rem; border:1px solid #2a3a6b;
				background:#0e1540; color:var(--text); cursor:pointer; padding:0;
			}
			.btn-icon svg{ width:18px; height:18px; pointer-events:none }
			.btn-icon.active{ box-shadow: inset 0 0 0 2px #6aa8ff; }
			/* Botón de acción solo icono (Ubicarme) */
			#locateMe.icon-only{ display:inline-flex; align-items:center; justify-content:center; width:36px; height:36px; padding:0 }
			/* Punto azul "mi ubicación" */
			.me-dot{
				width:14px; height:14px; border-radius:50%;
				background:#2a7bff; border:2px solid #fff;
				box-shadow:0 0 0 4px rgba(42,123,255,.25);
			}
			
			/* Botón Fullscreen (móvil): junto al ☰ */
			#fullScreenBtn{
				display:none; /* solo móvil */
				align-items:center; justify-content:center;
				padding: .45rem .6rem;
			}
			header button, header select{background:#11173a; color:var(--text); border:1px solid #26315c; padding:.45rem .7rem; border-radius:.5rem; cursor:pointer}
			#map{height:100%;}			
			.panel{
				position:absolute; top:60px; right:5px; bottom:25px; /* ← anclado arriba y abajo */
				width:300px; box-sizing: border-box;
				display:flex; flex-direction:column; /* ← layout en columna */
				background:var(--panel); border:1px solid #26315c; border-radius:12px;
				padding:.75rem; box-shadow:0 10px 30px rgba(0,0,0,.35); z-index:1000;
				transition:transform .25s ease, opacity .2s ease; will-change:transform, opacity;
				overflow:hidden; /* ← nada se desborda fuera del panel */
			}
			.panel h2{margin:.2rem 0 .6rem; font-size:1rem}
			/* resalta botón activo (seguir) */
			.sat-item .btn-icon.active{ box-shadow: inset 0 0 0 2px #6aa8ff; }
			
			.sat-item{
				display:grid;
				grid-template-columns:auto 1fr;   /* checkbox | info */
				grid-template-rows:auto auto;     /* info arriba, acciones debajo */
				gap:.5rem;
				align-items:center;
				padding:.45rem .5rem;
				border-radius:.6rem; border:1px solid #223059; margin-bottom:.45rem;
			}
			/* bloque de acciones debajo, a lo ancho (horizontal) */
			.sat-actions{
				grid-column: 1 / -1;
				display: flex;
				flex-direction: row;      /* ← horizontal */
				align-items: center;
				gap: .4rem;
				flex-wrap: wrap;          /* si no caben, saltan de línea */
				width: 100%;
				margin-top: .25rem;
			}
			
			/* alias por compatibilidad: forzamos horizontal, por si otra regla pisa */
			.sat-item .actions-col{ display:flex; flex-direction:row !important; align-items:center; gap:.4rem; flex-wrap:wrap }

			/* === Scroll interno solo en la lista === */
			#satList{
				flex:1 1 auto;             /* ocupa todo el espacio disponible */
				overflow:auto;              /* ← scroll aquí */
				overscroll-behavior:contain;
				margin-top:.4rem;
				/* Reserva siempre el canal del scrollbar para que no “salte” el layout */
				scrollbar-gutter: stable both-edges;
			}
			/* El bloque de “Añadir satélite” queda fijo al pie y nunca empuja el panel fuera */
			#addSatPanel{
				flex:0 0 auto;              /* altura natural; no crece */
				margin-top:.5rem;
				max-height:43vh;            /* por si lo abres, que no coma toda la columna */
				overflow:auto;              /* si hiciera falta, scrollea solo su contenido */
				scrollbar-gutter: stable;
			}
			#addSatPanel textarea{
				max-height:28vh;            /* evita que el textarea se haga enorme */
			}
			/* ===== Firefox: estilo de scroll ===== */
			#satList,
			#addSatPanel{
				scrollbar-width: thin; /* auto | thin | none */
				scrollbar-color: var(--scroll-thumb) transparent; /* pulgar | pista */
			}
			
			/* ===== Chromium / WebKit: estilo de scroll ===== */
			#satList::-webkit-scrollbar,
			#addSatPanel::-webkit-scrollbar{
				width: 10px;
				height: 10px;
			}
			#satList::-webkit-scrollbar-track,
			#addSatPanel::-webkit-scrollbar-track{
				background:
					linear-gradient(180deg, rgba(0,0,0,0) 0%, rgba(0,0,0,.12) 100%),
					var(--panel);
				border-radius: 8px;
				margin: 4px; /* deja respirar el canal al principio/fin */
			}
			#satList::-webkit-scrollbar-thumb,
			#addSatPanel::-webkit-scrollbar-thumb{
				background-color: var(--scroll-thumb);
				border-radius: 8px;
				border: 2px solid transparent;     /* crea un “acolchado” interno */
				background-clip: content-box;       /* mantiene el acolchado */
			}
			#satList::-webkit-scrollbar-thumb:hover,
			#addSatPanel::-webkit-scrollbar-thumb:hover{
				background-color: var(--scroll-thumb-hover);
			}
			#satList::-webkit-scrollbar-corner,
			#addSatPanel::-webkit-scrollbar-corner{
				background: var(--scroll-corner);
			}
			
			/* nombre editable (al clic) */
			.sat-item .sat-name{
				cursor:text;
				border-bottom:1px dashed rgba(230,238,248,.25);
			}
			.sat-item .sat-name:focus{ outline: none; background:#0c1330; }
			
			/* ===== Estilo “primario” para el botón Añadir del panel ===== */
			#addSatPanel #addSatBtn{
			  appearance: none;
			  border: 1px solid #2a3a6b;
			  background: linear-gradient(180deg, #1b2a6a, #101a46);
			  color: var(--text);
			  border-radius: .6rem;
			  padding: .55rem .9rem .55rem 2.1rem; /* hueco para el icono */
			  font-weight: 600;
			  letter-spacing: .2px;
			  position: relative;
			  cursor: pointer;
			  box-shadow:
				0 6px 18px rgba(0,0,0,.35),
				inset 0 0 0 1px rgba(255,255,255,.04);
			  transition: transform .08s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease, filter .2s ease;
			}

			/* Icono + “chip” luminoso a la izquierda (sin cambiar el HTML) */
			#addSatPanel #addSatBtn::before{
			  content: "+";
			  position: absolute;
			  left: .65rem; top: 50%;
			  transform: translateY(-50%);
			  width: 1.25rem; height: 1.25rem; line-height: 1.2rem;
			  border-radius: .4rem;
			  text-align: center;
			  font-weight: 700; font-size: 1rem;
			  color: #fff;
			  background: radial-gradient(100% 100% at 50% 50%, #3d8bfd 0%, #2a5be8 100%);
			  box-shadow: 0 2px 8px rgba(3,121,255,.45), inset 0 0 0 1px rgba(255,255,255,.15);
			}

			/* Estados */
			#addSatPanel #addSatBtn:hover{
			  filter: saturate(1.1) brightness(1.05);
			  box-shadow:
				0 10px 24px rgba(0,0,0,.45),
				inset 0 0 0 1px rgba(255,255,255,.06);
			}
			#addSatPanel #addSatBtn:active{
			  transform: translateY(1px) scale(.985);
			}
			#addSatPanel #addSatBtn:focus-visible{
			  outline: 2px solid #6aa8ff;
			  outline-offset: 2px;
			}
			#addSatPanel #addSatBtn:disabled{
			  opacity: .6;
			  cursor: not-allowed;
			  filter: grayscale(25%);
			}
			
			#addSatPanel #newIconBtn {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				width: 32px;
				height: 32px;
				border-radius: .4rem;
				border: 1px solid #2a3a6b;
				background: #0e1540;
				color: var(--text);
				cursor: pointer;
				padding: 0;
			}

			/* (Opcional) compacta el contenedor del botón + color para que se vea fino en pantallas pequeñas */
			#addSatPanel > div[style*="display:flex"]{
			  flex-wrap: wrap;
			  gap: .5rem .6rem !important;
			}
			
			.kv{font-size:.85rem; opacity:.9}
			/* En la ficha del satélite, respeta los saltos de línea (\n) */
			.sat-item .kv{
			  white-space: pre-line;   /* convierte \n en saltos de línea */
			  line-height: 1.25;
			}
						
			details{border:1px dashed #2a3a6b; border-radius:.6rem; padding:.4rem .6rem; margin-top:.5rem}
			textarea{width:100%; min-height:90px; background:#0c1330; color:var(--text); border:1px solid #2a3a6b; border-radius:.5rem; padding:.5rem; font-family:ui-monospace,Menlo,Consolas,monospace}
			.hint{font-size:.8rem; opacity:.7}
			/* Si quieres forzar SIN relleno para pruebas, descomenta:
			#map .terminator-line { fill: none !important; }
			*/
			/* Solo nubes (WMTS IR): el fondo oscuro desaparece, quedan píxeles claros (nubes) */
			.clouds-only img{
				mix-blend-mode: lighten;
				image-rendering:auto;
			}
			/* --- Panel colapsable --- */
			/* Estado colapsado: animamos fuera de la pantalla sin provocar overflow ni foco */
			.panel.collapsed{
				transform: translateX(calc(100% + 16px));
				opacity:0;
				pointer-events:none;
			}

			/* === Color picker en Añadir: igual aspecto que .btn-color === */
			#addSatPanel #defaultOrbitColor{
				appearance: none;
				-webkit-appearance: none;
				width: 32px;
				height: 32px;
				border-radius: .4rem;
				border: 1px solid #2a3a6b;
				background: #0e1540;     /* mismo fondo que los botones de la lista */
				padding: 0;
				cursor: pointer;
			}
			/* Chrome/Safari/Edge: elimina relleno y borde blanco del swatch */
			#addSatPanel #defaultOrbitColor::-webkit-color-swatch-wrapper{
				padding: 0;
				border-radius: .35rem;
			}
			#addSatPanel #defaultOrbitColor::-webkit-color-swatch{
				border: none;
				border-radius: .35rem;
			}
			/* Firefox */
			#addSatPanel #defaultOrbitColor::-moz-color-swatch{
				border: none;
				border-radius: .35rem;
			}
			/* Accesibilidad y hover, a juego con tus botones */
				#addSatPanel #defaultOrbitColor:hover{
				filter: saturate(1.05) brightness(1.05);
			}
			#addSatPanel #defaultOrbitColor:focus-visible{
				outline: 2px solid #6aa8ff;
				outline-offset: 2px;
			}
			
			/* Tamaños responsivos para que case con .btn-color en móvil/tablet */
			@media (max-width: 900px){
			#addSatPanel #defaultOrbitColor{ width: 32px; height: 32px; }
			}
			@media (max-width: 700px){
			#addSatPanel #defaultOrbitColor{ width: 36px; height: 36px; }
			}
			.panel .min-btn{
				position:absolute; top:8px; right:8px; border:1px solid #26315c; background:#0e1540;
				color:var(--text); border-radius:.5rem; padding:.25rem .5rem; cursor:pointer; font-size:.9rem;
			}
			/* Ocultación dura tras la animación (ya sin efecto) */
			.panel.collapsed-hidden{ display:none; }
			.panel-toggle{
				position:absolute; top:60px; right:5px; z-index:1001;
				border:1px solid #26315c; background:#11173a; color:var(--text);
				border-radius:.5rem; padding:.5rem .7rem; cursor:pointer; display:none; align-items:center; gap:.4rem;
				box-shadow:0 8px 24px rgba(0,0,0,.35);
			}
			.panel-toggle .dot{
				width:.6rem; height:.6rem; border-radius:999px; background:#5aa9ff; display:inline-block;
			}
			/* --- Botones icono en filas de satélites --- */
			.sat-item .btn-icon{
				display:inline-flex; align-items:center; justify-content:center;
				width:32px; height:32px; border-radius:.4rem; border:1px solid #2a3a6b;
				background:#0e1540; color:var(--text); cursor:pointer; padding:0;
			}
			.sat-item .btn-icon svg{ width:16px; height:16px; pointer-events:none }
			.sat-item .btn-danger{ border-color:#5a2a2a; background:#3a0e0e }
			/* Botón de color: muestra el color actual; con fallback por si no hay conic-gradient */
			.sat-item .btn-color{
				width:32px; height:32px; border-radius:.4rem; border:1px solid #2a3a6b;
				cursor:pointer; padding:0;
				background: var(--col, #ff3333);
				background: conic-gradient(from 0deg, var(--col, #ff3333), var(--col, #ff3333));
			}
			
			/* === Selector de iconos (popover) === */
			.icon-picker{
				position:fixed; z-index:2000; background:#0e1540; color:var(--text);
				border:1px solid #2a3a6b; border-radius:.6rem; box-shadow:0 12px 30px rgba(0,0,0,.45);
				padding:.5rem; width:220px; max-height:260px; overflow:auto;
			}
			.icon-picker h4{ margin:.1rem .1rem .4rem; font-size:.9rem; opacity:.85 }
			.icon-grid{
				display:grid; grid-template-columns:repeat(5, 1fr); gap:.35rem;
			}
			.icon-item{
				background:#0c1330; border:1px solid #2a3a6b; border-radius:.45rem;
				width:36px; height:36px; display:flex; align-items:center; justify-content:center;
				cursor:pointer;
			}
			.icon-item img{ width:24px; height:24px; image-rendering:auto }
			.icon-item[aria-selected="true"]{
				outline:2px solid #6aa8ff; outline-offset:1px;
				border-color:#6aa8ff;
			}
			.icon-picker .close-row{ display:flex; justify-content:flex-end; margin-top:.4rem }
			.icon-picker .close-btn{
				background:#11173a; border:1px solid #2a3a6b; color:var(--text);
				border-radius:.4rem; padding:.25rem .5rem; cursor:pointer;
			}
			
			/* === Picker de TLE (popover similar al de iconos) === */
			.tle-picker{
				position:fixed; z-index:2000; background:#0e1540; color:var(--text);
				border:1px solid #2a3a6b; border-radius:.6rem; box-shadow:0 12px 30px rgba(0,0,0,.45);
				padding:.6rem; width:460px; max-width:calc(100vw - 16px);
			}
			.tle-picker h4{ margin:.1rem .1rem .4rem; font-size:.95rem; opacity:.9 }
			.tle-picker .tle-area{
				width:96%; min-height:96px; resize:vertical;
				background:#0c1330; color:var(--text);
				border:1px solid #2a3a6b; border-radius:.45rem; padding:.5rem;
				font: 13px/1.35 ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
			}
			.tle-picker .meta{ display:flex; gap:.5rem; align-items:center; margin-top:.35rem; font-size:.85rem; opacity:.85 }
			.tle-picker .meta .pill{
				border:1px solid #2a3a6b; border-radius:.45rem; padding:.15rem .4rem; background:#0c1330;
			}
			.tle-picker .meta .ok{ color:#9fe29f; border-color:#2f5a2f }
			.tle-picker .meta .bad{ color:#ffb0b0; border-color:#5a2f2f }
			.tle-picker .actions{ display:flex; gap:.5rem; justify-content:flex-end; margin-top:.5rem }
			.tle-picker .btn{
				background:#11173a; border:1px solid #2a3a6b; color:var(--text);
				border-radius:.4rem; padding:.35rem .7rem; cursor:pointer;
			}
			.tle-picker .btn[disabled]{ opacity:.5; cursor:not-allowed }			
			
			/* Toggle (oculto por defecto en desktop) */
			.actions-toggle{
				display:none;
				margin-left:auto;
				background:#11173a;
				color:var(--text);
				border:1px solid #26315c;
				border-radius:.5rem;
				padding:.45rem .6rem;
				cursor:pointer;
				line-height:1;
			}
			
			/* ======= Responsivo: tablet y móvil ======= */
			@media (max-width: 1200px){
				header h1{ font-size:1rem }
				header .actions{ gap:.45rem }
				.panel{ width:300px; right:8px; bottom:20px; top:60px }
			}
			@media (max-width: 900px){
				header{ padding:.5rem .7rem }
				header h1{ font-size:.95rem; line-height: 2rem; }
				header button, header select, #refTime, #useNow{ font-size:.9rem; padding:.4rem .55rem }
				/* Mostrar el toggle y mandar acciones a la 2ª línea */
				.actions-toggle{ display:inline-flex; align-items:center; justify-content:center }
				#fullScreenBtn{ display:inline-flex; } /* aparece en móvil */
				header .actions{
					order:3;
					width:100%;
					display:flex;
					flex-wrap:wrap;
					gap:.45rem;
				}
				.panel{ width:300px; right:8px; bottom:18px; top:56px }
				/* botones más “tocables” en pantallas táctiles */
				.sat-item .btn-icon, .sat-item .btn-color{ width:32px; height:32px }
			}
			@media (max-width: 700px){
				/* En móvil: overlay fijo bajo el header (no empuja el layout) */
				header{ align-items:flex-start; gap:.5rem; position:relative }
				header .actions{ display:none }
				header .actions.open{
					display:flex;
					position: fixed;
					left: 0; right: 0;
					top: var(--actionsTop, 56px);   /* la fijamos desde JS al abrir */
					z-index: 1100;
					background: rgba(11,16,32,.98);
					border-bottom: 1px solid #1f284a;
					padding: .5rem .65rem;
					gap: .5rem;
					box-sizing: border-box;
					max-width: 100vw;               /* nunca más ancho que la pantalla */
					overflow-x: auto;               /* scroll horizontal si no cabe */
					overflow-y: hidden;
					-webkit-overflow-scrolling: touch;
					scrollbar-gutter: stable;
				}
				header .actions.open > *{ flex: 0 0 auto } /* que no intenten crecer/romper */
				header .actions.open::-webkit-scrollbar{ height:6px }
				/* Panel como “hoja” inferior, a ancho casi completo */
				.panel{
					right:5px; width:auto; max-width: 300px;
					top:auto; bottom:55px;            /* deja hueco para el botón flotante */
					max-height:83vh;
				}
				.panel-toggle{
					top:auto; right:6px; bottom:55px; /* botón para mostrar panel en móvil */
				}
				/* Botones más grandes para dedo */
				.sat-item .btn-icon, .sat-item .btn-color{ width:36px; height:36px }
				/* Ajustes del listado para pantallas estrechas */
				.sat-item{ gap:.45rem }
				#addSatPanel{ max-height:45vh }
				#addSatPanel textarea{ max-height:30vh }
			}
			@media (max-height: 540px){ /* paisaje de móvil: menos alto */
				.panel{ bottom:60px; max-height:55vh }
				#addSatPanel{ max-height:38vh }
			}
			
		</style>
	</head>
	<body>
		<div id="app">
			<header>
				<img id="brandIcon" src="img/satellite-rasteator/icons/32/sat1.png" alt="" aria-hidden="true">
 				<h1>Satellite Rasteator</h1>
				<button id="actionsToggle" class="actions-toggle" aria-label="Mostrar opciones">☰</button>
				<button id="fullScreenBtn" aria-label="Pantalla completa" title="Pantalla completa">
					<svg viewBox="0 0 24 24" width="15" height="15" aria-hidden="true">
						<path fill="currentColor" d="M 4 9 L 4 4 L 9 4 L 9 2 L 2 2 L 2 9 L 4 9 Z M 4 15 L 4 20 L 9 20 L 9 22 L 2 22 L 2 15 L 4 15 Z M 20 9 L 22 9 L 22 2 L 15 2 L 15 4 L 20 4 L 20 9 Z M 20 20 L 14.945 20 L 14.952 22 L 22.001 21.959 L 22.003 14.68 L 20 14.68 L 20 20 Z"/>
					</svg>
				</button>
				<div class="actions">

					<!-- Botón Ubicarme (toggle) -->
					<button id="locateMe" class="btn-icon" aria-pressed="false" title="Ubicarme">
						<svg viewBox="0 0 24 24" width="18" height="18" aria-hidden="true">
							<path fill="currentColor" d="M 11.007 1.99 L 13.002 1.998 L 12.998 3.953 C 16.266 4.036 19.975 7.678 20.001 10.999 L 22 11 L 22 12.998 L 20.001 12.996 C 19.932 16.036 16.553 19.9 13.001 20.001 L 12.998 21.999 L 10.996 21.993 L 10.997 20.002 C 7.66 19.944 4.008 16.162 3.999 12.997 L 2 13 L 2 10.999 L 3.999 10.995 C 4.039 7.891 7.56 4.024 10.995 3.958 L 11.007 1.99 Z M 12 7 C 8.151 7 5.745 11.167 7.67 14.5 C 9.594 17.833 14.406 17.833 16.33 14.5 C 16.769 13.74 17 12.878 17 12 C 16.997 9.24 14.76 7.003 12 7 Z M 12 9 C 14.309 9 15.753 11.5 14.598 13.5 C 13.443 15.5 10.557 15.5 9.402 13.5 C 9.139 13.044 9 12.527 9 12 C 9.002 10.344 10.344 9.002 12 9 Z"/>
						</svg>					
					</button>
					<!-- Día/Noche -->
					<button id="btnTerminator" class="btn-icon" aria-pressed="true" title="Día/Noche">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 2a10 10 0 1 0 10 10A8 8 0 0 1 12 2Z"/></svg>
					</button>
					<!-- Radar -->
					<button id="btnRadar" class="btn-icon" aria-pressed="true" title="Radar">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M12 3a9 9 0 1 0 9 9h-2a7 7 0 1 1-7-7V3Zm0 4a5 5 0 1 0 5 5h-2a3 3 0 1 1-3-3V7Z"/></svg>
					</button>
					<!-- Nubes -->
					<button id="btnClouds" class="btn-icon" aria-pressed="true" title="Nubes">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 18h11a4 4 0 0 0 0-8 5.5 5.5 0 0 0-10.4-2A4.5 4.5 0 0 0 6 18Z"/></svg>
					</button>
					<select id="baseSel">
						<option value="osm">OSM</option>
						<option value="light">Claro</option>
						<option value="dark">Oscuro</option>
						<option value="sat">Satélite</option>
					</select>
					<select id="trackHorizon">
						<option value="0">Sin traza</option>
						<option value="30">+30 min</option>
						<option value="60" selected>+60 min</option>
						<option value="90">+90 min</option>
					</select>
					<!-- Horizonte (huella) -->
					<button id="btnHorizon" class="btn-icon" aria-pressed="true" title="Horizonte">
						<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M 16.845 5.989 C 17.084 5.525 18.023 5.066 18.906 5.642 C 19.728 6.178 19.482 7.281 19.161 7.525 C 19.156 7.546 18.489 7.009 18.335 6.861 C 18.197 6.732 17.837 6.528 17.713 6.448 C 17.59 6.367 16.91 6.018 16.854 6.001 M 11.733 4.961 C 19.531 4.961 24.319 12.513 20.504 18.472 C 16.693 24.428 20.103 8.377 11.399 6.131 C 10.83 5.983 10.299 5.933 8.938 6.033 C 8.632 6.056 6.522 6.558 5.025 7.907 C 3.298 9.463 2.277 11.763 2.091 12.224 C 1.869 12.775 1.618 13.864 1.675 13.884 C 4.977 15.07 18.856 19.56 18.864 19.683 C 18.872 19.772 1.592 14.051 1.602 13.97 C 2.202 9.028 6.143 4.969 11.733 4.961"/></svg>
					</button>
					<input type="datetime-local" id="refTime" step="1" style="background:#11173a;color:#e6eef8;border:1px solid #26315c;border-radius:.5rem;padding:.45rem .5rem" />
					<button id="useNow">Ahora</button>
				</div>
			</header>
			
			<div id="map"></div>

			<div class="panel">
				<button class="min-btn" id="minimizePanel" title="Ocultar panel">⮞</button>
				<h2>Estado</h2>
				<div class="kv" id="status">TLE: esperando…</div>
				<div class="kv" id="timeStatus">Tiempo ref: auto (reloj del sistema)</div>
				<div class="kv" id="utcStatus">UTC: —</div>
				
				<!-- Filtro rápido por nombre -->
				<div style="margin-top:.35rem">
					<input id="satFilter" placeholder="Filtrar satélites…" 
						style="width:93%;background:#0c1330;color:var(--text);border:1px solid #2a3a6b;border-radius:.5rem;padding:.45rem .55rem" />
				</div>
				
				<!-- Lista dinámica de satélites -->
				<div id="satList"></div>
				
				<details id="addSatPanel">
					<summary>➕ Añadir satélite (TLE)</summary>
					<p class="hint">Introduce el <b>nombre</b> y pega el TLE completo en un único campo (2 líneas empezando por <code>1</code> y <code>2</code>).</p>
					<label>Nombre del satélite</label>
					<input id="satName" placeholder="Ej: SENTINEL-2A" style="width:100%;background:#0c1330;color:var(--text);border:1px solid #2a3a6b;border-radius:.5rem;padding:.5rem" />
					<label style="display:block;margin-top:.5rem">TLE (2 líneas)</label>
					<textarea id="tleBlock" placeholder="1 42063U 17013A ...&#10;2 42063 98.5661 ..."></textarea>
					<!-- Estado de validación del TLE pegado -->
					<div id="addTleInfo" class="hint" style="margin:.25rem 0 .35rem">
						<span id="addLen">—</span> · <span id="addL1">L1: —</span> · <span id="addL2">L2: —</span> · <span id="addState">Estado: esperando…</span>
					</div>
					<div style="display:flex;align-items:center;gap:.5rem">
						<button id="addSatBtn">Añadir</button>
						<button id="newIconBtn" class="btn-icon" title="Elegir icono"></button>
						<input type="color" id="defaultOrbitColor" value="#ff3333" title="Color de órbita por defecto" />					
					</div>
				</details>
			</div>
			
			<!-- Botón flotante para reabrir el panel -->
			<button id="panelToggle" class="panel-toggle" aria-label="Mostrar panel"><span class="dot"></span> Panel</button>
		</div>
		
		<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
		<script src="https://unpkg.com/satellite.js/dist/satellite.min.js"></script>
		<script>
			(function(){
				const MERC_MAX = 85.05112878;
				
				function ready(fn){ if(document.readyState!=='loading') fn(); else document.addEventListener('DOMContentLoaded', fn); }
				
				ready(function(){
				
					// Toggle de acciones en móvil
					const actionsToggle = document.getElementById('actionsToggle');
					const actionsBar = document.querySelector('header .actions');
					const headerEl = document.querySelector('header');
					if (actionsToggle && actionsBar){
						actionsToggle.addEventListener('click', ()=>{
							// Calcula el borde inferior del header para anclar el overlay
							const rect = headerEl.getBoundingClientRect();
							document.documentElement.style.setProperty('--actionsTop', `${Math.round(rect.bottom)}px`);
							actionsBar.classList.toggle('open');
						});

						// Cerrar al clicar fuera (solo en móvil)
						document.addEventListener('click', (e)=>{
							if (window.innerWidth > 700) return;
							if (!actionsBar.classList.contains('open')) return;
							const inside = actionsBar.contains(e.target) || actionsToggle.contains(e.target);
							if (!inside) actionsBar.classList.remove('open');
						});
						// Cerrar con Escape / al redimensionar / cambiar orientación
						window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') actionsBar.classList.remove('open'); });
						window.addEventListener('resize', ()=> actionsBar.classList.remove('open'));
						window.addEventListener('orientationchange', ()=> actionsBar.classList.remove('open'));
					}
					
					// === Sincroniza <meta name="theme-color"> con el color real del header ===
					(function syncThemeColorWithHeader(){
						const meta = document.querySelector('meta[name="theme-color"]') || (()=>{ const m=document.createElement('meta'); m.setAttribute('name','theme-color'); document.head.appendChild(m); return m; })();
						const header = document.querySelector('header');
						if(!header) return;
						function rgbToHex(rgb){
							// rgb(14, 21, 64)  |  rgba(14, 21, 64, 0.9)
							const m = rgb.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)(?:\s*,\s*[\d.]+)?\s*\)/i);
							if(!m) return '#0e1540';
							return '#' + [m[1],m[2],m[3]].map(n => Number(n).toString(16).padStart(2,'0')).join('');
						}
						function apply(){
							const bg = getComputedStyle(header).backgroundColor;
							meta.setAttribute('content', rgbToHex(bg));
						}
						apply();
						// Reaplica si el sistema cambia de tema o si algo toca el estilo
						window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').addEventListener?.('change', apply);
					})();
					
					// === Botón Pantalla Completa (móvil) ===
					(function initFullscreen(){
						const btn = document.getElementById('fullScreenBtn');
						if(!btn) return;
						const appEl = document.getElementById('app') || document.documentElement;
						const ENTER_ICON = '<svg viewBox="0 0 24 24" width="15" height="15" aria-hidden="true"><path fill="currentColor" d="M 4 9 L 4 4 L 9 4 L 9 2 L 2 2 L 2 9 L 4 9 Z M 4 15 L 4 20 L 9 20 L 9 22 L 2 22 L 2 15 L 4 15 Z M 20 9 L 22 9 L 22 2 L 15 2 L 15 4 L 20 4 L 20 9 Z M 20 20 L 14.945 20 L 14.952 22 L 22.001 21.959 L 22.003 14.68 L 20 14.68 L 20 20 Z"/></svg>';
						const EXIT_ICON  = '<svg viewBox="0 0 24 24" width="15" height="15" aria-hidden="true"><path fill="currentColor" d="M 9 3 L 7 3 L 7 7 L 3 7 L 3 9 L 9 9 L 9 3 Z M 17 7 L 17 3 L 15 3 L 15 9 L 21 9 L 21 7 L 17 7 Z M 7 21 L 9.003 21 L 9 15 L 3 15 L 3 17 L 7 17 L 7 21 Z M 21 15 L 15 15 L 15 21 L 17 21 L 17 17 L 21 17 L 21 15 Z"/></svg>';
						function isFs(){
							return document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
						}
						function refresh(){
							btn.title = isFs() ? 'Salir de pantalla completa' : 'Pantalla completa';
							btn.setAttribute('aria-label', btn.title);
							btn.innerHTML = isFs() ? EXIT_ICON : ENTER_ICON;
						}
						async function enterFs(){
							const el = appEl;
							try{
								if (el.requestFullscreen) await el.requestFullscreen();
								else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen(); // iOS Safari
								else if (el.msRequestFullscreen) await el.msRequestFullscreen();
							}catch(_){}
							refresh();
						}
						async function exitFs(){
							try{
								if (document.exitFullscreen) await document.exitFullscreen();
								else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
								else if (document.msExitFullscreen) await document.msExitFullscreen();
							}catch(_){}
							refresh();
						}
						btn.addEventListener('click', ()=>{
							isFs() ? exitFs() : enterFs();
						});
						document.addEventListener('fullscreenchange', refresh);
						document.addEventListener('webkitfullscreenchange', refresh);
						refresh();
					})();
				
					// --- MAPA (zoom/pan suaves) ---
					const map = L.map('map', {
						zoomControl: false,        // ← sin botones +/−
						worldCopyJump: false,
						// Zoom de rueda más fluido y con pasos fraccionados
						scrollWheelZoom: true,
						wheelDebounceTime: 25,       // respuesta rápida
					           wheelPxPerZoomLevel: 140,
					           // <-- pasos de 0.5 niveles
					           zoomSnap: 0.5,
					           zoomDelta: 0.5,
						zoomAnimation: true,
						zoomAnimationThreshold: 8,   // anima incluso saltos más grandes
						// Gestos táctiles/teclado centrados y panning con inercia suave
						touchZoom: 'center',
						doubleClickZoom: false,   // desactivamos el nativo (+1)
						inertia: true,
						inertiaDeceleration: 2500,
						inertiaMaxSpeed: 1500,
						easeLinearity: 0.2,
						 maxZoom: 22, minZoom: 2
					}).setView([0,0], 2);
					
					// Doble clic personalizado: +0.5 alrededor del punto clicado
					map.on('dblclick', (e) => {
						const next = Math.min(map.getMaxZoom(), map.getZoom() + 0.5);
						// setZoomAround mantiene el centro en el lugar del clic
						map.setZoomAround(e.latlng, next);
					});
					
					// --- Panel colapsable ---
					const panelEl = document.querySelector('.panel');
					const btnMin  = document.getElementById('minimizePanel');
					const btnFab  = document.getElementById('panelToggle');
					function setPanelCollapsed(collapsed){
						if(collapsed){
							// Quita ocultación dura para permitir la animación de salida si venía visible
							panelEl.classList.remove('collapsed-hidden');
							// Marca ARIA/inert para evitar foco y eventos mientras está fuera
							panelEl.setAttribute('aria-hidden','true');
							panelEl.setAttribute('inert','');
							// Activa animación hacia la derecha
							panelEl.classList.add('collapsed');
							// Cuando termine la transición, aplica ocultación dura
							const onEnd = (ev)=>{
								if(ev.propertyName !== 'transform') return;
								panelEl.classList.add('collapsed-hidden');
								panelEl.removeEventListener('transitionend', onEnd);
							};
							panelEl.addEventListener('transitionend', onEnd);
							btnFab.style.display = 'inline-flex';
						}else{
							// Quita ocultación dura y fuerza reflow para que se anime al entrar
							panelEl.classList.remove('collapsed-hidden');
							// Fuerza reflow para reiniciar la transición de 'transform'
							void panelEl.offsetWidth;
							panelEl.classList.remove('collapsed');
							// Restablece ARIA/inert
							panelEl.removeAttribute('aria-hidden');
							panelEl.removeAttribute('inert');
							btnFab.style.display = 'none';
						}
						try{ localStorage.setItem('panelCollapsed', collapsed ? '1' : '0'); }catch(e){}
					}
					// eventos
					if(btnMin) btnMin.addEventListener('click', ()=> setPanelCollapsed(true));
					if(btnFab) btnFab.addEventListener('click', ()=> setPanelCollapsed(false));
					// restaurar estado
					try{
						const saved = localStorage.getItem('panelCollapsed');
						if(saved === '1'){
							// Arrancar directamente oculto sin animar en el primer paint
							panelEl.classList.add('collapsed','collapsed-hidden');
							panelEl.setAttribute('aria-hidden','true');
							panelEl.setAttribute('inert','');
							btnFab.style.display = 'inline-flex';
						}
					}catch(e){}
										
					const baseCommonOpts = {
						maxNativeZoom: 19,   // detalle real de OSM
						maxZoom: 22,         // permite reescalar hasta 22
						updateWhenZooming: true, // actualiza durante la animación
						updateWhenIdle: false,   // prioriza fluidez
						keepBuffer: 3           // tiles alrededor para evitar parpadeos
					};
					const baseOSM   = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
						{ ...baseCommonOpts, maxNativeZoom: 19, attribution: 'OpenStreetMap contributors' }).addTo(map);
					const baseLight = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',
						{ ...baseCommonOpts, maxNativeZoom: 20, attribution: 'OpenStreetMap & CARTO' });
					const baseDark  = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png',
						{ ...baseCommonOpts, maxNativeZoom: 20, attribution: 'OpenStreetMap & CARTO' });

					// Base satélite (Esri World Imagery)
					const baseSat   = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
						{ ...baseCommonOpts,  maxNativeZoom: 19, attribution: 'Tiles &copy; Esri — Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community' });
					
					// Llevar control de la base actual para no borrar overlays al cambiar
					let currentBase = baseOSM;
								
					// ----- Estado de tiempo de referencia (auto vs manual) -----
					const timeState = { manual:false, value:new Date() };
					function refNow(){ return timeState.manual ? new Date(timeState.value) : new Date(); }
					// Formatea para <input type="datetime-local"> (zona local, sin 'Z')
					function toLocalDTValue(d){
						const pad = n => String(n).padStart(2,'0');
						const y=d.getFullYear(), m=pad(d.getMonth()+1), day=pad(d.getDate());
						const hh=pad(d.getHours()), mm=pad(d.getMinutes()), ss=pad(d.getSeconds());
						return `${y}-${m}-${day}T${hh}:${mm}:${ss}`;
					}
					// Actualiza el label de estado
					function updateTimeStatus(){
						const el = document.getElementById('timeStatus'); if(!el) return;
						if(timeState.manual){
							const d = refNow();
							el.textContent = `Tiempo ref: manual → ${d.toLocaleString()} (local) | ${d.toISOString().replace('T',' ').replace('Z',' UTC')}`;
						} else {
							el.textContent = 'Tiempo ref: auto (reloj del sistema)';
						}
						updateUTCStatus(); // sincroniza la línea de UTC global
					}
					
					// Línea global de UTC bajo "Estado"
					function updateUTCStatus(){
						const u = document.getElementById('utcStatus'); if(!u) return;
						const d = refNow();
						u.textContent = 'UTC: ' + d.toISOString().replace('T',' ').replace('Z',' UTC');
					}
					
					// Recalcula todo cuando cambia el tiempo de referencia
					function applyRefTime(){
						if(window.dayNightLayer) window.dayNightLayer.setTime(refNow());
						if(typeof buildTerminatorLine === 'function') buildTerminatorLine();
						if(typeof tick === 'function') tick();
						if(typeof computeAllTracks === 'function') computeAllTracks();
						updateTimeStatus();
						updateUTCStatus();
					}
									
					// === Panes por orden: satélites > órbitas > día/noche > radar > nubes > mapa ===
					
					// Pane para satélites (TOP map panes)
					let satPane = map.getPane('satPane');
					if (!satPane) { map.createPane('satPane'); satPane = map.getPane('satPane'); }
					satPane.style.zIndex = '750';       // 1) SATÉLITES (más alto de los panes del mapa)
					satPane.style.pointerEvents = 'auto';
					
					// 2) ÓRBITAS (polylines/círculos)
					let orbitPane = map.getPane('orbitPane');
					if(!orbitPane){ map.createPane('orbitPane'); orbitPane = map.getPane('orbitPane'); }
					orbitPane.style.zIndex = '720';
					orbitPane.style.pointerEvents = 'none';

					// 4) DÍA/NOCHE (terminator)
					let paneEl = map.getPane('terminatorPane');
					if(!paneEl){ map.createPane('terminatorPane'); paneEl = map.getPane('terminatorPane'); }
					paneEl.style.zIndex = '500';
					paneEl.style.pointerEvents = 'none';

					// 5) RADAR (RainViewer)
					let radarPane = map.getPane('radarPane');
					if(!radarPane){ map.createPane('radarPane'); radarPane = map.getPane('radarPane'); }
					radarPane.style.zIndex = '390';
					radarPane.style.pointerEvents = 'none';

					// 6) NUBES (Sat IR)
					let cloudsPane = map.getPane('cloudsPane');
					if(!cloudsPane){ map.createPane('cloudsPane'); cloudsPane = map.getPane('cloudsPane'); }
					cloudsPane.style.zIndex = '380';
					cloudsPane.style.pointerEvents = 'none';								
														
														
					// ========================= RainViewer (sin TimeDimension) =========================
					// Usamos la API pública para obtener la lista de frames y elegimos:
					//  - si "Ahora": el frame MÁS RECIENTE disponible
					//  - si manual:  el frame más cercano ≤ refTime()
					const RAINV_META_URL = 'https://api.rainviewer.com/public/weather-maps.json';
					
					// Radar
					let rainv = {
						host: 'https://tilecache.rainviewer.com',
						frames: [],           // [{time, path}, ...] (segundos desde epoch)
						layer: null,
						lastUrl: '',
						_lastMeta: 0
					};
					// Satélite (infrared)
					let satv = {
						host: 'https://tilecache.rainviewer.com',
						frames: [],           // [{time, path}, ...]
						layer: null,
						lastUrl: '',
						_lastMeta: 0
					};
					
					function fetchRainMeta(){
						return fetch(RAINV_META_URL, { cache: 'no-store' })
						.then(r => r.json())
						.then(j => {
							const host = j?.host || rainv.host;
							rainv.host = host; satv.host = host;
							// Radar
							const past = Array.isArray(j?.radar?.past) ? j.radar.past : [];
							const nowc = Array.isArray(j?.radar?.nowcast) ? j.radar.nowcast : [];
							rainv.frames = past.concat(nowc).sort((a,b)=>a.time-b.time);
							rainv._lastMeta = Date.now();
							// Satélite (infrared)
							const infrared = Array.isArray(j?.satellite?.infrared) ? j.satellite.infrared : [];
							satv.frames = infrared.sort((a,b)=>a.time-b.time);
							satv._lastMeta = Date.now();
						})
						.catch(()=>{ /* silencio: sin conexión o CORS */ });
					}
					
					function pickBestFrame(frames, date){
						if (!frames.length) return null;
						const ts = Math.floor(date.getTime()/1000);
						if (!timeState.manual){
							// "Ahora": el último frame disponible
							return frames[frames.length-1];
						}
						// Manual: el frame más cercano que no supere refTime
						let best = frames[0];
						for (const f of frames){
							if (f.time <= ts) best = f; else break;
						}
						return best;
					}
					
					// Construye URL de teselas a partir de "path" de RainViewer
					// Formato: {host}{path}/256/{z}/{x}/{y}/{color}/{smooth}_{snow}.png
					// Elegimos color 3 (The Weather Channel), smooth=1, snow=1
					function pathToTileUrl(path){
						return `${rainv.host}${path}/256/{z}/{x}/{y}/3/1_1.png`;
					}
					
					function ensureRadar(){
					// Capa vacía al inicio; se rellena con setUrl cuando tengamos meta+frame
						if (!rainv.layer){
							rainv.layer = L.tileLayer('', {
								pane: 'radarPane',   // 5) radar por encima de nubes
								updateWhenZooming: true,
								updateWhenIdle: false,
								opacity: 0.85,
								maxNativeZoom: 9,   // límite actual de RainViewer
								maxZoom: 22,
								noWrap: true,
								crossOrigin: true,
								attribution: 'Radar © RainViewer'
							}).addTo(map);
						}
						// Carga metadatos (si hace >2 min que no actualizamos) y ajusta frame
						const needMeta = (Date.now() - rainv._lastMeta) > 120000 || !rainv.frames.length;
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(rainv.frames, refNow());
						if (!f) return;
						const url = pathToTileUrl(f.path);
						if (url !== rainv.lastUrl){
							rainv.layer.setUrl(url);
							rainv.lastUrl = url;
						}
						if (map.hasLayer(rainv.layer)) rainv.layer.bringToFront();
						// Mantén el terminador arriba
						if (window.dayNightLayer) window.dayNightLayer.bringToFront(); if (window.ringLine) window.ringLine.bringToFront();
						});
					}
					
					function updateRadar(){
						// Si estamos en "Ahora", refresca metadatos de vez en cuando
						const needMeta = !timeState.manual && ((Date.now() - rainv._lastMeta) > 120000);
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(rainv.frames, refNow());
						if (!f) return;
						const url = pathToTileUrl(f.path);
						if (url !== rainv.lastUrl){
							rainv.layer.setUrl(url);
							rainv.lastUrl = url;
						}
						});
					}
					
					// Inicializa radar
					ensureRadar();
					
					// ------------------------- Nubes (Satélite IR) -------------------------
					// color=0 (grayscale IR), usamos clase 'clouds-only' para blend "solo nubes"
					function pathToSatUrl(path){
						return `${satv.host}${path}/256/{z}/{x}/{y}/0/1_1.png`;
					}
					
					function ensureSatRV(){
					if (!satv.layer){
					satv.layer = L.tileLayer('', {
						pane: 'cloudsPane',      // 6) nubes por debajo de radar
						updateWhenZooming: true,
						updateWhenIdle: false,
						className: 'clouds-only',   // mix-blend-mode: lighten
						opacity: 0.95,
						maxNativeZoom: 9,
						maxZoom: 22,
						noWrap: true,
						crossOrigin: true,
						attribution: 'Satélite © RainViewer'
					}).addTo(map);
					}
					const needMeta = (Date.now() - satv._lastMeta) > 120000 || !satv.frames.length;
					const p = needMeta ? fetchRainMeta() : Promise.resolve();
					p.then(()=>{
					const f = pickBestFrame(satv.frames, refNow());
					if (!f) return;
					const url = pathToSatUrl(f.path);
					if (url !== satv.lastUrl){
						satv.layer.setUrl(url);
						satv.lastUrl = url;
					}
					if (map.hasLayer(satv.layer)) satv.layer.bringToFront();
					// Mantén el terminador arriba
						if (window.dayNightLayer) window.dayNightLayer.bringToFront(); if (window.ringLine) window.ringLine.bringToFront();
					});
					}
					
					function updateSatRV(){
						const needMeta = !timeState.manual && ((Date.now() - satv._lastMeta) > 120000);
						const p = needMeta ? fetchRainMeta() : Promise.resolve();
						p.then(()=>{
						const f = pickBestFrame(satv.frames, refNow());
						if (!f) return;
						const url = pathToSatUrl(f.path);
						if (url !== satv.lastUrl){
							satv.layer.setUrl(url);
							satv.lastUrl = url;
						}
						});
					}
					
					// Inicializa nubes satélite
					ensureSatRV();
					
					// Toggle mostrar/ocultar
					
					// --- Centraliza el orden de capas dentro de cada pane ---
					// (Los zIndex de los panes ya fijan el orden global)
					function restoreOrder(){
						if (satv.layer  && map.hasLayer(satv.layer))   satv.layer.bringToFront();   // Nubes
						if (rainv.layer && map.hasLayer(rainv.layer))  rainv.layer.bringToFront();  // Radar
						if (window.ringLine)      window.ringLine.bringToFront();                   // Terminador (SVG)
						if (window.dayNightLayer) window.dayNightLayer.bringToFront();              // Terminador (tiles)
					}					
					
					// === Toggles como botones con icono ===
					const termBtn   = document.getElementById('btnTerminator');
					const radarBtn  = document.getElementById('btnRadar');
					const cloudsBtn = document.getElementById('btnClouds');
					const horizBtn  = document.getElementById('btnHorizon');
					function setBtn(btn, on){ if(!btn) return; btn.classList.toggle('active', !!on); btn.setAttribute('aria-pressed', on?'true':'false'); }
					function isOn(btn){ return !!(btn && btn.classList.contains('active')); }
					function applyTerm(on){
						setBtn(termBtn, on);
						if (on){ if (dayNightLayer) dayNightLayer.addTo(map); if (ringLine) ringLine.addTo(map); }
						else { if (dayNightLayer) map.removeLayer(dayNightLayer); if (ringLine) map.removeLayer(ringLine); }
						// reponer overlays activos al frente
						if (on){
							if (isOn(radarBtn)  && rainv?.layer){ rainv.layer.addTo(map); }
							if (isOn(cloudsBtn) && satv?.layer){ satv.layer.addTo(map); }
							restoreOrder?.();
						}
						try{ localStorage.setItem('sr.t.term', on?'1':'0'); }catch(_){}
					}
					function applyRadar(on){
						setBtn(radarBtn, on);
						if (on){ if (rainv.layer){ rainv.layer.addTo(map); rainv.layer.bringToFront(); } }
						else { if (rainv.layer) map.removeLayer(rainv.layer); }
						try{ localStorage.setItem('sr.t.radar', on?'1':'0'); }catch(_){}
					}
					function applyClouds(on){
						setBtn(cloudsBtn, on);
						if (on){ if (satv.layer){ satv.layer.addTo(map); satv.layer.bringToFront(); } }
						else { if (satv.layer) map.removeLayer(satv.layer); }
						try{ localStorage.setItem('sr.t.clouds', on?'1':'0'); }catch(_){}
					}
					function applyHorizon(on){
						setBtn(horizBtn, on);
						try{ localStorage.setItem('sr.t.horiz', on?'1':'0'); }catch(_){}
						for (const id in state.sats){
							const s = state.sats[id];
							// asegúrate de tener círculo calculado si está ON
							if (on){ updateSat(id); }
							if (!s.circle) continue;
							if (on && s.visible !== false){ if(!map.hasLayer(s.circle)) s.circle.addTo(map); }
							else { if(map.hasLayer(s.circle)) map.removeLayer(s.circle); }
						}
					}
					termBtn?.addEventListener('click',  ()=> applyTerm(!isOn(termBtn)));
					radarBtn?.addEventListener('click', ()=> applyRadar(!isOn(radarBtn)));
					cloudsBtn?.addEventListener('click',()=> applyClouds(!isOn(cloudsBtn)));
					horizBtn?.addEventListener('click', ()=> applyHorizon(!isOn(horizBtn)));
					
					// Inicializa el input con la hora actual (local) — AHORA sí, tras definir toLocalDTValue/applyRefTime
					const refInput = document.getElementById('refTime');
					if(refInput){
						refInput.value = toLocalDTValue(new Date());
						refInput.addEventListener('change', () => {
							const v = refInput.value;        // "YYYY-MM-DDTHH:mm[:ss]"
							if(!v) return;
							const d = new Date(v);           // interpretado en LOCAL
							if(isNaN(d.getTime())) return;
							timeState.manual = true;
							timeState.value  = d;
							applyRefTime();
							updateRadar();                   // sincroniza radar al nuevo frame
							updateSatRV();                   // sincroniza nubes al nuevo frame
						});
					}

					
					// Botón "Ahora" → vuelve a automático
					const useNowBtn = document.getElementById('useNow');
					if(useNowBtn){
						useNowBtn.addEventListener('click', () => {
							timeState.manual = false;
							timeState.value  = new Date();
							if(refInput) refInput.value = toLocalDTValue(new Date());
							applyRefTime();
							updateRadar();
							updateSatRV();
						});
					}
				
					document.getElementById('baseSel').addEventListener('change', (e)=>{
						const v = e.target.value;
						const nextBase = (v==='light' ? baseLight : v==='dark' ? baseDark : v==='sat' ? baseSat : baseOSM);
						if (currentBase && map.hasLayer(currentBase)) map.removeLayer(currentBase);
						nextBase.addTo(map);
						currentBase = nextBase;

						try{ localStorage.setItem('sr.base', v); }catch(_){}
						restoreOrder();
					});
				
					// --- DÍA/NOCHE por tiles (GridLayer Canvas) ---
					let dayNightLayer = null; window.dayNightLayer = null;
					let ringLine = null;      window.ringLine     = null;
				
					const rad = x => x*Math.PI/180;
					const deg = x => x*180/Math.PI;
					const normLon = d => { while(d<-180) d+=360; while(d>180) d-=360; return d; };
					const jdFromDate = date => date.getTime()/86400000 + 2440587.5;
				
					function subsolar(date){
						const JD = jdFromDate(date);
						const T = (JD - 2451545.0)/36525.0;
						let L0 = 280.46646 + 36000.76983*T + 0.0003032*T*T; L0 = ((L0%360)+360)%360;
						const M  = 357.52911 + 35999.05029*T - 0.0001537*T*T; const Mr = rad(M);
						const C  = (1.914602 - 0.004817*T - 0.000014*T*T)*Math.sin(Mr)
								+ (0.019993 - 0.000101*T)*Math.sin(2*Mr)
								+ 0.000289*Math.sin(3*Mr);
						const lambda = L0 + C; const Omega = 125.04 - 1934.136*T;
						const lambdaApp = lambda - 0.00569 - 0.00478*Math.sin(rad(Omega));
						const eps0 = 23 + 26/60 + 21.448/3600 - (46.8150/3600)*T - (0.00059/3600)*T*T + (0.001813/3600)*T*T*T;
						const eps  = eps0 + 0.00256*Math.cos(rad(Omega));
						const epsr = rad(eps), lamr = rad(lambdaApp);
						const alpha = Math.atan2(Math.cos(epsr)*Math.sin(lamr), Math.cos(lamr));
						const delta = Math.asin(Math.sin(epsr)*Math.sin(lamr));
						let Theta = 280.46061837 + 360.98564736629*(JD - 2451545.0) + 0.000387933*T*T - T*T*T/38710000.0;
						Theta = ((Theta%360)+360)%360;
						const alphaDeg = ((deg(alpha)%360)+360)%360;
						const lon = normLon(alphaDeg - Theta);
						const lat = deg(delta);
						return { lat, lon };
					}
				
					// GridLayer: usa paso dinámico según zoom para rendimiento
					const DayNight = L.GridLayer.extend({
					initialize: function(opts){ L.setOptions(this, opts||{}); this._sun = subsolar(new Date()); },
					setTime: function(date){ this._sun = subsolar(date); this.redraw(); },
					createTile: function(coords, done){
						const tile = L.DomUtil.create('canvas','leaflet-tile');
						const size = this.getTileSize(); tile.width = size.x; tile.height = size.y;
						const ctx = tile.getContext('2d');
						const z = this._map ? this._map.getZoom() : 2;
						// Más grueso a zoom bajos para ahorrar CPU, más fino con zoom altos
						const step = Math.max(2, 10 - Math.min(8, Math.floor(z))); // 8→2 px aprox.
						const origin = coords.scaleBy(size);
						ctx.fillStyle = '#000000';
						const opacity = (typeof this.options.opacity === 'number') ? this.options.opacity : 0.8;
						const s = this._sun; const sphi = rad(s.lat), slam = rad(s.lon);
						const sx = Math.cos(sphi)*Math.cos(slam), sy = Math.cos(sphi)*Math.sin(slam), sz = Math.sin(sphi);
						for (let y=0; y<size.y; y+=step){
						for (let x=0; x<size.x; x+=step){
							const ll = this._map.unproject(L.point(origin.x + x + step/2, origin.y + y + step/2));
							const phi = rad(ll.lat), lam = rad(ll.lng);
							const nx = Math.cos(phi)*Math.cos(lam), ny = Math.cos(phi)*Math.sin(lam), nz = Math.sin(phi);
							const cosz = nx*sx + ny*sy + nz*sz; // >0 día, <0 noche
							if (cosz < 0){ ctx.globalAlpha = opacity; ctx.fillRect(x, y, step, step); }
						}
						}
						ctx.globalAlpha = 1;
						if(done) done(null, tile);
						return tile;
					}
					});
				
					dayNightLayer = new DayNight({ tileSize: 256, opacity: 0.8, pane:'terminatorPane' }).addTo(map);
					window.dayNightLayer = dayNightLayer;
					dayNightLayer.setTime(refNow()); // ← sincroniza con la hora de referencia al inicio
				
					// Re-mapea una longitud para que quede "cerca" de una de referencia (evita saltos de 360°)
					function unwrapLon(lon, ref){
						let x = lon;
						while (x - ref > 180)  x -= 360;
						while (x - ref < -180) x += 360;
						return x;
						}
						// Envuelve de vuelta a [-180, 180]
						function wrapLon(lon){
						return ((lon + 180) % 360 + 360) % 360 - 180;
						}
						
						// Cierra cada segmento hacia el sur (edgeLat=-MERC_MAX) o norte (edgeLat=+MERC_MAX)
						// Asegura SIEMPRE los dos vértices inferiores: derecha (lonA) e izquierda (lonB)
						function segmentsToClosedRings(segments, closeToSouth = true){
						const rings = [];
						const edgeLat = closeToSouth ? -MERC_MAX : MERC_MAX;
						
						for (const seg of segments){
							if (!seg || seg.length < 2) continue;
						
							const first = seg[0];
							const last  = seg[seg.length - 1];
						
							// Referencia de "desenvoltura": la longitud del último punto
							const lonRef = last[1];
						
							// Copiamos el segmento "desenvuelto" para que no haya saltos en ±180°
							const unwrapped = seg.map(([la, lo]) => [la, unwrapLon(lo, lonRef)]);
						
							// Calculamos las dos longitudes inferiores "desenvueltas"
							const lonA = unwrapLon(last[1],  lonRef);   // derecha (desde el último)
							const lonB = unwrapLon(first[1], lonA);     // izquierda (con continuidad respecto a lonA)
						
							// Construimos el anillo: línea del terminador → bajar a fondo derecha → fondo izquierda → subir a inicio
							const ring = [
							...unwrapped,
							[edgeLat, lonA],
							[edgeLat, lonB],
							[first[0], lonB],
							].map(([la, lo]) => [la, wrapLon(lo)]);     // volvemos a ±180°
						
							rings.push(ring);
						}
						return rings;
					}
				
					// Línea/máscara del terminador (segmentada en ±180°)
					function buildTerminatorLine(){
						const s = subsolar(refNow());
					
						// Base ortonormal:
						const phi = rad(s.lat), lam = rad(s.lon);
						const cx = Math.cos(phi)*Math.cos(lam), cy = Math.cos(phi)*Math.sin(lam), cz = Math.sin(phi);
						let ax=0, ay=0, az=1; if (Math.abs(cz) > 0.99) { ax=1; ay=0; az=0; }
						let ux = ay*cz - az*cy, uy = az*cx - ax*cz, uz = ax*cy - ay*cx; const un = Math.hypot(ux,uy,uz); ux/=un; uy/=un; uz/=un;
						const vx = cy*uz - cz*uy, vy = cz*ux - cx*uz, vz = cx*uy - cy*ux;
					
						// 1) Línea del terminador (evitar salto ±180°)
						const segments = []; let seg = []; let prevLon = null; const TH = 170;
						for (let t=0; t<=360; t+=0.5){
							const tr = rad(t);
							const x = ux*Math.cos(tr) + vx*Math.sin(tr);
							const y = uy*Math.cos(tr) + vy*Math.sin(tr);
							const z = uz*Math.cos(tr) + vz*Math.sin(tr);
							let lat = deg(Math.asin(z));
							if (lat >  MERC_MAX) lat =  MERC_MAX;
							if (lat < -MERC_MAX) lat = -MERC_MAX;
							let lon = deg(Math.atan2(y, x)); lon = normLon(lon);
					
							if (prevLon !== null){
							if ((prevLon > TH && lon < -TH) || (prevLon < -TH && lon > TH)){
								if (seg.length) segments.push(seg);
								seg = [];
							}
							}
							seg.push([lat, lon]);
							prevLon = lon;
						}
						if (seg.length) segments.push(seg);
					
						// 2) ¿Cerrar al sur o al norte? (noche incluye el polo opuesto al subsolar)
						const closeToSouth = (s.lat >= 0); // sol en norte => noche al sur; sol en sur => noche al norte
						const rings = segmentsToClosedRings(segments, closeToSouth);
					
						// 3) Crear/actualizar la máscara
						const opts = {
							pane: 'terminatorPane',
							weight: 0,                      // sin borde visible (mejor máscara pura)
							color:  'rgba(0,0,0,0)',
							lineCap: 'round',
							lineJoin: 'round',
							fill: true,
							fillColor: '#001133',              // negro para noche (se integra con tiles)
							fillOpacity: 0.60,
							noClip: true,
							smoothFactor: 0,
							className: 'terminator-line',
							interactive: false,             // no bloquea eventos (además el pane tiene pointer-events:none)
							renderer: L.svg({ padding: 0 })
						};
					
						if (!window.ringLine){
							window.ringLine = L.polygon(rings, opts).addTo(map);
							ringLine = window.ringLine; // sincroniza ref. local para el toggle
						} else {
							window.ringLine.setLatLngs(rings);
							window.ringLine.setStyle(opts);
						}
						window.ringLine.bringToFront();
					}
						
					// Pintar ya
					buildTerminatorLine();
					
					// Toggle de ambas capas
					const termChk = document.getElementById('toggleTerminator');
					if (termChk) {
						termChk.addEventListener('change', function () {
							if (this.checked) {
							if (dayNightLayer) dayNightLayer.addTo(map);
							if (ringLine)      ringLine.addTo(map);
						
							// Reponer overlays si están activos y dejarlos AL FRENTE
							if (document.getElementById('toggleRadar')?.checked && rainv?.layer) {
								rainv.layer.addTo(map);
							}
							if (document.getElementById('toggleClouds')?.checked && satv?.layer) {
								satv.layer.addTo(map);
							}
						
							restoreOrder();
							} else {
							if (dayNightLayer) map.removeLayer(dayNightLayer);
							if (ringLine)      map.removeLayer(ringLine);
							}
						
							// ⇩⇩ Persistencia del toggle Día/Noche
							try { localStorage.setItem('sr.t.term', this.checked ? '1' : '0'); } catch (_) {}
						});
					}
				
					const state = { horizonMins:60, sats:{} }; // ahora dinámico (id -> objeto sat)

					// ===== Persistencia en navegador =====
					const STORAGE = {
						key: 'satRasteator.sats.v1',
						save(){
							try{
								const arr = Object.entries(state.sats).map(([id, s])=>({
									id,
									name: s.name,
									l1: s.l1,
									l2: s.l2,
									color: s.color || '#ff3333',
									visible: !!s.visible,
									iconKey: s.iconKey || null,
									iconUrl: s.iconUrl || null
								}));
								localStorage.setItem(this.key, JSON.stringify(arr));
							}catch(_){}
						},
						load(){
							try{
								const raw = localStorage.getItem(this.key);
								if(!raw) return [];
								const arr = JSON.parse(raw);
								return Array.isArray(arr) ? arr : [];
							}catch(_){ return []; }
						}
					};
				
					function toggleSat(id, on){
						const s=state.sats[id]; if (!s) return;
						s.visible=on;
						if(s.marker){ on?map.addLayer(s.marker):map.removeLayer(s.marker); }
						// círculo solo si el toggle global de horizonte está activo
						if(s.circle){
							const showHoriz = isOn(document.getElementById('btnHorizon'));
							if(on && showHoriz){ if(!map.hasLayer(s.circle)) map.addLayer(s.circle); }
							else { if(map.hasLayer(s.circle)) map.removeLayer(s.circle); }
						}
						if(s.track){  on?map.addLayer(s.track):map.removeLayer(s.track); }
						STORAGE.save();
					}
				
					// === Ubicarme como toggle (punto azul + precisión) ===
					let meLayer=null, meMarker=null, meAcc=null;
					const locBtn = document.getElementById('locateMe');
					function applyLocate(on){
						setBtn(locBtn, on);
						if (!on){
							if (meLayer) { try{ map.removeLayer(meLayer); }catch(_){ } meLayer=null; meMarker=null; meAcc=null; }
							return;
						}
						if(!navigator.geolocation){ alert('Geolocalización no soportada'); setBtn(locBtn,false); return; }
						navigator.geolocation.getCurrentPosition(function(pos){
							const lat=pos.coords.latitude, lon=pos.coords.longitude, acc=pos.coords.accuracy||0;
							const dotIcon = L.divIcon({ className:'me-dot', iconSize:[14,14], iconAnchor:[7,7] });
							if (!meLayer){
								meMarker = L.marker([lat,lon], { icon: dotIcon, interactive:false, pane:'satPane' });
								meAcc    = L.circle([lat,lon], { radius: acc, color:'#2a7bff', fillColor:'#2a7bff', weight:1, opacity:.4, fillOpacity:.15, pane:'orbitPane' });
								meLayer  = L.layerGroup([meAcc, meMarker]).addTo(map);
							} else {
								meMarker.setIcon(dotIcon).setLatLng([lat,lon]);
								meAcc.setLatLng([lat,lon]).setRadius(acc);
								if (!map.hasLayer(meLayer)) meLayer.addTo(map);
							}
						}, function(){ alert('No se pudo obtener ubicación'); setBtn(locBtn,false); });
					}
					locBtn?.addEventListener('click', ()=> applyLocate(!isOn(locBtn)));
				
					document.getElementById('trackHorizon').addEventListener('change', function(e){
						state.horizonMins=parseInt(e.target.value,10)||0; computeAllTracks();
						try{ localStorage.setItem('sr.horizon', String(state.horizonMins)); }catch(_){}
					});
				
					const now = () => refNow();
					function toLLA(satrec, date){
						const pv = satellite.propagate(satrec, date);
						if(!pv.position||!pv.velocity) return null;
						const gmst = satellite.gstime(date);
						const gd = satellite.eciToGeodetic(pv.position, gmst);
						const lat = satellite.degreesLat(gd.latitude);
						const lon = satellite.degreesLong(gd.longitude);
						const altKm = gd.height;
						const v = pv.velocity; const speedKms = Math.hypot(v.x,v.y,v.z);
						return { lat, lon, altKm, speedKmh:speedKms*3600 };
					}
					
					// Radio de huella (arco sobre la superficie) ~ Re * acos(Re/(Re+h))
					function footprintRadiusMeters(altKm){
						const Re = 6371;                       // km
						const psi = Math.acos(Re / (Re + Math.max(altKm, 0.001)));
						return Re * psi * 1000;                // → metros
					}
					
					// Precarga de un icono local para evitar parpadeos
					(new Image()).src = 'img/satellite-rasteator/icons/32/sat1.png';

					// === Iconos locales (32/64 px) y fábrica de iconos ===
					const ICON_BASE = 'img/satellite-rasteator/icons';
					const ICON_FILES = {
						sat1: 'sat1.png',
						sat2: 'sat2.png',
						sat3: 'sat3.png',
						sat4: 'sat4.png',
						sat5: 'sat5.png',
						sat6: 'sat6.png',
						sat7: 'sat7.png',
						/*sat8: 'sat8.png',
						sat9: 'sat9.png',*/
						iss : 'iss.png'
					};
					function iconPath(key, size=32){
						const file = ICON_FILES[key] || ICON_FILES.sat1;
						return `${ICON_BASE}/${size}/${file}`;
					}
					// Acepta una clave (sat1…iss) o una URL absoluta/data:
					function makeIcon(keyOrUrl = 'sat1'){
						const isUrl = /^(https?:|data:|\/)/i.test(keyOrUrl);
						const file  = ICON_FILES[keyOrUrl] || ICON_FILES.sat1;
						const x1 = isUrl ? keyOrUrl : `${ICON_BASE}/32/${file}`;
						const x2 = isUrl ? keyOrUrl : `${ICON_BASE}/64/${file}`;
						return L.icon({
							iconUrl: x1,
							iconRetinaUrl: x2,
							iconSize: [32,32],
							iconAnchor: [16,16],
							popupAnchor: [0,-16],
							className: 'satellite-icon'
						});
					}
					
					// === Picker de TLE ===
					function tleChecksumOk(line){
						// Checksum TLE: suma dígitos + ( - cuenta como 1 ) mod 10 debe igualar último char
						if(!line || line.length < 69) return false;
						const csChar = line.trim().slice(-1);
						if(!/^[0-9]$/.test(csChar)) return false;
						const head = line.slice(0, 68);
						let s = 0;
						for (let i=0;i<head.length;i++){
							const ch = head[i];
							if (ch >= '0' && ch <= '9') s += ch.charCodeAt(0) - 48;
							else if (ch === '-') s += 1;
						}
						return (s % 10) === parseInt(csChar,10);
					}
					function openTlePicker(anchorBtn, l1Current='', l2Current='', onSave){
						// Cierra cualquier otro popover
						document.querySelectorAll('.tle-picker,.icon-picker').forEach(el=>el.remove());
						const pop = document.createElement('div');
						pop.className = 'tle-picker';
						pop.innerHTML = `
							<h4>Modificar TLE</h4>
							<textarea class="tle-area" placeholder="Pega aquí las 2 líneas (empiezan por 1 y 2)"></textarea>
							<div class="meta">
								<span class="pill len">—</span>
								<span class="pill chk1">L1: —</span>
								<span class="pill chk2">L2: —</span>
								<span class="pill status">Estado: esperando…</span>
							</div>
							<div class="actions">
								<button class="btn close-btn">Cancelar</button>
								<button class="btn save-btn" disabled>Guardar</button>
							</div>
						`;
						const area  = pop.querySelector('.tle-area');
						const lenEl = pop.querySelector('.len');
						const c1El  = pop.querySelector('.chk1');
						const c2El  = pop.querySelector('.chk2');
						const stEl  = pop.querySelector('.status');
						const btnSave = pop.querySelector('.save-btn');
						const btnClose= pop.querySelector('.close-btn');
						area.value = (l1Current ? (l1Current+'\n') : '') + (l2Current||'');
						function validate(){
							const raw = area.value.trim();
							const parsed = parseTLEBlock(raw) || {};
							const l1 = parsed.l1 || ''; const l2 = parsed.l2 || '';
							const l1ok = /^1\s/.test(l1) && l1.length>=60 && tleChecksumOk(l1);
							const l2ok = /^2\s/.test(l2) && l2.length>=60 && tleChecksumOk(l2);
							lenEl.textContent = `${raw.length} chars`;
							c1El.textContent  = `L1: ${l1ok?'OK':'X'}`; c1El.className = `pill ${l1ok?'ok':'bad'}`;
							c2El.textContent  = `L2: ${l2ok?'OK':'X'}`; c2El.className = `pill ${l2ok?'ok':'bad'}`;
							const ok = !!(l1 && l2 && l1ok && l2ok);
							btnSave.disabled = !ok;
							stEl.textContent = ok ? 'Estado: válido' : 'Estado: incompleto o inválido';
							return ok ? {l1,l2} : null;
						}
						area.addEventListener('input', validate);
						setTimeout(()=>{ area.focus(); area.setSelectionRange(area.value.length, area.value.length); validate(); }, 0);
						document.body.appendChild(pop);
						// Posicionar junto al botón
						const r = anchorBtn.getBoundingClientRect(), m=6;
						let left = Math.min(window.innerWidth - pop.offsetWidth - 8, Math.max(8, r.left));
						let top  = r.bottom + m; if (top + pop.offsetHeight + 8 > window.innerHeight) top = r.top - pop.offsetHeight - m;
						pop.style.left = `${left}px`; pop.style.top = `${top}px`;
						// Cerrar fuera / ESC
						const onDoc = (e)=>{ if(!pop.contains(e.target) && e.target!==anchorBtn){ pop.remove(); document.removeEventListener('mousedown',onDoc); } };
						document.addEventListener('mousedown', onDoc);
						window.addEventListener('keydown', function onEsc(ev){ if(ev.key==='Escape'){ pop.remove(); document.removeEventListener('mousedown',onDoc); window.removeEventListener('keydown', onEsc); }});
						btnClose.addEventListener('click', ()=>{ pop.remove(); document.removeEventListener('mousedown',onDoc); });
						btnSave.addEventListener('click', ()=>{
							const ok = validate();
							if(!ok) return;
							onSave(ok.l1, ok.l2);
							pop.remove(); document.removeEventListener('mousedown',onDoc);
						});
					}
					
					// === Popover genérico de selección de icono ===
					function openIconPicker(anchorBtn, currentKey, onChoose){
						// Cerrar si ya hay uno
						let existing = document.querySelector('.icon-picker');
						if (existing) existing.remove();
						const pop = document.createElement('div');
						pop.className = 'icon-picker';
						pop.innerHTML = `
							<h4>Elige un icono</h4>
							<div class="icon-grid"></div>
							<div class="close-row"><button class="close-btn">Cerrar</button></div>
						`;
						const grid = pop.querySelector('.icon-grid');
						const keys = Object.keys(ICON_FILES);
						keys.forEach(k=>{
							const it = document.createElement('button');
							it.type = 'button';
							it.className = 'icon-item';
							it.setAttribute('aria-selected', String(k===currentKey));
							it.innerHTML = `<img alt="${k}" src="${iconPath(k,32)}">`;
							it.addEventListener('click', ()=>{
								onChoose(k);
								pop.remove();
							});
							grid.appendChild(it);
						});
						document.body.appendChild(pop);
						// Posicionar junto al botón
						const r = anchorBtn.getBoundingClientRect();
						const margin = 6;
						let left = Math.min(window.innerWidth - pop.offsetWidth - 8, Math.max(8, r.left));
						let top  = r.bottom + margin;
						// si se sale por abajo, colócalo arriba
						if (top + 280 > window.innerHeight) top = r.top - pop.offsetHeight - margin;
						pop.style.left = `${left}px`;
						pop.style.top  = `${top}px`;
						// Cerrar fuera / ESC
						const onDoc = (e)=>{ if(!pop.contains(e.target) && e.target!==anchorBtn){ pop.remove(); document.removeEventListener('mousedown',onDoc); } };
						document.addEventListener('mousedown', onDoc);
						pop.querySelector('.close-btn').addEventListener('click', ()=>{ pop.remove(); document.removeEventListener('mousedown',onDoc); });
						window.addEventListener('keydown', function onEsc(ev){ if(ev.key==='Escape'){ pop.remove(); document.removeEventListener('mousedown',onDoc); window.removeEventListener('keydown', onEsc); }});
					}
					function setIconButtonVisual(btn, keyOrUrl){
						// Si es URL externa/data, úsala tal cual; si es clave, usa 32px local
						const isUrl = /^(https?:|data:|\/)/i.test(keyOrUrl);
						const src = isUrl ? keyOrUrl : iconPath(keyOrUrl||'sat1', 32);
						btn.innerHTML = `<img alt="icon" src="${src}" style="width:20px;height:20px;pointer-events:none">`;
					}
					
					// DEBUG: icono de prueba en (0,0). Quitar luego.
					//L.marker([0,0], { icon: satIcon, pane: 'satPane', title: 'TEST' }).addTo(map);
				
					function updateSat(id){
						const s = state.sats[id]; if(!s || !s.satrec) return;
						const p=toLLA(s.satrec, now()); if(!p) return;
						if(!s.marker){
							const keyOrUrl = s.iconUrl || s.iconKey || 'sat1';
							s.marker = L.marker([p.lat, p.lon], {
								title: s.name,
								icon: makeIcon(keyOrUrl),
								pane: 'satPane'
							}).addTo(map).bindPopup('<b>'+s.name+'</b>');
						} else {
							// ¡No recrear! solo mover el marker existente
							s.marker.setLatLng([p.lat, p.lon]);
						}
						
						const radius = typeof footprintRadiusMeters === 'function'
							? footprintRadiusMeters(p.altKm)
							: 145000; // fallback si no integraste la función de radio dinámico
						if(!s.circle){
							// 2) footprint/área en pane de ÓRBITAS (no añadir aún al mapa)
							s.circle = L.circle([p.lat, p.lon], {
								pane: 'orbitPane',
								radius,
								color: s.color || '#ff3333',
								fillColor: s.color || '#ff3333',
								weight: 1,
								opacity: 0.9,
								fillOpacity: 0.12
							});
						} else {
							s.circle.setLatLng([p.lat,p.lon]);
							// por si cambia la altitud o integras radio dinámico
							if (typeof s.circle.setRadius === 'function') s.circle.setRadius(radius);
						}
						
						// mostrar/ocultar según toggle global + visibilidad del satélite
						const showHoriz = isOn(document.getElementById('btnHorizon'));
						if (s.circle){
							if (showHoriz && s.visible !== false){
								if (!map.hasLayer(s.circle)) s.circle.addTo(map);
							} else {
								if (map.hasLayer(s.circle)) map.removeLayer(s.circle);
							}
						}
						
						const el=document.getElementById('kv-'+id);
						if(el){
							let txt='Lat: '+p.lat.toFixed(3)+' deg, Lon: '+p.lon.toFixed(3)+' deg';
							txt+='\nAlt: '+p.altKm.toFixed(1)+' km | Vel: '+p.speedKmh.toFixed(0)+' km/h';
							el.textContent=txt;
						}
					}
				
					function computeTrack(id){
						const s=state.sats[id];
						if(!s.satrec || state.horizonMins<=0){ if(s.track){ map.removeLayer(s.track); s.track=null; } return; }
						const step=30; // 30s
						const total=state.horizonMins*60;
						const pts=[]; const start = refNow();
						for(let t=0; t<=total; t+=step){
							const d=new Date(start.getTime()+t*1000);
							const p=toLLA(s.satrec, d);
							if(p) pts.push([p.lat,p.lon]);
						}
						if(!s.track){
							s.track=L.polyline(pts,{
								pane:'orbitPane',
								color: s.color || '#ff3333',
								weight:1.2, opacity:.9
							}).addTo(map);
						} else {
							s.track.setLatLngs(pts);
							// aplica color si cambió
							s.track.setStyle({ color: s.color || '#ff3333' });
						}
					}
				
					function computeAllTracks(){
						for (const id in state.sats){ computeTrack(id); }
					}
					function tick(){
						for (const id in state.sats){ updateSat(id); }
						// Si estamos siguiendo uno, céntralo manteniendo el zoom actual (sin “salto” de zoom)
						if (followId && state.sats[followId] && state.sats[followId].marker){
							const ll = state.sats[followId].marker.getLatLng();
							map.setView(ll, map.getZoom(), { animate:false });
						}
					}
				
					document.getElementById('status').textContent='TLE: esperando (usa el panel para pegarlas)';

					// ====== Gestión dinámica de satélites (refs DOM) — mover arriba para evitar TDZ ======
					const satListEl   = document.getElementById('satList');
					const addBtn      = document.getElementById('addSatBtn');
					const nameInp     = document.getElementById('satName');
					const tleBlockInp = document.getElementById('tleBlock');
					const defColInp   = document.getElementById('defaultOrbitColor');
					const newIconBtn  = document.getElementById('newIconBtn');
					const satFilterInp= document.getElementById('satFilter');
					// UI estado validación al añadir
					const addLenEl    = document.getElementById('addLen');
					const addL1El     = document.getElementById('addL1');
					const addL2El     = document.getElementById('addL2');
					const addStateEl  = document.getElementById('addState');
					let newSatIconKey = (localStorage.getItem('sr.newIcon') || 'sat1');
					let followId = null; // id del satélite en modo “seguir”

					// === Guardar vista del mapa (centro/zoom)
					map.on('moveend zoomend', ()=>{
						try{
							const c = map.getCenter();
							localStorage.setItem('sr.mapView', JSON.stringify({ center:[c.lat, c.lng], zoom: map.getZoom() }));
						}catch(_){}
					});

					// === Restaurar estado de UI
					function restoreUI(){
						try{
							// Base
							const savedBase = localStorage.getItem('sr.base');
							if (savedBase){
								const sel = document.getElementById('baseSel');
								if (sel) sel.value = savedBase;
								const nextBase = (savedBase==='light'?baseLight : savedBase==='dark'?baseDark : savedBase==='sat'?baseSat : baseOSM);
								if (currentBase && map.hasLayer(currentBase)) map.removeLayer(currentBase);
								nextBase.addTo(map); currentBase = nextBase;
							}
							// Vista
							const mv = JSON.parse(localStorage.getItem('sr.mapView')||'null');
							if (mv && Array.isArray(mv.center) && typeof mv.zoom==='number'){
								map.setView(mv.center, mv.zoom, {animate:false});
							}
							// Horizonte traza
							const h = localStorage.getItem('sr.horizon');
							if (h){
								state.horizonMins = parseInt(h,10)||0;
								const selH = document.getElementById('trackHorizon');
								if (selH) selH.value = String(state.horizonMins);
								computeAllTracks();
							}
							// Restaurar estado de botones desde localStorage
							applyTerm(   (localStorage.getItem('sr.t.term')   ?? '1') === '1' );
							applyRadar(  (localStorage.getItem('sr.t.radar')  ?? '1') === '1' );
							applyClouds( (localStorage.getItem('sr.t.clouds') ?? '1') === '1' );
							applyHorizon((localStorage.getItem('sr.t.horiz')  ?? '1') === '1' );
						}catch(_){}
					}

					// Restaurar UI y luego satélites guardados
					restoreUI();	

					// Icono por defecto para nuevos satélites (UI)
					if (newIconBtn){
						setIconButtonVisual(newIconBtn, newSatIconKey);
						newIconBtn.addEventListener('click', ()=>{
							openIconPicker(newIconBtn, newSatIconKey, (k)=>{
								newSatIconKey = k;
								setIconButtonVisual(newIconBtn, newSatIconKey);
								try{ localStorage.setItem('sr.newIcon', newSatIconKey); }catch(_){}
							});
						});
					}					
					
					// Restaurar satélites guardados
					(function restoreSaved(){
						const saved = STORAGE.load();
						if (saved.length){
							for (const it of saved){
								const {id, name, l1, l2, color, visible, iconKey, iconUrl} = it || {};
 								if (name && l1 && l2){
									addSatellite({ id, name, l1, l2, color, visible, iconKey, iconUrl });
 								}
							}
							const st = document.getElementById('status');
							if (st) st.textContent = `TLE: cargado (${Object.keys(state.sats).length} satélites)`;
						}
					})();
					tick(); computeAllTracks();
					
					setInterval(tick,1000);

					function parseTwoline(l1, l2){
						try{ return satellite.twoline2satrec(l1.trim(), l2.trim()); }catch(_){ return null; }
					}
					
					function parseTLEBlock(txt){
						if (!txt) return null;
						const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
						// Buscar la primera línea que empiece por "1 " y la primera que empiece por "2 "
						let l1 = lines.find(l => /^1\s/.test(l));
						let l2 = lines.find(l => /^2\s/.test(l));
						// Por si el usuario pegó más de dos líneas, tomar la siguiente "2 " tras la "1 "
						if (!l2 && l1){
							const i1 = lines.indexOf(l1);
							l2 = lines.slice(i1+1).find(l => /^2\s/.test(l));
						}
						return (l1 && l2) ? { l1, l2 } : null;
					}

					function uidFromName(name){
						const base = name.trim().toUpperCase().replace(/[^A-Z0-9]+/g,'-').replace(/^-+|-+$/g,'') || 'SAT';
						return base + '-' + Date.now().toString(36);
					}

					function createSatRow(id, s){
						const row = document.createElement('div');
						row.className = 'sat-item';
						row.id = 'row-'+id;
						row.innerHTML = `
							<input type="checkbox" id="chk-${id}" ${s.visible?'checked':''} />
							<div style="min-width:0">
								<div><b class="sat-name" data-id="${id}" title="Editar nombre (clic)">${s.name}</b></div>
								<div class="kv" id="kv-${id}"></div>
							</div>
							<div class="sat-actions actions-col">
								<button class="zoomSat btn-icon" data-id="${id}" title="Zoom/Seguir">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M15.5 14h-.79l-.28-.27A6.471 6.471 0 0 0 16 9.5 6.5 6.5 0 1 0 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5Zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14Z"/></svg>
								</button>
								<button class="iconBtn btn-icon" data-id="${id}" title="Elegir icono"></button>
								<button class="colorBtn btn-color" data-id="${id}" title="Cambiar color de órbita"></button>
								<button class="editTLE btn-icon" data-id="${id}" title="Modificar TLE">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25ZM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83Z"/></svg>
								</button>
								<button class="delSat btn-icon btn-danger" data-id="${id}" title="Eliminar satélite">
									<svg viewBox="0 0 24 24" aria-hidden="true"><path fill="currentColor" d="M6 7h12v2H6V7Zm2 3h8l-1 9H9L8 10Zm3-6h2v2h-2V4Z"/></svg>
								</button>
								<input type="color" class="colorPicker" id="col-${id}" value="${s.color || '#ff3333'}" style="position:absolute;opacity:0;pointer-events:none;width:0;height:0" />
							</div>
						`;
						satListEl.appendChild(row);

						// eventos
						row.querySelector('#chk-'+id).addEventListener('change', e=>{
							toggleSat(id, e.target.checked);
						});
						
						// Zoom (manteniendo nivel) + seguir / desenganchar sin mover
						const zoomBtn = row.querySelector('.zoomSat');
						function refreshZoomFollow(){
							if (followId === id){ zoomBtn.classList.add('active'); zoomBtn.title = 'Dejar de seguir'; }
							else { zoomBtn.classList.remove('active'); zoomBtn.title = 'Zoom/Seguir'; }
						}
						refreshZoomFollow();
						zoomBtn.addEventListener('click', ()=>{
							const sat = state.sats[id];
							if(!sat || !sat.marker) return;
							// Si ya seguimos este satélite → desenganchar y no mover el mapa
							if (followId === id){
								followId = null;
								refreshZoomFollow();
								return;
							}
							// Si seguimos a otro o a ninguno → viajar al satélite conservando el zoom actual y empezar a seguir
							const currentZoom = map.getZoom();
							map.flyTo(sat.marker.getLatLng(), currentZoom, { duration:1.2, easeLinearity:0.25, animate:true });
							followId = id;
							// actualizar estilos en todos los botones
							document.querySelectorAll('.zoomSat').forEach(b=>b.classList.remove('active'));
							refreshZoomFollow();
						});
						
						const colorBtn = row.querySelector('.colorBtn');
						const colorInp = row.querySelector('#col-'+id);
						// color inicial del chip (asegurado por JS)
						colorBtn.style.setProperty('--col', s.color || '#ff3333');
						colorBtn.addEventListener('click', ()=> colorInp.click());
						colorInp.addEventListener('input', (e)=>{
							const c = e.target.value;
							const sat = state.sats[id];
							sat.color = c;
							if (sat.track)  sat.track.setStyle({ color:c });
							if (sat.circle) sat.circle.setStyle({ color:c, fillColor:c });
							// actualizar chip visual del botón
							colorBtn.style.setProperty('--col', c);
							STORAGE.save();
						});
						
						// elegir icono (presets: sat/dot/tri o URL)
						// Botón de icono: muestra miniatura actual y abre picker
						const iconBtn = row.querySelector('.iconBtn');
						setIconButtonVisual(iconBtn, s.iconUrl || s.iconKey || 'sat1');
						iconBtn.addEventListener('click', ()=>{
							const sat = state.sats[id];
							openIconPicker(iconBtn, sat.iconKey || 'sat1', (k)=>{
								sat.iconKey = k; sat.iconUrl = null;
								setIconButtonVisual(iconBtn, k);
								if (sat.marker) sat.marker.setIcon(makeIcon(k));
								STORAGE.save();
							});
						});
						
						// botón editar TLE → abre picker popover
						const editBtn = row.querySelector('.editTLE');
						editBtn.addEventListener('click', ()=>{
							const sat = state.sats[id];
							openTlePicker(editBtn, sat.l1, sat.l2, (newL1, newL2)=>{
								sat.l1 = newL1; sat.l2 = newL2;
								try{ sat.satrec = parseTwoline(newL1, newL2); }catch(e){ console.warn('parseTwoline error', e); }
								STORAGE.save();
							});
						});
						
						// eliminar satélite
						row.querySelector('.delSat').addEventListener('click', ()=>{
							removeSatellite(id);
						});
						
						// nombre editable al clic
						const nameEl = row.querySelector('.sat-name');
						nameEl.addEventListener('click', ()=>{
							nameEl.setAttribute('contenteditable','true');
							const sel = window.getSelection(); const r = document.createRange();
							r.selectNodeContents(nameEl); sel.removeAllRanges(); sel.addRange(r);
							nameEl.focus();
						});
						nameEl.addEventListener('keydown', (ev)=>{ if(ev.key==='Enter'){ ev.preventDefault(); nameEl.blur(); }});
						nameEl.addEventListener('blur', ()=>{
							nameEl.removeAttribute('contenteditable');
							const newName = nameEl.textContent.trim() || s.name;
							s.name = newName;
							if (s.marker && s.marker.getPopup()) s.marker.getPopup().setContent('<b>'+s.name+'</b>');
							else if (s.marker) s.marker.bindPopup('<b>'+s.name+'</b>');
							STORAGE.save();
						});
					}

					function addSatellite({id, name, l1, l2, color, visible, iconKey, iconUrl}){
 						const satrec = parseTwoline(l1, l2);
						if(!satrec){ alert('TLE inválido'); return; }
						const _id = id || uidFromName(name);
						if (state.sats[_id]) { /* evita duplicados si ya existiera */ return; }
						state.sats[_id] = {
							name, l1, l2, satrec,
							color: color || '#ff3333',
							iconKey: iconKey || newSatIconKey || 'sat1',
							iconUrl: iconUrl || null,
							marker:null, circle:null, track:null,
							visible: (visible === false ? false : true)
						};
						createSatRow(_id, state.sats[_id]);
						// fuerza primer tick/track
						updateSat(_id);
						computeTrack(_id);
						// respetar visibilidad restaurada
						if (visible === false) toggleSat(_id, false);
						// UI feedback
						const st = document.getElementById('status');
						if (st) st.textContent = `TLE: cargado (${Object.keys(state.sats).length} satélites)`;
						// guardar
						STORAGE.save();
					}
					
					function removeSatellite(id){
						const s = state.sats[id];
						if(!s) return;
						// elimina capas del mapa
						if (s.marker) { try{ map.removeLayer(s.marker); }catch(_){} }
						if (s.circle) { try{ map.removeLayer(s.circle); }catch(_){} }
						if (s.track)  { try{ map.removeLayer(s.track);  }catch(_){} }
						// borra del estado
						delete state.sats[id];
						// si se estaba siguiendo, cancelar seguimiento
						if (followId === id) followId = null;
						// borra la fila
						const row = document.getElementById('row-'+id);
						if (row && row.parentNode) row.parentNode.removeChild(row);
						// feedback de estado
						const st = document.getElementById('status');
						const n  = Object.keys(state.sats).length;
						if (st) st.textContent = n ? `TLE: cargado (${n} satélites)` : 'TLE: esperando…';
						// guardar
						STORAGE.save();
					}

					if(addBtn){
						addBtn.addEventListener('click', ()=>{
							const name  = (nameInp.value || '').trim();
							const color = defColInp.value || '#ff3333';
							const parsed = parseTLEBlock(tleBlockInp.value || '');
							if (!name || !parsed){
								alert('Indica un nombre y pega un TLE válido (2 líneas que empiecen por 1 y 2).');
								return;
							}
							addSatellite({ name, l1: parsed.l1, l2: parsed.l2, color, iconKey: newSatIconKey });
							// limpia y cierra
							nameInp.value = ''; tleBlockInp.value = '';
							try{ document.getElementById('addSatPanel').open = false; }catch(_){}
						});
						// validación en vivo del TLE para el botón Añadir
						function validateAddTLE(){
							const raw = (tleBlockInp.value||'').trim();
							const parsed = parseTLEBlock(raw) || {};
							const l1 = parsed.l1||''; const l2 = parsed.l2||'';
							const l1ok = /^1\s/.test(l1) && l1.length>=60 && tleChecksumOk(l1);
							const l2ok = /^2\s/.test(l2) && l2.length>=60 && tleChecksumOk(l2);
							if (addLenEl) addLenEl.textContent = `${raw.length} chars`;
							if (addL1El)  addL1El.textContent  = `L1: ${l1ok?'OK':'X'}`;
							if (addL2El)  addL2El.textContent  = `L2: ${l2ok?'OK':'X'}`;
							if (addStateEl) addStateEl.textContent = (l1ok&&l2ok) ? 'Estado: válido' : 'Estado: incompleto o inválido';
							addBtn.disabled = !(l1ok && l2ok && (nameInp.value||'').trim());
						}
						tleBlockInp.addEventListener('input', validateAddTLE);
						nameInp.addEventListener('input', validateAddTLE);
						// primera pasada
						validateAddTLE();
					}
					
					// Filtro por nombre
					if (satFilterInp){
						satFilterInp.addEventListener('input', ()=>{
							const q = satFilterInp.value.trim().toLowerCase();
							for (const id in state.sats){
								const s = state.sats[id];
								const row = document.getElementById('row-'+id);
								if (!row) continue;
								const show = !q || (s.name||'').toLowerCase().includes(q);
								row.style.display = show ? '' : 'none';
							}
						});
					}
					
					// === HEARTBEAT global (1/min) ===
					const HEARTBEAT_MS = 60000;
					function heartbeat(){
						if (window.dayNightLayer) window.dayNightLayer.setTime(refNow());
						if (typeof buildTerminatorLine === 'function') buildTerminatorLine();
						if (typeof computeAllTracks === 'function') computeAllTracks();
						updateRadar();
						updateSatRV();
					}
					setInterval(heartbeat, HEARTBEAT_MS);

					// Si estamos en "Ahora", refresca el input visible cada segundo para que "corra" el reloj
					setInterval(()=>{
						if (!timeState.manual && refInput){
							refInput.value = toLocalDTValue(new Date());
						}
					// Actualiza el reloj UTC global cada segundo
					updateUTCStatus();
					}, 1000);
					
				});
			})();
		</script>
	</body>
</html>
