<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Sistema Solar â€” Babylon.js (N-Body + FreeFly + Look)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#000}
    #renderCanvas{width:100%;height:100%;touch-action:none;display:block}
    #ui{
      position:fixed;left:12px;top:12px;z-index:10;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:#fff; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius:10px; backdrop-filter: blur(6px);
      width: 360px;
    }
    #ui h1{font-size:14px;margin:0 0 8px 0;font-weight:650;opacity:.95}
    .row{display:flex;align-items:center;gap:8px;margin:8px 0}
    .row label{font-size:12px;opacity:.9;min-width:92px}
    .row input[type="range"]{flex:1}
    .btn{
      cursor:pointer;border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);color:#fff;border-radius:8px;
      padding:6px 10px;font-size:12px;
    }
    .btn:hover{background:rgba(255,255,255,.10)}
    .hint{font-size:11px;opacity:.8;line-height:1.25;margin-top:6px}
    .small{font-size:11px;opacity:.85}
    .kv{display:flex;justify-content:space-between;gap:12px;flex-wrap:wrap}
    .tag{font-size:11px;opacity:.85;border:1px solid rgba(255,255,255,.14);padding:3px 8px;border-radius:999px}
  </style>
</head>
<body>
  <div id="ui">
    <h1>ðŸŒž Sistema Solar (Babylon.js) â€” N-Body + FreeFly + Look</h1>

    <div class="row">
      <label>Velocidad</label>
      <input id="speed" type="range" min="0" max="400" value="60" />
      <span id="speedVal" style="font-size:12px;opacity:.9;min-width:42px;text-align:right;">60</span>
    </div>

    <div class="row">
      <label>Trails</label>
      <input id="trails" type="checkbox" checked />
      <label style="min-width:auto;">Etiquetas</label>
      <input id="labels" type="checkbox" checked />
    </div>

    <div class="row">
      <button id="pauseBtn" class="btn">Pausar</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="focusSunBtn" class="btn">Focus Sol</button>
      <button id="camBtn" class="btn">CÃ¡mara: Libre</button>
    </div>

    <div class="small kv">
      <div class="tag">G: <span id="gVal">0.0001</span></div>
      <div class="tag">dt: <span id="dtVal">0.01</span></div>
      <div class="tag">pasos/frame: <span id="stepsVal">0</span></div>
    </div>

    <div class="hint">
      <b>Libre:</b> click en el canvas para capturar ratÃ³n â€¢ WASD mover â€¢ Shift sprint â€¢ Q/E subir/bajar â€¢ ESC libera ratÃ³n.<br>
      <b>Orbit:</b> arrastrar para orbitar â€¢ rueda zoom â€¢ click derecho pan.
    </div>
  </div>

  <canvas id="renderCanvas"></canvas>

  <!-- Babylon.js + GUI -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

  <script>
    // ===========================
    // Universe (como en SebLague)
    // ===========================
    const Universe = {
      gravitationalConstant: 0.0001,
      physicsTimeStep: 0.01
    };

    // ===========================
    // UI
    // ===========================
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    const speedEl = document.getElementById("speed");
    const speedValEl = document.getElementById("speedVal");
    const pauseBtn = document.getElementById("pauseBtn");
    const resetBtn = document.getElementById("resetBtn");
    const trailsEl = document.getElementById("trails");
    const labelsEl = document.getElementById("labels");
    const focusSunBtn = document.getElementById("focusSunBtn");
    const camBtn = document.getElementById("camBtn");

    const gValEl = document.getElementById("gVal");
    const dtValEl = document.getElementById("dtVal");
    const stepsValEl = document.getElementById("stepsVal");

    gValEl.textContent = Universe.gravitationalConstant;
    dtValEl.textContent = Universe.physicsTimeStep;

    let paused = false;
    let timeScale = Number(speedEl.value);
    speedValEl.textContent = speedEl.value;

    speedEl.addEventListener("input", () => {
      timeScale = Number(speedEl.value);
      speedValEl.textContent = String(timeScale);
    });

    pauseBtn.addEventListener("click", () => {
      paused = !paused;
      pauseBtn.textContent = paused ? "Reanudar" : "Pausar";
    });

    // ===========================
    // Helpers
    // ===========================
    function v3(x,y,z){ return new BABYLON.Vector3(x,y,z); }

    function makeEmissiveMaterial(scene, name, color3, alpha=1){
      const mat = new BABYLON.StandardMaterial(name, scene);
      mat.emissiveColor = color3;
      mat.diffuseColor = BABYLON.Color3.Black();
      mat.specularColor = BABYLON.Color3.Black();
      mat.alpha = alpha;
      return mat;
    }

    function makeLitMaterial(scene, name, color3){
      const mat = new BABYLON.StandardMaterial(name, scene);
      mat.diffuseColor = color3;
      mat.specularColor = new BABYLON.Color3(0.12, 0.12, 0.12);
      mat.specularPower = 64;
      return mat;
    }

    function createLabel(gui, text, targetMesh){
      const rect = new BABYLON.GUI.Rectangle("labelRect");
      rect.background = "rgba(0,0,0,0.35)";
      rect.height = "22px";
      rect.cornerRadius = 8;
      rect.thickness = 1;
      rect.color = "rgba(255,255,255,0.18)";
      rect.width = (Math.max(60, text.length * 8)) + "px";
      rect.isVisible = true;

      const tb = new BABYLON.GUI.TextBlock();
      tb.text = text;
      tb.color = "white";
      tb.fontSize = 12;
      rect.addControl(tb);

      gui.addControl(rect);
      rect.linkWithMesh(targetMesh);
      rect.linkOffsetY = -28;
      return rect;
    }

    // a = G * m_j * r / |r|^3  (con softening)
    function gravAccel(posI, posJ, massJ, G){
      const r = posJ.subtract(posI);
      const distSq = r.lengthSquared();
      const soft = 0.0001;
      const inv = 1.0 / Math.pow(distSq + soft, 1.5);
      return r.scale(G * massJ * inv);
    }

    // textura radial procedimental (corona)
    function createRadialSpriteTexture(scene, name, size=512){
      const dt = new BABYLON.DynamicTexture(name, {width:size, height:size}, scene, false);
      const ctx = dt.getContext();
      ctx.clearRect(0,0,size,size);

      const cx = size/2, cy = size/2;
      const grd = ctx.createRadialGradient(cx, cy, 0, cx, cy, size/2);

      // centro brillante -> borde suave
      grd.addColorStop(0.00, "rgba(255,235,180,1.0)");
      grd.addColorStop(0.12, "rgba(255,200,120,0.75)");
      grd.addColorStop(0.35, "rgba(255,160,80,0.25)");
      grd.addColorStop(0.70, "rgba(255,120,40,0.06)");
      grd.addColorStop(1.00, "rgba(0,0,0,0.00)");

      ctx.fillStyle = grd;
      ctx.beginPath();
      ctx.arc(cx, cy, size/2, 0, Math.PI*2);
      ctx.fill();

      dt.update(false);
      return dt;
    }

    // ===========================
    // Scene
    // ===========================
    const createScene = () => {
      const scene = new BABYLON.Scene(engine);
      scene.clearColor = new BABYLON.Color4(0,0,0,1);

      // --- CÃ¡maras (Orbit + FreeFly) ---
      const orbitCam = new BABYLON.ArcRotateCamera(
        "orbitCam",
        Math.PI / 2,
        Math.PI / 3,
        140,
        BABYLON.Vector3.Zero(),
        scene
      );
      orbitCam.lowerRadiusLimit = 10;
      orbitCam.upperRadiusLimit = 1200;
      orbitCam.wheelDeltaPercentage = 0.01;
      orbitCam.panningSensibility = 2000;

      const freeCam = new BABYLON.UniversalCamera("freeCam", v3(0, 25, -180), scene);
      freeCam.setTarget(BABYLON.Vector3.Zero());
      freeCam.speed = 1.2;
      freeCam.angularSensibility = 4000;
      freeCam.minZ = 0.1;

      // WASD + QE + Shift sprint
      freeCam.keysUp.push(87);    // W
      freeCam.keysDown.push(83);  // S
      freeCam.keysLeft.push(65);  // A
      freeCam.keysRight.push(68); // D
      // Q/E lo implementamos manualmente (subir/bajar), y Shift sprint tambiÃ©n:
      let keyState = new Set();
      window.addEventListener("keydown", (e) => keyState.add(e.code));
      window.addEventListener("keyup", (e) => keyState.delete(e.code));

      // modo inicial: Libre
      let cameraMode = "free"; // "free" | "orbit"
      scene.activeCamera = freeCam;
      freeCam.attachControl(canvas, true);

      // pointer lock para ratÃ³n (solo en libre)
      scene.onPointerDown = () => {
        if (cameraMode !== "free") return;
        if (document.pointerLockElement !== canvas) {
          canvas.requestPointerLock?.();
        }
      };

      document.addEventListener("pointerlockchange", () => {
        // nada, solo para tener el hook listo
      });

      camBtn.addEventListener("click", () => {
        if (cameraMode === "free") {
          // a orbit
          cameraMode = "orbit";
          camBtn.textContent = "CÃ¡mara: Orbit";
          freeCam.detachControl(canvas);
          orbitCam.attachControl(canvas, true);
          scene.activeCamera = orbitCam;
          // suelta pointer lock si estaba
          if (document.pointerLockElement === canvas) document.exitPointerLock?.();
        } else {
          // a free
          cameraMode = "free";
          camBtn.textContent = "CÃ¡mara: Libre";
          orbitCam.detachControl(canvas);
          freeCam.attachControl(canvas, true);
          scene.activeCamera = freeCam;
        }
      });

      // --- Luz ---
      new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene).intensity = 0.18;
      const sunLight = new BABYLON.PointLight("sunLight", BABYLON.Vector3.Zero(), scene);
      sunLight.intensity = 3.4;
      sunLight.range = 4000;

      // --- Postprocess look (bloom / exposure) ---
      scene.imageProcessingConfiguration.exposure = 1.25;
      scene.imageProcessingConfiguration.contrast = 1.15;

      const pipeline = new BABYLON.DefaultRenderingPipeline("pipe", true, scene, [orbitCam, freeCam]);
      pipeline.bloomEnabled = true;
      pipeline.bloomThreshold = 0.75;
      pipeline.bloomWeight = 0.65;
      pipeline.bloomKernel = 64;
      pipeline.bloomScale = 0.5;

      // Glow (para emisivos)
      const glowLayer = new BABYLON.GlowLayer("glow", scene, { blurKernelSize: 64 });
      glowLayer.intensity = 0.6;

      // --- Starfield (puntos) ---
      // Colocamos muchas "estrellas" en una esfera enorme
      const stars = new BABYLON.PointsCloudSystem("stars", 2, scene);
      const starRadius = 1600;
      const starCount = 6000;

      stars.addPoints(starCount, (p) => {
        // distribuciÃ³n uniforme aproximada en esfera
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const r = starRadius;

        p.position.x = r * Math.sin(phi) * Math.cos(theta);
        p.position.y = r * Math.cos(phi);
        p.position.z = r * Math.sin(phi) * Math.sin(theta);

        // brillo aleatorio (blanco/azulado/amarillento leve)
        const t = Math.random();
        const base = 0.7 + Math.random() * 0.3;
        p.color = new BABYLON.Color4(
          base * (t < 0.33 ? 0.95 : 1.0),
          base * (t < 0.66 ? 0.95 : 1.0),
          base * (t < 0.33 ? 1.0 : 0.95),
          1.0
        );
      });

      let starsMesh = null;
      stars.buildMeshAsync().then((m) => {
        starsMesh = m;
        starsMesh.isPickable = false;
        starsMesh.alwaysSelectAsActiveMesh = true;
        starsMesh.position.set(0,0,0);
        // que no afecte a la luz
        starsMesh.material = new BABYLON.StandardMaterial("starsMat", scene);
        starsMesh.material.emissiveColor = new BABYLON.Color3(1,1,1);
        starsMesh.material.disableLighting = true;
        starsMesh.material.pointsCloud = true;
        starsMesh.material.pointSize = 1.0;
      });

      // --- GUI etiquetas ---
      const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("ui", true, scene);

      // ===========================
      // Datos (artÃ­sticos) N-Body
      // ===========================
      const bodiesDef = [
        { name:"Sol",      type:"Sun",    color: new BABYLON.Color3(1.0, 0.75, 0.2),  radius: 10,  mass: 100000, distance: 0 },
        { name:"Mercurio", type:"Planet", color: new BABYLON.Color3(0.70,0.70,0.72),  radius: 0.8, mass: 0.055,  distance: 14 },
        { name:"Venus",    type:"Planet", color: new BABYLON.Color3(0.90,0.78,0.55),  radius: 1.2, mass: 0.815,  distance: 18 },
        { name:"Tierra",   type:"Planet", color: new BABYLON.Color3(0.25,0.45,0.95),  radius: 1.3, mass: 1.0,    distance: 23, atmosphere:true },
        { name:"Marte",    type:"Planet", color: new BABYLON.Color3(0.90,0.35,0.20),  radius: 1.0, mass: 0.107,  distance: 28 },
        { name:"JÃºpiter",  type:"Planet", color: new BABYLON.Color3(0.88,0.75,0.55),  radius: 3.3, mass: 317.8,  distance: 38 },
        { name:"Saturno",  type:"Planet", color: new BABYLON.Color3(0.90,0.82,0.55),  radius: 2.9, mass: 95.2,   distance: 50, rings:true },
        { name:"Urano",    type:"Planet", color: new BABYLON.Color3(0.55,0.85,0.90),  radius: 2.1, mass: 14.5,   distance: 62 },
        { name:"Neptuno",  type:"Planet", color: new BABYLON.Color3(0.25,0.45,0.95),  radius: 2.0, mass: 17.1,   distance: 74 }
      ];

      const moonDef = { name:"Luna", type:"Moon", color: new BABYLON.Color3(0.82,0.82,0.86), radius: 0.35, mass: 0.0123, parent:"Tierra", moonDistance: 2.8 };

      // ===========================
      // Crear cuerpos + estado fÃ­sico
      // ===========================
      const bodies = [];
      const labels = [];
      const trails = [];

      function createTrail(color3){
        const maxPoints = 1400;
        const points = [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()];
        const line = BABYLON.MeshBuilder.CreateLines("trail", { points, updatable: true }, scene);
        line.color = color3;
        line.isPickable = false;
        line.isVisible = trailsEl.checked;
        line.alwaysSelectAsActiveMesh = true;
        return { line, points: [], maxPoints };
      }

      function addBody(def, initialPosition, initialVelocity){
        const mesh = BABYLON.MeshBuilder.CreateSphere(def.name, { diameter: def.radius * 2, segments: 28 }, scene);

        let atmosphereMesh = null;

        if (def.type === "Sun") {
          mesh.material = makeEmissiveMaterial(scene, "mat_"+def.name, def.color);
          // corona billboard (look Seb)
          const coronaTex = createRadialSpriteTexture(scene, "coronaTex", 512);
          const corona = BABYLON.MeshBuilder.CreatePlane("SunCorona", { size: def.radius * 6.0 }, scene);
          corona.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
          const coronaMat = new BABYLON.StandardMaterial("coronaMat", scene);
          coronaMat.diffuseTexture = coronaTex;
          coronaMat.diffuseTexture.hasAlpha = true;
          coronaMat.useAlphaFromDiffuseTexture = true;
          coronaMat.emissiveColor = new BABYLON.Color3(1, 0.7, 0.25);
          coronaMat.disableLighting = true;
          coronaMat.alpha = 0.9;
          corona.material = coronaMat;
          corona.parent = mesh;
          corona.isPickable = false;

          glowLayer.addIncludedOnlyMesh(mesh);
          glowLayer.addIncludedOnlyMesh(corona);

        } else {
          mesh.material = makeLitMaterial(scene, "mat_"+def.name, def.color);
        }

        // AtmÃ³sfera Tierra (fresnel halo)
        if (def.atmosphere) {
          atmosphereMesh = BABYLON.MeshBuilder.CreateSphere(def.name+"_Atmo", { diameter: def.radius * 2.22, segments: 28 }, scene);
          atmosphereMesh.parent = mesh;
          atmosphereMesh.isPickable = false;

          const atmoMat = new BABYLON.StandardMaterial(def.name+"_AtmoMat", scene);
          atmoMat.diffuseColor = new BABYLON.Color3(0,0,0);
          atmoMat.emissiveColor = new BABYLON.Color3(0.25,0.55,1.0);
          atmoMat.specularColor = new BABYLON.Color3(0,0,0);
          atmoMat.disableLighting = true;
          atmoMat.alpha = 0.25;

          // Fresnel para borde brillante
          atmoMat.emissiveFresnelParameters = new BABYLON.FresnelParameters();
          atmoMat.emissiveFresnelParameters.bias = 0.0;
          atmoMat.emissiveFresnelParameters.power = 3.0;
          atmoMat.emissiveFresnelParameters.leftColor = new BABYLON.Color3(0.10, 0.25, 0.55);
          atmoMat.emissiveFresnelParameters.rightColor = new BABYLON.Color3(0.45, 0.80, 1.0);

          // MÃ¡s â€œadditiveâ€ aproximado
          atmoMat.alphaMode = BABYLON.Engine.ALPHA_ADD;

          atmosphereMesh.material = atmoMat;
          glowLayer.addIncludedOnlyMesh(atmosphereMesh);
        }

        // Anillos Saturno (visual)
        let ring = null;
        if (def.rings) {
          ring = BABYLON.MeshBuilder.CreateTorus(def.name+"_Rings", {
            diameter: def.radius * 3.8,
            thickness: def.radius * 0.35,
            tessellation: 96
          }, scene);
          ring.parent = mesh;
          ring.rotation.x = Math.PI / 2.15;
          const ringMat = new BABYLON.StandardMaterial("ringMat", scene);
          ringMat.diffuseColor = new BABYLON.Color3(0.85,0.80,0.65);
          ringMat.alpha = 0.55;
          ringMat.specularColor = new BABYLON.Color3(0.05,0.05,0.05);
          ringMat.disableLighting = false;
          ring.material = ringMat;
          ring.isPickable = false;
        }

        mesh.position.copyFrom(initialPosition);

        const body = {
          name: def.name,
          type: def.type,
          mass: def.mass,
          radius: def.radius,
          mesh,
          ring,
          atmosphereMesh,
          velocity: initialVelocity.clone(),
        };

        bodies.push(body);

        const lbl = createLabel(gui, def.name, mesh);
        lbl.isVisible = labelsEl.checked;
        labels.push(lbl);

        const tr = createTrail(def.type === "Sun"
          ? new BABYLON.Color3(0.9,0.7,0.3)
          : def.color.scale(0.85)
        );
        trails.push(tr);

        return body;
      }

      // Inicializar Sol
      const sunDef = bodiesDef.find(b => b.name === "Sol");
      const sun = addBody(sunDef, v3(0,0,0), v3(0,0,0));

      // Velocidad circular alrededor del Sol: v = sqrt(G*M / r)
      function circularOrbitVelocityAroundSun(r){
        const mu = Universe.gravitationalConstant * sun.mass;
        return Math.sqrt(mu / r);
      }

      // Crear planetas
      const planetBodies = new Map();
      for (const def of bodiesDef) {
        if (def.name === "Sol") continue;
        const r = def.distance;
        const pos = v3(r, 0, 0);
        const v = circularOrbitVelocityAroundSun(r);
        const vel = v3(0, 0, v);
        const pb = addBody(def, pos, vel);
        planetBodies.set(def.name, pb);
      }

      // AÃ±adir Luna como cuerpo N-Body
      const earth = planetBodies.get("Tierra");
      if (earth) {
        const moonPos = earth.mesh.position.add(v3(moonDef.moonDistance, 0, 0));
        const muE = Universe.gravitationalConstant * earth.mass;
        const vMoon = Math.sqrt(muE / moonDef.moonDistance);
        const moonVel = earth.velocity.add(v3(0, 0, vMoon));
        addBody(moonDef, moonPos, moonVel);
      }

      // Toggles
      labelsEl.addEventListener("change", () => {
        for (const l of labels) l.isVisible = labelsEl.checked;
      });
      trailsEl.addEventListener("change", () => {
        for (const t of trails) t.line.isVisible = trailsEl.checked;
      });

      // Focus Sol
      focusSunBtn.addEventListener("click", () => {
        orbitCam.setTarget(sun.mesh.position);
        freeCam.setTarget(sun.mesh.position);
      });

      // Reset
      resetBtn.addEventListener("click", () => {
        paused = false;
        pauseBtn.textContent = "Pausar";

        // Sol
        const sunB = bodies.find(b=>b.name==="Sol");
        sunB.mesh.position.set(0,0,0);
        sunB.velocity.set(0,0,0);

        // Planetas
        for (const def of bodiesDef) {
          if (def.name === "Sol") continue;
          const b = bodies.find(x=>x.name===def.name);
          if (!b) continue;
          const r = def.distance;
          b.mesh.position.set(r,0,0);
          b.velocity.set(0,0,circularOrbitVelocityAroundSun(r));
        }

        // Luna
        const moon = bodies.find(b=>b.name==="Luna");
        const earthNow = bodies.find(b=>b.name==="Tierra");
        if (moon && earthNow) {
          moon.mesh.position.copyFrom(earthNow.mesh.position.add(v3(moonDef.moonDistance,0,0)));
          const muE = Universe.gravitationalConstant * earthNow.mass;
          const vMoon = Math.sqrt(muE / moonDef.moonDistance);
          moon.velocity.copyFrom(earthNow.velocity.add(v3(0,0,vMoon)));
        }

        // Limpia trails
        for (const t of trails) {
          t.points = [];
          BABYLON.MeshBuilder.CreateLines(null, { points: [BABYLON.Vector3.Zero(), BABYLON.Vector3.Zero()], instance: t.line });
        }
      });

      // ===========================
      // FÃ­sica N-Body (fixed timestep)
      // ===========================
      let accumulator = 0;

      function physicsStep(dt){
        const G = Universe.gravitationalConstant;

        // aceleraciones
        const accelerations = bodies.map(() => v3(0,0,0));
        for (let i=0;i<bodies.length;i++){
          const bi = bodies[i];
          const pi = bi.mesh.position;
          let ai = v3(0,0,0);
          for (let j=0;j<bodies.length;j++){
            if (i===j) continue;
            const bj = bodies[j];
            ai = ai.add(gravAccel(pi, bj.mesh.position, bj.mass, G));
          }
          accelerations[i] = ai;
        }

        // integraciÃ³n symplectic Euler
        for (let i=0;i<bodies.length;i++){
          const b = bodies[i];
          b.velocity = b.velocity.add(accelerations[i].scale(dt));
          b.mesh.position = b.mesh.position.add(b.velocity.scale(dt));
        }

        // rotaciÃ³n visual (estÃ©tica)
        for (const b of bodies){
          if (b.type === "Sun") b.mesh.rotation.y += 0.002;
          else b.mesh.rotation.y += 0.02;
          if (b.ring) b.ring.rotation.z += 0.01;
          if (b.atmosphereMesh) b.atmosphereMesh.rotation.y += 0.01;
        }
      }

      function updateTrails(){
        if (!trailsEl.checked) return;
        for (let i=0;i<bodies.length;i++){
          const b = bodies[i];
          const t = trails[i];

          t.points.push(b.mesh.position.clone());
          if (t.points.length > t.maxPoints) t.points.shift();

          if (t.points.length >= 2) {
            BABYLON.MeshBuilder.CreateLines(null, { points: t.points, instance: t.line });
          }
        }
      }

      // ===========================
      // FreeFly: Q/E + Shift sprint
      // ===========================
      function updateFreeFly(dt){
        if (cameraMode !== "free") return;

        const base = freeCam.speed;
        const sprint = keyState.has("ShiftLeft") || keyState.has("ShiftRight");
        const spd = (sprint ? base * 2.6 : base) * (dt * 60);

        if (keyState.has("KeyQ")) freeCam.position.y -= spd;
        if (keyState.has("KeyE")) freeCam.position.y += spd;
      }

      // ===========================
      // Render loop
      // ===========================
      scene.onBeforeRenderObservable.add(() => {
        const realDt = engine.getDeltaTime() / 1000;
        stepsValEl.textContent = "0";

        updateFreeFly(realDt);

        if (!paused && timeScale > 0) {
          const simDt = realDt * timeScale;
          accumulator += simDt;

          const h = Universe.physicsTimeStep;
          let steps = 0;
          const maxStepsPerFrame = 2000;

          while (accumulator >= h && steps < maxStepsPerFrame) {
            physicsStep(h);
            accumulator -= h;
            steps++;
          }
          stepsValEl.textContent = String(steps);

          updateTrails();

          // que las estrellas sigan a la cÃ¡mara (evita sensaciÃ³n de "moverte por ellas")
          if (starsMesh && scene.activeCamera) {
            starsMesh.position.copyFrom(scene.activeCamera.position);
          }
        }

        // pequeÃ±a â€œrespiraciÃ³nâ€ en corona del sol
        const sunMesh = bodies.find(b=>b.name==="Sol")?.mesh;
        if (sunMesh) {
          const t = performance.now() * 0.001;
          sunLight.intensity = 3.2 + Math.sin(t*0.8)*0.15;
        }
      });

      return scene;
    };

    const scene = createScene();
    engine.runRenderLoop(() => scene.render());
    window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
